                          Б. Я. PЯБКО
                         А. Н. ФИОНОВ




КРИПТОГРАФИЧЕСКИЕ МЕТОДЫ
   ЗАЩИТЫ ИНФОРМАЦИИ
                  2-е издание, стереотипное


  Рекомендовано УМО по образованию в области телекоммуникаций
в качестве учебного пособия для студентов высших учебных заведений,
                  обучающихся по специальностям:
       «Многоканальные телекоммуникационные системы»,
           «Радиосвязь, радиовещание и телевидение»,
                  «Защищенные системы связи»




                          Москва
                 Горячая линия — Телеком
                           2012
  К 691.391
  К 32.801.4
    98

                                  :                      .               ,                                      . .

       Ря к       . ., Ф                     . Н.
Р 98     К                                                                                                                :
                 . – 2-         ,                                               .–             .:                                   –                ,
       2012. – 229 c.: .
        ISBN 978-5-9912-0286-2.
          И
                          ,                                                            ,                                                             -
          .                                                                                                                                   ,      -

                                                                     .                                                                               -
                              ,                                                            ,
                    ,                                                              ,                                                    -            ,

                                                                                                                                                  .И -
                                                                                                                                ,                    -
                                                                                                            .                                        -
              ,                                                                                                                                      -
                              .                                                                         ,                                            -
                                                                                                    .
                                      ,                                                                               «                             »,
                                                     .
                                                                                                                                            32.801.4
                    А                      ль                    И                     www.techbook.ru



                                          Ря к
                                      Ф

              К                       ф      к                           ы         щ           ы                 ф
                                                Уч

                                                                             . .


                  05 06 2012              60×90/16           -           14,5                  500              (1-           200   )И      № 120286

ISBN 978-5-9912-0286-2                                                   ©      . .                             , . .               , 2005, 2012
                                                 © И                                    «                                      −         », 2012
ПРЕДИСЛОВИЕ




В течение многих столетий криптография, т.е. наука о шифровании,
или «закрытии» информации от несанкционированного использова-
ния, применялась в основном для защиты сообщений, которыми об-
менивались государственные чиновники или военные. Поэтому круг
людей, применявших криптографию, был весьма ограничен, а сами
методы этой науки секретны. Однако в последние десятилетия, когда
человечество вступило в стадию информационного общества, крип-
тографические методы защиты информации стали использоваться
очень широко, обслуживая, в первую очередь, потребности бизне-
са. Причем имеются в виду не только межбанковские расчеты по
компьютерным сетям или, скажем, биржи, в которых все расчеты
проводятся через Интернет, но и многочисленные операции, в ко-
торых ежедневно участвуют миллионы, если не миллиарды «обыч-
ных» людей, а именно: расчеты по кредитным карточкам, перевод
заработной платы в банк, заказ билетов через Интернет, покупки
в Интернет-магазинах и т.д., и т.п. Естественно, все эти операции,
как и, скажем, разговоры по мобильным телефонам и электронная
почта, должны быть защищены от нечестных или просто чрезмерно
любопытных людей и организаций. Поэтому в наши дни в разработ-
ку и эксплуатацию систем защиты информации вовлечено множе-
ство специалистов, работающих в сфере информационных техноло-
гий. Так как многие из таких методов основываются на результатах
современной криптографии, то теперь эта дисциплина преподается
на факультетах университетов, готовящих специалистов по инфор-
мационным технологиям.
     Предлагаемое учебное пособие в значительной степени базирует-
ся на курсе лекций, который профессор Б. Я. Рябко читал сначала
аспирантам, а затем студентам Сибирского государственного уни-
верситета телекоммуникаций и информатики, обучавшимся по спе-
циальностям, связанным с программированием и компьютерными
сетями, и для которых курс «Защита информации» является обя-
зательным. Как можно заключить из названия, эта книга предна-
4                                                  Предисловие

значена для студентов и инженеров, специализирующихся в области
информационных технологий, поэтому она рассчитана на людей со
знанием математики в объеме, даваемом в технических вузах. Все
необходимые сведения из теории чисел и теории вероятностей при-
водятся в книге, причем не в виде отдельных разделов, а по мере
необходимости. Такой стиль позволяет поддерживать интерес сту-
дентов на лекциях и, как мы надеемся, поможет и читателям книги.
     При изложении материала мы старались следовать принципу
А. Эйнштейна «Все должно делаться настолько просто, насколь-
ко это возможно, но не проще» и соблюдать правило «. . . Кратко
и подробно», сформулированное одним из героев известной поэмы
А. Твардовского. Поэтому мы не пытались описать всю современ-
ную криптографию на строгом математическом уровне и во всей
общности, но, как нам кажется, рассмотрели основные идеи и ме-
тоды криптографии, применяемые в информационных технологиях,
как мы надеемся, без их вульгаризации. При этом, хотя главный
упор в книге делается на объяснение основных идей и принципов,
в ней содержится также точное описание целого ряда практически
используемых методов, в том числе и российских ГОСТов на крип-
тографические алгоритмы.
     Содержание первых пяти глав может быть основой семестрового
курса. Другие главы могут быть использованы при чтении спецкур-
сов. Наш опыт показывает, что усвоению материала помогают прак-
тические занятия и лабораторные работы в компьютерных классах,
в ходе которых студенты реализуют все основные алгоритмы из ука-
занных глав. Поэтому пособие содержит снабженные ответами зада-
чи и темы лабораторных работ.
     Мы надеемся, что это учебное пособие поможет читателям не
только понять основные задачи и методы современной криптогра-
фии, но и оценить красоту и изящество ее идей и результатов.
Глава 1.     ВВЕДЕНИЕ




Мы начинаем изложение основ криптографии с классической зада-
чи передачи секретных сообщений от некоторого отправителя A к
получателю B .
    Отправитель сообщений и их получатель могут быть физиче-
скими лицами, организациями, какими-либо техническими система-
ми. Иногда об A и B говорят как об абонентах некоторой сети,
о пользователях некоторой компьютерной системы или, еще более
формально, как об абстрактных «сторонах» (англоязычный термин
«party») или «сущностях» (entity), участвующих в информационном
взаимодействии. Но чаще бывает удобно отождествлять участников
обмена с некоторыми людьми и заменить формальные обозначения
A и B на Алиса и Боб.
    Предполагается, что сообщения передаются по так называемо-
му «открытому» каналу связи, в принципе доступному для прослу-
шивания некоторым другим лицам, отличным от получателя и от-
правителя. Такая ситуация возникает при радиопередаче сообщений
(например, посредством мобильного телефона) и возможна при ис-
пользовании даже таких «проверенных» каналов связи, как прово-
лочный телефон, телеграф, да и обычная почта. Особый интерес как
средство передачи данных, стремительно завоевывающее лидирую-
щие позиции во всем мире и в то же время чрезвычайно уязвимое с
точки зрения возможности несанкционированного доступа третьих
лиц, представляет Интернет. В этой среде легко реализуется не толь-
ко копирование, но и подмена передаваемых сообщений.
    В криптографии обычно предполагается, что у лица, передаю-
щего сообщения и (или) их принимающего, есть некоторый против-
ник E , который может быть конкурентом в бизнесе, членом преступ-
ной группировки, представителем иностранной разведки или даже
чрезмерно ревнивой женой, и этот противник может перехватывать
сообщения, передаваемые по открытому каналу, и анализировать их.
Часто удобно рассматривать противника как некую особу по имени
Ева, которая имеет в своем распоряжении мощную вычислительную
6                                              Глава 1. Введение

технику и владеет методами криптоанализа. Естественно, Алиса и
Боб хотят, чтобы их сообщения были непонятны Еве, и используют
для этого специальные шифры.

    Перед тем как передать сообщение по открытому каналу связи
от A к B , A шифрует сообщение, а B , приняв зашифрованное со-
общение, дешифрует его, восстанавливая исходный текст. Важно то,
что в рассматриваемой нами в этой главе задаче Алиса и Боб могут
договариваться об используемом ими шифре (или, скорее, о неко-
торых его параметрах) не по открытому каналу, а по специальному
«закрытому» каналу, недоступному для прослушивания противни-
ком. Такой «закрытый канал» может быть организован при помо-
щи курьеров, или же Алиса и Боб могут обмениваться шифрами во
время личной встречи и т.п. При этом надо учитывать, что обычно
организация такого закрытого канала и передача по нему сообщений
слишком дороги по сравнению с открытым каналом и (или) закры-
тый канал не может быть использован в любое время. Например,
курьерская почта намного дороже обычной, передача сообщений с
ее помощью происходит намного медленнее, чем, скажем, по теле-
графу, да и использовать ее можно не в любое время суток и не в
любой ситуации.

     Чтобы быть более конкретными, рассмотрим пример шифра.
Так как проблема шифрования сообщений возникла еще в глубокой
древности, некоторые шифры связаны с именами известных истори-
ческих личностей и в качестве первых примеров обычно используют
именно такие шифры. Мы также будем придерживаться этой тради-
ции. Начнем с известного шифра Гая Юлия Цезаря (см., например,
[2, 28]), адаптировав его к русскому языку. В этом шифре каждая
буква сообщения заменяется на другую, номер которой в алфавите
на три больше. Например, А заменяется на Г, Б на Д и т.д. Три
последние буквы русского алфавита — Э, Ю, Я — шифруются бук-
вами А, Б, В соответственно. Например, слово ПЕРЕМЕНА после
применения к нему шифра Цезаря превращается в ТИУИПИРГ (ес-
ли исключить букву Ё и считать, что в алфавите 32 буквы).

    Последующие римские цезари модифицировали шифр, исполь-
зуя смещение в алфавите на четыре, пять и более букв. Мы можем
описать их шифр в общем виде, если пронумеруем (закодируем) бук-
вы русского алфавита числами от 0 до 31 (исключив букву Ё). Тогда
Глава 1. Введение                                                 7

правило шифрования запишется следующим образом:

                            c = (m + k) mod 32,                (1.1)

где m и c — номера букв соответственно сообщения и шифротекста,
а k — некоторое целое число, называемое ключом шифра (в рассмот-
ренном выше шифре Цезаря k = 3). (Здесь и в дальнейшем a mod b
обозначает остаток от деления целого числа a на целое число b ,
причем остаток берется из множества {0, 1, . . . , b − 1}. Например,
13 mod 5 = 3 .)
    Чтобы дешифровать зашифрованный текст, нужно применить
«обратный» алгоритм

                            m = (c − k) mod 32.                (1.2)

    Можно представить себе ситуацию, когда источник и получа-
тель сообщений договорились использовать шифр (1.1), но для того,
чтобы усложнить задачу противника, решили иногда менять ключ
шифра. Для этого Алиса каким-либо образом генерирует число k ,
передает его Бобу по закрытому каналу связи, и после этого они об-
мениваются сообщениями, зашифрованными с помощью этого клю-
ча k . Замену ключа можно проводить, например, перед каждым
сеансом связи или после передачи фиксированного числа букв (ска-
жем, каждую десятку символов шифровать со своим k ) и т.п. В та-
ком случае говорят, что ключ порождается источником ключа. Схе-
ма рассмотренной криптосистемы с секретным ключом приведена
на рис. 1.1.                   ✓✏
                                E
                               ✒✑
    ✓✏                                                     ✓✏
     A     ✲ шифратор            ❄       ✲ дешифратор ✲ B
    ✒✑                                                     ✒✑
                 ✻        открытый канал        ✻

    источник        r   ✄                         ❣
    ключа               ✂
                              закрытый канал


           Рис. 1.1. Классическая система секретной связи
8                                                 Глава 1. Введение

     Обратимся теперь к анализу действий противника, пытающего-
ся расшифровать сообщение и узнать секретный ключ, иными слова-
ми, вскрыть, или взломать шифр. Каждая попытка вскрытия шифра
называется атакой на шифр (или на криптосистему). В криптогра-
фии принято считать, что противник может знать использованный
алгоритм шифрования, характер передаваемых сообщений и пере-
хваченный шифротекст, но не знает секретный ключ. Это называется
«правилом Керкхоффса» (см. [28]) в честь ученого, впервые сформу-
лировавшего основные требования к шифрам (A. Kerckhoﬀs, 1883).
Иногда это правило кажется «перестраховкой», но такая «перестра-
ховка» отнюдь не лишняя, если, скажем, передается распоряжение
о переводе миллиона долларов с одного счета на другой.
     В нашем примере Ева знает, что шифр был построен в соответ-
ствии с (1.1), что исходное сообщение было на русском языке и что
был передан шифротекст ТИУИПИРГ, но ключ Еве не известен.
     Наиболее очевидная попытка расшифровки — последователь-
ный перебор всех возможных ключей (это так называемый метод
«грубой силы» (brute-force attack)). Итак, Ева перебирает последова-
тельно все возможные ключи k = 1, 2, . . . , подставляя их в алгоритм
дешифрования и оценивая получающиеся результаты. Попробуем и
мы использовать этот метод. Результаты дешифрования по (1.2) при
различных ключах и шифротексте ТИУИПИРГ сведены в табл. 1.1.
В большинстве случаев нам достаточно было расшифровать две–три
буквы, чтобы отвергнуть соответствующий ключ (из-за отсутствия
слова в русском языке, начинающегося с такого фрагмента).


    Т а б л и ц а 1.1. Pасшифровка слова ТИУИПИРГ путем
                       перебора ключей
    k   m             k    m        k    m      k    m
    1   СЗТ            9   ЙЯ       17   БЧ     25   ЩП
    2   РЖС           10   ИЮЙ      18   АЦБ    26   ШОЩ
    3   ПЕРЕМЕНА      11   ЗЭИ      19   ЯХА    27   ЧН
    4   ОДП           12   ЖЬ       20   ЮФ     28   ЦМ
    5   НГ            13   ЕЫ       21   ЭУ     29   ХЛЦ
    6   МВ            14   ДЪ       22   Ь      30   ФК
    7   ЛБМ           15   ГЩ       23   Ы      31   УЙ
    8   КАЛАЗ         16   ВШГ      24   Ъ      32   ТИУИПИРГ


   Из табл. 1.1 мы видим, что был использован ключ k = 3 и
зашифровано сообщение ПЕРЕМЕНА. Причем для того, чтобы про-
Глава 1. Введение                                                9

верить остальные возможные значения ключа, нам не требовалось
дешифровать все восемь букв, а в большинстве случаев после ана-
лиза двух–трех букв ключ отвергался (только при k = 8 надо было
дешифровать пять букв, зато при k = 22, 23, 24 хватало и одной, так
как в русском языке нет слов, начинающихся с Ь, Ъ, Ы).
    Из этого примера мы видим, что рассмотренный шифр совер-
шенно нестоек, для его вскрытия достаточно проанализировать нес-
колько первых букв сообщения и после этого ключ k однозначно
определяется (и, следовательно, однозначно дешифруется все сооб-
щение).
    В чем же причины нестойкости рассмотренного шифра и как
можно было бы увеличить его стойкость? Рассмотрим еще один при-
мер. Алиса спрятала важные документы в ячейке камеры хранения,
снабженной пятидекадным кодовым замком. Теперь она хотела бы
сообщить Бобу комбинацию цифр, открывающую ячейку. Она реши-
ла использовать аналог шифра Цезаря, адаптированный к алфавиту,
состоящему из десятичных цифр:

                       c = (m + k) mod 10.                    (1.3)

Допустим, Алиса послала Бобу шифротекст 26047. Ева пытается рас-
шифровать его, последовательно перебирая все возможные ключи.
Результаты ее попыток сведены в табл. 1.2.


          Т а б л и ц а 1.2. Pасшифровка сообщения
                             26047 путем перебора ключей
            k        m              k        m
            1        15936          6        60481
            2        04825          7        59370
            3        93714          8        48269
            4        82603          9        37158
            5        71592          0        26047

    Мы видим, что все полученные варианты равнозначны и Ева не
может понять, какая именно комбинация истинна. Анализируя шиф-
ротекст, она не может найти значения секретного ключа. Конечно, до
перехвата сообщения у Евы было 105 возможных значений кодовой
комбинации, а после — только 10. Однако важно отметить то, что в
данном случае всего 10 значений ключа. Поэтому при таком ключе
10                                             Глава 1. Введение

(одна десятичная цифра) Алиса и Боб и не могли расчитывать на
бо́льшую секретность.
     В первом примере сообщение — текст на русском языке, поэто-
му оно подчиняется многочисленным правилам, различные буквы
и их сочетания имеют различные вероятности и, в частности, мно-
гие наборы букв вообще запрещены. (Это свойство называется из-
быточностью текста). Поэтому-то и удалось легко подобрать ключ
и дешифровать сообщение, т.е. избыточность позволила «взломать»
шифр. В противоположность этому, во втором примере все комби-
нации цифр допустимы. «Язык» кодового замка не содержит избы-
точности. Поэтому даже простой шифр, примененный к сообщени-
ям этого языка, становится невскрываемым. В классической работе
К. Шеннона [19] построена глубокая и изящная теория шифров с
секретным ключом и, в частности, предложена «правильная» коли-
чественная мера избыточности. Мы кратко коснемся этих вопросов в
главе 7, а в главе 8 будут описаны современные шифры с секретным
ключом.
     Описанная в приведенных примерах атака называется атакой
по шифротексту. Но часто на шифр может быть проведена атака
по известному тексту. Это происходит, если Ева получает в свое
распоряжение какие-либо открытые тексты, соответствующие ран-
нее переданным зашифрованным. Сопоставляя пары «текст–шифро-
текст», Ева пытается узнать секретный ключ, чтобы с его помощью
дешифровать все последующие сообщения от Алисы к Бобу.
     Можно представить себе и более «серьезную» атаку — атаку по
выбранному тексту, когда противник пользуется не только предо-
ставленными ему парами «текст–шифротекст», но может и сам фор-
мировать нужные ему тексты и шифровать их с помощью того клю-
ча, который он хочет узнать. Например, во время Второй мировой
войны американцы, подкупив охрану, выкрали шифровальную ма-
шину в японском посольстве на два дня и имели возможность по-
давать ей на вход различные тексты и получать соответствующие
шифровки. (Они не могли взломать машину с целью непосредствен-
ного определения заложенного в нее секретного ключа, так как это
было бы замечено и повлекло бы за собой смену всех ключей.)
     Может показаться, что атаки по известному и выбранному тек-
сту надуманы и далеко не всегда возможны. Отчасти это так. Но раз-
работчики современных криптосистем стремятся сделать их неуяз-
вимыми даже и по отношению к атакам по выбранному тексту, и
Задачи и упражнения                                           11

на этом пути достигнуты значительные успехи. Иногда считается,
что более надежно использовать шифр, противостоящий атаке по
выбранному тексту, чем организационно обеспечивать неосуществи-
мость такой атаки, хотя наиболее осторожные пользователи делают
и то, и другое.
     Итак, мы познакомились с основными героями криптографии —
Алисой, Бобом и Евой и с важными понятиями этой науки — шиф-
ром, ключом, атакой, открытым и защищенным каналом. Заметим,
что с последним понятием связан один интригующий факт — воз-
можно построение надежных криптосистем без защищенного канала!
В таких системах Алиса и Боб вычисляют секретный ключ так, что
Ева не может этого сделать. Это открытие было сделано в осново-
полагающих работах Диффи, Хеллмана и Меркля (см., например,
[22]) в 1976 году и открыло новую эру в современной криптографии.
Большая часть этой книги будет связана именно с такими система-
ми, называемыми схемами с открытым, или несимметричным клю-
чом.

Задачи и упражнения
 1.1. Определить ключи шифра Цезаря, если известны следующие
      пары открытый текст – шифротекст:
        а. АПЕЛЬСИН – САЦЬНВЩЮ,
        б. АБРИКОС – ЫЬЛГЕЙМ.

 1.2. Расшифровать следующие сообщения, зашифрованные шиф-
      ром Цезаря с неизвестным ключом k , 0 < k < 32:
        а. ФХНЗКЧ,
        б. ЦЩЕБФ.
Глава 2.     КРИПТОСИСТЕМЫ С ОТКРЫТЫМ
             КЛЮЧОМ




2.1.   Предыстория и основные идеи
Рассмотрим три задачи, решение которых поможет нам лучше по-
нять идеи и методы криптографии с открытым ключом. Все эти
задачи имеют важное практическое значение.
    Первая задача — хранение паролей в компьютере. Мы знаем,
что каждый пользователь в сети имеет свой секретный пароль. При
входе в сеть пользователь указывает свое имя (несекретное) и затем
вводит пароль. Проблема состоит в следующем: если хранить пароль
на диске компьютера, то Ева может прочитать его, а затем использо-
вать для несанкционированного доступа (особенно легко это сделать,
если Ева работает системным администратором этой сети). Поэтому
необходимо организовать хранение паролей в компьютере так, чтобы
такой «взлом» был невозможен.
    Вторая задача возникла с появлением радиолокаторов и систе-
мы ПВО. При пересечении самолетом границы радиолокатор спра-
шивает пароль. Если пароль верный, то самолет «свой», в против-
ном случае — «чужой». Здесь возникает такая проблема: так как па-
роль должен передаваться по открытому каналу (воздушной среде),
то противник может прослушивать все переговоры и узнавать пра-
вильный пароль. Затем «чужой» самолет в случае запроса повторит
перехваченный ранее «правильный» пароль в качестве ответа лока-
тору и будет пропущен.
    Третья задача похожа на предыдущую и возникает в компью-
терных сетях с удаленным доступом, например, при взаимодействии
банка и клиента. Обычно в начале сеанса банк запрашивает у кли-
ента имя, а затем секретный пароль, но Ева может узнать пароль,
так как линия связи открытая.
    Сегодня все эти проблемы решаются с использованием крипто-
графических методов. Решение всех этих задач основано на важном
понятии односторонней функции (one-way function).
2.1. Предыстория и основные идеи                               13

    Определение 2.1. Пусть дана функция

                             y = f (x),                      (2.1)

определенная на конечном множестве X (x ∈ X ), для которой су-
ществует обратная функция

                           x = f −1 (y).                     (2.2)

Функция называется односторонней, если вычисление по формуле
(2.1) — простая задача, требующая немного времени, а вычисление
по (2.2) — задача сложная, требующая привлечения массы вычисли-
тельных ресурсов, например, 106 –1010 лет работы мощного супер-
компьютера.

    Данное определение, безусловно, неформально. Строгое опреде-
ление односторонней функции может быть найдено в [26, 28], но для
наших целей достаточно и вышеприведенного.
    В качестве примера односторонней функции рассмотрим следу-
ющую:
                          y = ax modp,                       (2.3)
где p — некоторое простое число (т.е. такое, которое делится без
остатка только на себя и на единицу), а x — целое число из множе-
ства {1, 2, . . . , p − 1}. Обратная функция обозначается

                         x = loga y mod p                    (2.4)

и называется дискретным логарифмом.
     Для того чтобы обеспечить трудность вычисления по (2.4) при
использовании лучших современных компьютеров, в настоящее вре-
мя используются числа размером более 512 бит. На практике часто
применяются и другие односторонние функции, например, так назы-
ваемые хеш-функции, оперирующие с существенно более короткими
числами порядка 60–120 бит (они будут рассмотрены в главе 8).
     Сначала мы покажем, что вычисление по (2.3) может быть вы-
полнено достаточно быстро. Начнем с примера вычисления числа
a16 modp . Мы можем записать
                                         2
                   16
                                     2
                                   2 2
                  a modp =        a             modp,
14                   Глава 2. Криптосистемы с открытым ключом

т.е.значение данной функции вычисляется всего за 4 операции умно-
жения вместо 15 при «наивном» варианте a·a·. . .·a. На этом основан
общий алгоритм.                                            
     Для описания алгоритма введем величину t = log2 x — це-
лую часть log2 x (далее все логарифмы будут двоичные, поэтому в
дальнейшем мы не будем указывать основание 2). Вычисляем числа
ряда
                                           t
              a, a2 , a4 , a8 , . . . , a2   (mod p).          (2.5)
В ряду (2.5) каждое число получается путем умножения предыдуще-
го числа самого на себя по модулю p . Запишем показатель степени
x в двоичной системе счисления:

                          x = (xt xt−1 . . . x1 x0 )2 .

Тогда число y = ax modp может быть вычислено как
                                 t
                                 Y         i
                           y=          axi ·2 mod p                 (2.6)
                                 i=0

(все вычисления проводятся по модулю p ).
                                                100
   П р и ме р 2.1. Пусть требуется вычислить 3    mod 7 . Имеем
t = log 100 = 6. Вычисляем числа ряда (2.5):

                    a a2      a4    a8    a16    a32      a64
                                                                    (2.7)
                    3 2       4     2     4      2        4

Записываем показатель в двоичной системе счисления:

                             100 = (1100100)2

и проводим вычисления по формуле (2.6):

              a64   a32             a4
                                                                    (2.8)
              4 ·   2 ·     1 · 1 · 4 · 1 · 1               =   4

Нам потребовалось всего 8 операций умножения (6 для вычисления
ряда (2.7) и 2 для (2.8)).                                   ⊔
                                                             ⊓
     В общем случае справедливо следующее
2.1. Предыстория и основные идеи                                      15

    Утверждение 2.1 (о сложности вычислений (2.3)). Коли-
чество операций умножения при вычислении (2.3) по описанному
методу не превосходит 2 log x.

      Д о к а з а т е л ь с т в о . Для вычисления чисел ряда (2.5) тре-
 буется t умножений, для вычисления y по (2.6) не более, чем t
умножений
              (см. пример 2.1). Из условия t = log x , учитывая, что
  log x ≤ log x, делаем вывод о справедливости доказываемого ут-
верждения.                                                            ⊔
                                                                      ⊓
    З а м е ч а н и е. Как будет показано в дальнейшем, при возведении в
степень по модулю p имеет смысл использовать только показатели x < p .
В этом случае мы можем сказать, что количество операций умножения
при вычислении (2.3) не превосходит 2 log p .
     Важно отметить, что столь же эффективные алгоритмы вычис-
ления обратной функции (2.4) неизвестны. Один из методов вычис-
ления (2.4), называемый «шаг младенца, шаг великана», будет по-
                                                       √
дробно описан в разд. 3.2. Этот метод требует порядка 2 p опера-
ций.
     Покажем, что при больших p функция (2.3) действительно од-
носторонняя, если для вычисления обратной функции используется
метод «шаг младенца, шаг великана». Получаем следующий резуль-
тат (табл. 2.1).


    Т а б л и ц а 2.1. Количество умножений для вычисления
                       прямой и обратной функции
     Количество десятич-     Вычисление (2.3)      Вычисление (2.4)
                                                     √
     ных знаков в записи p   (2 log p умножений)   (2 p умножений)
              12                 2 · 40 = 80            2 · 106
              60                2 · 200 = 400           2 · 1030
              90                2 · 300 = 600           2 · 1045

    Мы видим, что если использовать модули, состоящие из 50–100
десятичных цифр, то «прямая» функция вычисляется быстро, а об-
ратная практически не вычислима. Рассмотрим, например, супер-
компьютер, который умножает два 90-значных числа за 10 −14 сек.
(для современных компьютеров это пока не доступно). Для вычис-
ления (2.3) такому компьютеру потребуется

                Tвыч.пр. = 600 · 10−14 = 6 · 10−12 сек.,
16                   Глава 2. Криптосистемы с открытым ключом

а для вычисления (2.4) —
                Tвыч.обр. = 1045 · 10−14 = 1031 сек.,

т.е. более 10 22 лет. Мы видим, что вычисление обратных функций
практически невозможно при длине чисел порядка 90 десятичных
цифр, и использование параллельных вычислений и компьютерных
сетей существенно не меняет ситуацию. В рассмотренном примере
                                                           √
мы предполагали, что обратная функция вычисляется за 2 p опе-
раций. В настоящее время известны и более «быстрые» методы вы-
числения дискретного логарифма, однако общая картина та же —
количество требуемых в них операций много больше 2 log p . Таким
образом, можно утверждать, что функция (2.3) действительно одно-
сторонняя , но с оговоркой. Никем не доказано, что обратная функ-
ция (2.4) не может быть вычислена столь же быстро, как и «прямая».
      Используем одностороннюю функцию (2.3) для решения всех
трех задач, описанных в начале данного раздела, не забывая, од-
нако, что точно так же может быть использована и любая другая
односторонняя функция.
      Начнем с хранения паролей в памяти компьютера. Решение за-
дачи основано на том, что пароли вообще не хранятся! Точнее, при
регистрации в сети пользователь набирает свое имя и пароль; пусть,
например, его имя — «фрукт», а пароль — «абрикос». Компьютер
рассматривает слово «абрикос» как двоичную запись числа x и вы-
числяет (2.3), где a и p — два несекретные числа, возможно да-
же, всем известные. После этого в памяти компьютера заводится
пара (имя, y ), где y вычислено по (2.3) при x = пароль. При всех
дальнейших входах этого пользователя после ввода пары («фрукт»,
«абрикос»), компьютер вычисляет по (2.3) новое значение yнов с
x =«абрикос» и сравнивает с хранящимся в памяти ранее вычис-
ленным значением y . Если yнов совпадает с хранящимся в памяти
y , соответствующим данному имени, то это законный пользователь.
В противном случае это Ева.
      Ева могла бы попытаться найти x по y . Однако мы видели, что
уже при 90-значных числах для этого потребуется более чем 10 22
лет. Таким образом, представленная система хранения пароля весь-
ма надежна и в настоящее время используется во многих реальных
операционных системах.
      Рассмотрим решение второй задачи (ПВО и самолет). Можно
использовать следующий метод. Каждому «своему» самолету при-
2.1. Предыстория и основные идеи                               17

сваивается секретное имя, известное системе ПВО и летчику, точ-
нее, бортовому компьютеру. Пусть, например, одному из самолетов
присвоено секретное имя СОКОЛ, и этот самолет приближается к
границе 01 февраля 2005 года в 12 час.45 мин. Тогда перед прибли-
жением к границе бортовой компьютер самолета формирует слово
         СОКОЛ     05    02      01     12     45
         (имя      год   месяц   день   часы   минуты).
     Другими словами, компьютер на самолете и станция ПВО при-
бавляют к секретному слову сведения о текущем времени и, рассмат-
ривая полученное слово как число x, вычисляют y = ax mod p , где
a и p не секретны. Затем самолет сообщает число y станции ПВО.
Станция сравнивает вычисленное ею число y с полученным от само-
лета. Если вычисленное и полученное значения совпали, то самолет
признается как «свой».
     Противник не может взломать эту систему. Действительно, с
одной стороны, он не знает секретного слова СОКОЛ и не может
найти его по y , так как вычисление x по y занимает, скажем, 10 22
лет. С другой стороны, он не может просто скопировать y и исполь-
зовать его в качестве ответа в будущем, так как время пересечения
границы никогда не повторяется и последующие значения y будут
отличаться от первоначального.
     Рассмотренный вариант решения «задачи ПВО» требует точ-
ной синхронизации часов в самолете и в локаторе. Эта проблема
достаточно легко решается. Например, служба навигации постоян-
но передает метки времени в открытом виде (время не секретно),
и все самолеты и локаторы используют эти метки для синхрониза-
ции своих часов. Но есть более тонкие проблемы. Метка времени
добавляется в слово x для того, чтобы все вычисляемые значения
y были различны и противник не мог их повторно использовать.
Однако противник может попытаться мгновенно повторить y в пре-
делах текущей минуты. Как предотвратить эту возможность? Это
первый вопрос. Другое затруднение возникает в ситуации, когда са-
молет посылает число y в конце 45-й минуты, а локатор принимает
его в начале 46-й. Мы предоставляем читателю возможность само-
стоятельно предложить вариант решения этих проблем.
     Другой способ решения «задачи ПВО» возможен, если мы будем
использовать дополнительный открытый канал передачи данных от
локатора к самолету. Как и выше, каждый «свой» самолет и локатор
18                    Глава 2. Криптосистемы с открытым ключом

знают секретное слово (типа СОКОЛ), которое не заменяется. Обна-
ружив цель, локатор посылает ей случайно сгенерированное число
a («вызов»). Самолет вычисляет y = ax mod p , где x — секретное
слово («СОКОЛ»), и сообщает число y локатору. Локатор воспро-
изводит те же вычисления и сравнивает вычисленное y и принятое.
В этой схеме не нужно синхронизировать часы, но, как и ранее, про-
тивник не может повторить число y , так как локатор всякий раз по-
сылает разные вызовы ( a). Интересно, что эта задача, по-видимому,
была исторически первой, при решении которой использовались од-
носторонние функции.
    Третья задача решается совершенно аналогично, и оба рассмот-
ренных метода формирования пароля применимы и используются в
реальных сетевых протоколах.


2.2.   Первая система с открытым ключом —
       система Диффи–Хеллмана
Эта криптосистема была открыта в середине 70-х годов американ-
скими учеными Диффи (Whitﬁeld Diﬃe) и Хеллманом (Martin Hell-
man) и привела к настоящей революции в криптографии и ее практи-
ческих применениях. Это первая система, которая позволяла защи-
щать информацию без использования секретных ключей, передавае-
мых по защищенным каналам. Для того чтобы продемонстрировать
одну из схем применения таких систем, рассмотрим сеть связи с N
пользователями, где N — большое число. Пусть мы хотим органи-
зовать секретную связь для каждой пары из них. Если мы будем
использовать обычную систему распределения секретных ключей,
то каждая пара абонентов должна быть снабжена своим секретным
                                                  2
ключом, т.е. всего потребуется CN2
                                   = N (N2−1) ≈ N2 ключей.
    Если абонентов 100, то требуется 5000 ключей, если же абонен-
тов 10 4 , то ключей должно быть 5·107 . Мы видим, что при большом
числе абонентов система снабжения их секретными ключами стано-
вится очень громоздкой и дорогостоящей.
    Диффи и Хеллман решили эту проблему за счет открытого рас-
пространения и вычисления ключей. Перейдем к описанию предло-
женной ими системы.
    Пусть строится система связи для абонентов A, B, C, . . . . У каж-
дого абонента есть своя секретная и открытая информация. Для
2.2. Первая система с открытым ключом                             19

организации этой системы выбирается большое простое число p и
некоторое число g , 1 < g < p − 1, такое, что все числа из множе-
ства {1, 2, · · · , p − 1} могут быть представлены как различные сте-
пени g mod p (известны различные подходы для нахождения таких
чисел g , один из них будет представлен ниже). Числа p и g известны
всем абонентам.
    Абоненты выбирают большие числа XA , XB , XC , которые хра-
нят в секрете (обычно такой выбор рекомендуется проводить случай-
но, используя датчики случайных чисел). Каждый абонент вычис-
ляет соответствующее число Y , которое открыто передается другим
абонентам,                  
                             YA = g XA mod p ,
                               YB = g XB mod p ,                (2.9)
                               YC = g XC mod p .
                            

    В результате получаем следующую таблицу.

      Т а б л и ц а 2.2. Ключи пользователей в системе
                         Диффи–Хеллмана
          Абонент       Секретный ключ         Открытый ключ
             A                 XA                   YA
             B                 XB                   YB
             C                 XC                   YC

    Допустим, абонент A решил организовать сеанс связи с B , при
этом обоим абонентам доступна открытая информация из табл. 2.2.
Абонент A сообщает B по открытому каналу, что он хочет передать
ему сообщение. Затем абонент A вычисляет величину
                                      XA
                         ZAB = (YB )       mod p               (2.10)
(никто другой кроме A этого сделать не может, так как число XA
секретно). В свою очередь, абонент B вычисляет число
                        ZBA = (YA )XB mod p.                   (2.11)
    Утверждение 2.2. ZAB = ZBA .
    Д о к а з а т е л ь с т в о . Действительно,

  ZAB = (YB )XA mod p = (g XB )XA mod p =
                             = g XA XB modp = (YA )XB mod p = ZBA .
20                      Глава 2. Криптосистемы с открытым ключом

(Здесь первое равенство следует из (2.10), второе и четвертое — из
(2.9), последнее — из (2.11).)                                  ⊔
                                                                ⊓
      Отметим главные свойства системы:

     1) абоненты A и B получили одно и то же число Z = ZAB = ZBA ,
        которое не передавалось по открытой линии связи;

     2) Ева не знает секретных чисел XA , XB , . . ., поэтому не может
        вычислить число ZAB (вообще говоря, она могла бы попытать-
        ся найти секретное число XA по YA (см. (2.9)), однако при
        больших p это практически невозможно (требуются миллионы
        лет)).

     Абоненты A и B могут использовать ZAB в качестве секретного
ключа для шифрования и дешифрования данных. Таким же образом
любая пара абонентов может вычислить секретный ключ, известный
только им.
     Остановимся теперь на упомянутой выше задаче выбора числа
g . При произвольно заданном p она может оказаться трудной зада-
чей, связанной с разложением на простые множители числа p − 1.
Дело в том, что для обеспечения высокой стойкости рассмотренной
системы число p−1 должно обязательно содержать большой простой
множитель (в противном случае алгоритм Полига–Хеллмана, опи-
санный, например, в [28], быстро вычисляет дискретный логарифм).
Поэтому часто рекомендуют использовать следующий подход. Про-
стое число p выбирается таким, чтобы выполнялось равенство

                               p = 2q + 1,

где q — также простое число. Тогда в качестве g можно взять любое
число, для которого справедливы неравенства

                    1<g <p−1 и         g q mod p 6= 1.

    П р и м е р 2.2. Пусть p = 23 = 2 · 11 + 1 (q = 11) . Выберем пара-
метр g . Попробуем взять g = 3. Проверим: 311 mod 23 = 1 и значит,
такое g не подходит. Возьмем g = 5. Проверим: 511 mod 23 = 22.
Итак, мы выбрали параметры p = 23, g = 5. Теперь каждый або-
нент выбирает секретное число и вычисляет соответствующее ему
открытое число. Пусть выбраны XA = 7 , XB = 13 . Вычисляем
2.3. Элементы теории чисел                                        21

YA = 57 mod 23 = 17, YB = 513 mod 23 = 21. Пусть A и B реши-
ли сформировать общий секретный ключ. Для этого A вычисляет
ZAB = 217 mod 23 = 10, а B вычисляет ZBA = 1713 mod 23 = 10.
Теперь они имеют общий ключ 10, который не передавался по кана-
лу связи.                                                    ⊔
                                                             ⊓


2.3.   Элементы теории чисел
Многие криптографические алгоритмы базируются на результатах
классической теории чисел. Мы рассмотрим необходимый минимум
из этой теории. Классические теоремы Ферма, Эйлера и ряд других
результатов из теории чисел будут даны без доказательств, которые
могут быть найдены практически в любом учебнике по теории чи-
сел (см., например, [3]). Читатели, знакомые с теорией чисел, могут
непосредственно перейти к разд. 2.4.

    Определение 2.2. Целое положительное число p называется
простым, если оно не делится ни на какое другое число, кроме са-
мого себя и единицы.

    П р и м е р 2.3. Числа 11, 23 — простые; числа 27, 33 — составные
(27 делится на 3 и на 9, 33 делится на 3 и на 11).                  ⊔
                                                                    ⊓

    Теорема 2.3 (основная теорема арифметики). Любое целое
положительное число может быть представлено в виде произве-
дения простых чисел, причем единственным образом.

    П р и м е р 2.4. 27 = 3 · 3 · 3, 33 = 3 · 11.                  ⊔
                                                                   ⊓

    Определение 2.3. Два числа называются взаимно простыми,
если они не имеют ни одного общего делителя кроме единицы.

    П р и м е р 2.5. Числа 27 и 28 взаимно просты (у них нет общих
делителей кроме единицы), числа 27 и 33 — нет (у них есть общий
делитель 3).                                                     ⊔
                                                                 ⊓

    Определение 2.4 (функция Эйлера). Пусть дано целое чис-
ло N ≥ 1. Значение функции Эйлера ϕ (N ) равно количеству чисел
в ряду 1, 2, 3, . . . , N − 1 , взаимно простых с N .
22                               Глава 2. Криптосистемы с открытым ключом

     П р и м е р 2.6.
     ϕ (10) =?                                        ϕ (12) =?
     1, 6 2, 3, 6 4, 6 5, 6 6, 7, 6 8, 9,             1, 6 2, 6 3, 6 4, 5, 6 6, 7, 6 8, 6 9, 6 10, 11
     ϕ (10) = 4                                       ϕ (12) = 4

(здесь зачеркнуты числа, не взаимнопростые с аргументом).                                               ⊔
                                                                                                        ⊓
     Утверждение 2.4. Если p — простое число, то ϕ (p) = p − 1.
    Д о к а з а т е л ь с т в о . В ряду 1, 2, 3, . . . , p−1 все числа взаимно
просты с p , так как p — простое число и по определению не делится
ни на какое другое число.                                                     ⊔
                                                                              ⊓
    Утверждение 2.5. Пусть p и q — два различных простых
числа (p 6= q ). Тогда ϕ (pq) = (p − 1) (q − 1).
   Д о к а з а т е л ь с т в о . В ряду 1, 2, . . . , pq − 1 не взаимнопро-
стыми с pq будут числа

                                    p, 2p, 3p, · · · , (q − 1) p

и
                                    q, 2q, 3q, · · · , (p − 1) q.
Всего таких чисел будет (q − 1) + (p − 1). Следвательно, количество
чисел, взаимнопростых с pq , будет pq − 1 − (p − 1) − (q − 1) = pq −
q − p + 1 = (p − 1) (q − 1).                                       ⊔
                                                                   ⊓
    Теорема 2.6 (Ферма). Пусть p — простое число и 0 < a < p.
Тогда
                      ap−1 mod p = 1.
     П р и м е р 2.7. p = 13, a = 2;
                         2   2 2
       212   mod 13 = 22 · 22        mod 13 = 3 · 9 mod 13 = 1,
                                                      2 2
             1010 mod 11 = 102 ·                102            mod 11 = 1 · 1 = 1.                      ⊔
                                                                                                        ⊓


    Теорема 2.7 (Эйлер). Пусть a и b — взаимно простые чис-
ла. Тогда
                      aϕ(b) mod b = 1.
2.3. Элементы теории чисел                                       23

    Теорема Ферма является частным случаем теоремы Эйлера, ко-
гда b — простое число.
    П р и м е р 2.8.
                             ϕ (12) = 4,
                          2             2
           54 mod 12 = 52 mod 12 = 12 mod 12 = 1.


                           ϕ (21) = 2 · 6 = 12,
                                2
         212   mod 21 = 24 · 24 mod 21 = 16 · 4 mod 21 = 1.       ⊔
                                                                  ⊓


    Нам понадобится еще одна теорема, близкая к теореме Эйлера.

    Теорема 2.8. Если p и q — простые числа, p 6= q и k —
произвольное целое число, то

                        akϕ(pq)+1 mod (pq) = a.               (2.12)

    П р и м е р 2.9. Возьмем p = 5, q = 7. Тогда pq = 35 , а функция
Эйлера — ϕ(35) = 4 · 6 = 24. Рассмотрим случай k = 2 , т.е. будем
возводить числа в степень 2 · 24 + 1 = 49. Получим

                  949 mod 35 = 9,    2349 mod 35 = 23.

Это не удивительно, так как каждое из чисел 9 и 23 взаимно просто
с модулем 35, и по теореме Эйлера 924 mod 35 = 1, 2324 mod 35 = 1.
Однако теорема 2.8 остается верной и для следующих чисел:

                 1049 mod 35 = 10,    2849 mod 35 = 28,

в то время как теорема Эйлера для них не применима (каждое из
чисел 10 и 28 не взаимно просто с модулем 35 и 1024 mod 35 = 15,
2824 mod 35 = 21).                                            ⊔
                                                              ⊓

    Определение 2.5. Пусть a и b — два целых положительных
числа. Наибольший общий делитель чисел a и b есть наибольшее
число c, которое делит и a и b :

                             c = gcd(a, b) .
24                       Глава 2. Криптосистемы с открытым ключом

    (Обозначение gcd для наибольшего общего делителя происходит
от английских слов greatest common divisor и принято в современной
литературе.)

     П р и м е р 2.10.   gcd(10, 15) = 5; gcd(8, 28) = 4.                ⊔
                                                                         ⊓
    Для нахождения наибольшего общего делителя можно исполь-
зовать следующий алгоритм, известный как алгоритм Евклида.


Алгоритм 2.1. Алгоритм Евклида
ВХОД:   Положительные целые числа a,b , a ≥ b .
ВЫХОД: Наибольший общий делитель gcd(a, b).
1.    WHILE b 6= 0 DO
2.       r ← a mod b , a ← b , b ← r .
3.    RETURN a.

   П р и м е р 2.11. Покажем, как с помощью алгоритма Евклида
вычисляется gcd(28, 8):
                              a:   28 8 4
                              b:    8 4 0
                              r:    4 0
Здесь каждый столбец представляет собой очередную итерацию ал-
горитма. Процесс продолжается до тех пор, пока b не станет равным
нулю. Тогда в значении переменной a содержится ответ (4).       ⊔
                                                                ⊓
    Для многих криптографических систем, рассматриваемых в сле-
дующих разделах и главах, актуален так называемый обобщенный
алгоритм Евклида, с которым связана следующая теорема.
    Теорема 2.9. Пусть a и b — два целых положительных чис-
ла. Тогда существуют целые (не обязательно положительные)
числа x и y , такие, что

                           ax + by = gcd(a, b).                     (2.13)

     Обобщенный алгоритм Евклида служит для отыскания gcd(a, b)
и x, y , удовлетворяющих (2.13). Введем три строки U = (u1 , u2 , u3 ),
V = (v1 , v2 , v3 ) и T = (t1 , t2 , t3 ). Тогда алгоритм записывается сле-
дующим образом.
2.3. Элементы теории чисел                                        25

Алгоритм 2.2. Обобщенный алгоритм Евклида
ВХОД:    Положительные целые числа a,b , a ≥ b .
ВЫХОД: gcd(a, b), x, y , удовлетворяющие (2.13).
1.    U ← (a, 1, 0), V ← (b, 0, 1).
2.    WHILE v1 6= 0 DO
3.       q ← u1 div v1 ;
4.       T ← (u1 mod v1 , u2 − qv2 , u3 − qv3 );
5.       U ←V , V ←T.
6.    RETURN U = (gcd(a, b), x, y).

Результат содержится в строке U .
    Операция div в алгоритме — это целочисленное деление
                                   
                         a div b = a/b .
Доказательство корректности алгоритма 2.2 может быть найдено в
[1, 9].
    П р и м е р 2.12. Пусть a=28, b =19. Найдем числа x и y , удо-
влетворяющие (2.13).
                U               28  1   0
                V   U           19  0   1
                T   V   U        9  1 −1 q = 1
                    T   V   U    1 −2   3 q=2
                        T   V    0 19 −28 q = 9
Поясним представленную схему. Вначале в строку U записываются
числа (28,1,0), а в строку V — числа (19,0,1) (это первые две строки
на схеме). Вычисляется строка T (третья строка в схеме). После
этого в качестве строки U берется вторая строка в схеме, а в качестве
V — третья, и опять вычисляется строка T (четвертая строка в
схеме). Этот процесс продолжается до тех пор, пока первый элемент
строки V не станет равным нулю. Тогда предпоследняя строка в
схеме содержит ответ. В нашем случае gcd(28, 19) = 1, x = −2,
y = 3 . Выполним проверку: 28 · (−2) + 19 · 3 = 1 .                ⊔
                                                                   ⊓
   Рассмотрим одно важное применение обобщенного алгоритма
Евклида. Во многих задачах криптографии для заданных чисел c,
m требуется находить такое число d < m, что
                            cd mod m = 1.                      (2.14)
26                   Глава 2. Криптосистемы с открытым ключом

Отметим, что такое d существует тогда и только тогда, когда числа
c и m взаимно простые.

    Определение 2.6. Число d , удовлетворяющее (2.14), называ-
ется инверсией c по модулю m и часто обозначается c−1 mod m.

   Данное обозначение для инверсии довольно естественно, так как
мы можем теперь переписать (2.14) в виде

                         cc−1 mod m = 1.

Умножение на c−1 соответствует делению на c при вычислениях по
модулю m . По аналогии можно ввести произвольные отрицательные
степени при вычислениях по модулю m:

                 c−e = (ce )−1 = (c−1 )e   (mod m).

    П р и м е р 2.13. 3 · 4 mod 11 = 1, поэтому число 4 — это инвер-
сия числа 3 по модулю 11. Можно записать 3−1 mod 11 = 4. Число
5−2 mod 11 может быть найдено двумя способами:

       5−2 mod 11 = (52 mod 11)−1 mod 11 = 3−1 mod 11 = 4,

       5−2 mod 11 = (5−1 mod 11)2 mod 11 = 92 mod 11 = 4.
При вычислениях по второму способу мы использовали равенство
5−1 mod 11 = 9. Действительно, 5 · 9 mod 11 = 45 mod 11 = 1. ⊔
                                                             ⊓
    Покажем, как можно вычислить инверсию с помощью обобщен-
ного алгоритма Евклида. Равенство (2.14) означает, что для некото-
рого целого k
                          cd − km = 1.                       (2.15)
Учитывая, что c и m взаимно просты, перепишем (2.15) в виде

                      m(−k) + cd = gcd(m, c),                 (2.16)

что полностью соответствует (2.13), здесь только по-другому обозна-
чены переменные. Поэтому, чтобы вычислить c−1 mod m, т.е. найти
число d , нужно просто использовать обобщенный алгоритма Евкли-
да для решения уравнения (2.16). Заметим, что значение переменной
k нас не интересует, поэтому можно не вычислять вторые элементы
2.3. Элементы теории чисел                                    27

строк U , V , T . Кроме того, если число d получается отрицатель-
ным, то нужно прибавить к нему m, так как по определению число
a mod m берется из множества {0, 1, . . . , m − 1}.
    П р и м е р 2.14. Вычислим 7−1 mod 11 . Используем такую же
схему записи вычислений, как в примере 2.12 :
                            11  0
                             7  1
                             4 −1 q = 1
                             3  2 q=1
                             1 −3 q = 1
                             0 11 q = 3.
Получаем d = −3 и d mod 11 = 11 − 3 = 8, т.е. 7−1 mod 11 = 8.
Проверим результат: 7 · 8 mod 11 = 56 mod 11 = 1.          ⊔
                                                           ⊓
    Одной из важнейших операций в криптографии с открытыми
ключами является операция возведения в степень по модулю. Идея
построения эффективного алгоритма возведения степень была ранее
проиллюстрирована с помощью (2.5) и (2.6). Рассмотренный алго-
ритм можно реализовать и без хранения в памяти ряда чисел (2.5).
Дадим описание этого алгоритма в форме, пригодной для непосред-
ственной программной реализации. В названии алгоритма отражен
тот факт, что биты показателя степени просматриваются справа-
налево, т.е. от младшего к старшему.


Алгоритм 2.3. Возведение в степень (справа-налево)
ВХОД:    Целые числа a, x = (xt xt−1 . . . x0 )2 , p.
ВЫХОД: Число y = ax mod p .
1.    y ← 1 , s ← a.
2.    FOR i = 0, 1, . . . , t DO
3.       IF xi = 1 THEN y ← y · s mod p ;
4.       s ← s · s mod p .
5.    RETURN y .

    Чтобы показать, что по представленному алгоритму действи-
тельно вычисляется y согласно (2.6), запишем степени переменных
после каждой итерации цикла. Пусть x = 100 = (1100100)2 , как в
примере 2.1, тогда:
28                         Глава 2. Криптосистемы с открытым ключом

              i:      0     1    2    3     4     5     6
              xi :    0     0    1    0     0     1     1
              y:      1     1    a4   a4    a4    a36   a100
              s:      a2    a4   a8   a16   a32   a64   a128

    В некоторых ситуациях более эффективным оказывается следу-
ющий алгоритм, в котором биты показателя степени просмативают-
ся слева-направо, т.е. от старшего к младшему.


Алгоритм 2.4. Возведение в степень (слева-направо)

ВХОД:    Целые числа a, x = (xt xt−1 . . . x0 )2 , p.
ВЫХОД: Число y = ax mod p .
1.    y ← 1.
2.    FOR i = t, t − 1, . . . , 0 DO
3.       y ← y · y mod p ;
4.       IF xi = 1 THEN y ← y · a mod p .
5.    RETURN y .

    Чтобы убедиться в том, что алгоритм 2.4 вычисляет то же самое,
что и алгоритм 2.3, запишем степени переменной y после каждой
итерации цикла для x = 100 :

               i:     6     5    4    3     2     1     0
               xi :   1     1    0    0     1     0     0
               y:     a     a3   a6   a12   a25   a50   a100

    Приведенных в данном разделе сведений из теории чисел будет
достаточно для описания основных криптографических алгоритмов
и методов.


2.4.   Шифр Шамира
Этот шифр, предложенный Шамиром (Adi Shamir), был первым,
позволяющим организовать обмен секретными сообщениями по от-
крытой линии связи для лиц, которые не имеют никаких защищен-
ных каналов и секретных ключей и, возможно, никогда не видели
друг друга. (Напомним, что система Диффи–Хеллмана позволяет
2.4. Шифр Шамира                                                     29

сформировать только секретное слово, а передача сообщения потре-
бует использования некоторого шифра, где это слово будет исполь-
зоваться как ключ.)
    Перейдем к описанию системы. Пусть есть два абонента A и B ,
соединенные линией связи. A хочет передать сообщение m абоненту
B так, чтобы никто не узнал его содержание. A выбирает случай-
ное большое простое число p и открыто передает его B . Затем A
выбирает два числа cA и dA , такие, что

                        cA dA mod (p − 1) = 1.                    (2.17)

Эти числа A держит в секрете и передавать не будет. B тоже вы-
бирает два числа cB и dB , такие, что

                        cB dB mod (p − 1) = 1,                    (2.18)

и держит их в секрете.
     После этого A передает свое сообщение m, используя трехсту-
пенчатый протокол. Если m < p (m рассматривается как число),
то сообщение m передается сразу , если же m ≥ p , то сообще-
ние предствляется в виде m1 , m2 , . . . , mt , где все mi < p , и затем
передаются последовательно m1 , m2 , . . . , mt . При этом для кодиро-
вания каждого mi лучше выбирать случайно новые пары (cA , dA )
и (cB , dB ) — в противном случае надежность системы понижается.
В настоящее время такой шифр, как правило, используется для пере-
дачи чисел, например, секретных ключей, значения которых меньше
p . Таким образом, мы будем рассматривать только случай m < p .
Дадим описание протокола.

Шаг 1. A вычисляет число

                              x1 = mcA mod p,                     (2.19)

     где m — исходное сообщение, и пересылает x1 к B .

Шаг 2. B , получив x1 , вычисляет число

                              x2 = xc1B mod p                     (2.20)

     и передает x2 к A.
30                      Глава 2. Криптосистемы с открытым ключом

Шаг 3. A вычисляет число

                                x3 = xd2A mod p                    (2.21)

       и передает его B .
Шаг 4. B , получив x3 , вычисляет число

                                x4 = xd3B mod p.                   (2.22)

      Утверждение 2.10 (свойства протокола Шамира).
     1) x4 = m , т.е. в результате реализации протокола от A к B
        действительно передается исходное сообщение;
     2) злоумышленник не может узнать, какое сообщение было пе-
        редано.
    Д о к а з а т е л ь с т в о . Вначале заметим, что любое целое число
e ≥ 0 может быть представлено в виде e = k(p − 1) + r , где r =
e mod (p − 1). Поэтому на основании теоремы Ферма

  xe mod p = xk(p−1)+r mod p =
                          = (1k · xr ) mod p = xe mod (p−1) mod p. (2.23)

Справедливость первого пункта утверждения вытекает из следую-
щей цепочки равенств:

      x4   = xd3B mod p = (xd2A )dB mod p =
           = (xc1B )dA dB mod p = (mcA )cB dA dB mod p =
           = mcA dA cB dB mod p = m(cA dA cB dB ) mod (p−1) mod p = m

(предпоследнее равенство следует из (2.23), а последнее выполняется
в силу (2.17) и (2.18)).
    Доказательство второго пункта утверждения основано на пред-
положении, что для злоумышленника, пытающегося определить m,
не существует стратегии более эффективной, чем следующая. Вна-
чале он вычисляет cB из (2.20), затем находит dB и, наконец, вы-
числяет x4 = m по (2.22). Но для осуществления этой стратегии
злоумышленник должен решить задачу дискретного логарифмиро-
вания (2.20), что практически невозможно при больших p .         ⊔
                                                                 ⊓
2.5. Шифр Эль-Гамаля                                            31

    Опишем метод нахождения пар cA , dA и cB , dB , удовлетворя-
ющих (2.17) и (2.18). Достаточно описать только действия для або-
нента A, так как действия для B совершенно аналогичны. Число cA
выбираем случайно так, чтобы оно было взаимно простым с p−1 (по-
иск целесообразно вести среди нечетных чисел, так как p − 1 четно).
Затем вычисляем dA с помощью обобщенного алгоритма Евклида,
как это было объяснено в разд. 2.3.
    П р и м е р 2.15. Пусть A хочет передать B сообщение m = 10 .
A выбирает p = 23, cA = 7 (gcd(7, 22) = 1) и вычисляет dA = 19.
Аналогично, B выбирает параметры cB = 5 (взаимно простое с 22)
и dB = 9. Переходим к протоколу Шамира.

Шаг 1. x1 = 107 mod 23 = 14.

Шаг 2. x2 = 145 mod 23 = 15.

Шаг 3. x3 = 1519 mod 23 = 19.

Шаг 4. x4 = 199 mod 23 = 10.

Таким образом, B получил передаваемое сообщение m = 10.          ⊔
                                                                 ⊓

2.5.   Шифр Эль-Гамаля
Пусть имеются абоненты A , B , C , . . . , которые хотят передавать
друг другу зашифрованные сообщения, не имея никаких защищен-
ных каналов связи. В этом разделе мы рассмотрим шифр, предло-
женный Эль-Гамалем (Taher ElGamal), который решает эту задачу,
используя, в отличие от шифра Шамира, только одну пересылку со-
общения. Фактически здесь используется схема Диффи–Хеллмана,
чтобы сформировать общий секретный ключ для двух абонентов,
передающих друг другу сообщение, и затем сообщение шифруется
путем умножения его на этот ключ. Для каждого следующего со-
общения секретный ключ вычисляется заново. Перейдем к точному
описанию метода.
    Для всей группы абонентов выбираются некоторое большое про-
стое число p и число g , такие, что различные степени g суть раз-
личные числа по модулю p (см. разд. 2.2). Числа p и g передаются
абонентам в открытом виде (они могут использоваться всеми або-
нентами сети).
32                       Глава 2. Криптосистемы с открытым ключом

      Затем каждый абонент группы выбирает свое секретное число
ci , 1 < ci < p − 1 , и вычисляет соответствующее ему открытое число
di ,
                              di = g ci mod p.                 (2.24)
      В результате получаем таблицу 2.3.

         Т а б л и ц а 2.3. Ключи пользователей в системе
                            Эль-Гамаля
            Абонент        Секретный ключ        Открытый ключ
               A                 cA                     dA
               B                 cB                     dB
               C                 cC                     dC

    Покажем теперь, как A передает сообщение m абоненту B . Бу-
дем предполагать, как и при описании шифра Шамира, что сообще-
ние представлено в виде числа m < p .
Шаг 1. A формирует случайное число k , 1 ≤ k ≤ p − 2, вычисляет
   числа
                         r = g k mod p,                   (2.25)
                                e = m · dB k mod p                   (2.26)
       и передает пару чисел ( r ,e) абоненту B .
Шаг 2. B , получив ( r ,e), вычисляет
                             m′ = e · rp−1−cB mod p.                 (2.27)

      Утверждение 2.11 (свойства шифра Эль-Гамаля).
     1) Абонент B получил сообщение, т.е. m′ = m ;
     2) противник, зная p , g , dB , r и e, не может вычислить m .
      Д о к а з а т е л ь с т в о . Подставим в (2.27) значение e из (2.26):
                       m′ = m · dB k · rp−1−cB mod p.
Теперь вместо r подставим (2.25), а вместо dB — (2.24):

  m′ = m · (g cB )k · (g k )p−1−cB mod p =
                      = m · g cB k+k(p−1)−kcB mod p = m · g k(p−1) mod p.
2.5. Шифр Эль-Гамаля                                                  33

По теореме Ферма

                   g k(p−1) mod p = 1k mod p = 1,

и, таким образом, мы получаем первую часть утверждения.
     Для доказательства второй части заметим, что противник не
может вычислить k в равенстве (2.25), так как это задача дискрет-
ного логарифмирования. Следовательно, он не может вычислить m
в равенстве (2.26), так как m было умножено на неизвестное ему
число. Противник также не может воспроизвести действия закон-
ного получателя сообщения (абонента B ), так как ему не известно
секретное число cB (вычисление cB на основании (2.24) — также
задача дискретного логарифмирования).                          ⊔
                                                               ⊓
     П р и м е р 2.16. Передадим сообщение m = 15 от A к B . Вы-
берем параметры аналогично тому, как это было сделано в примере
2.2 cтр. 20. Возьмем p = 23, g = 5. Пусть абонент B выбрал для
себя секретное число cB = 13 и вычислил по (2.24)

                        dB = 513 mod 23 = 21.

    Абонент A выбирает случайно число k , например k = 7 , и вы-
числяет по (2.25), (2.26):

  r = 57 mod 23 = 17,    e = 15 · 217 mod 23 = 15 · 10 mod 23 = 12.

Теперь A посылает к B зашифрованное сообщение в виде пары чи-
сел (17, 12). B вычисляет по (2.27)

 m′ = 12 · 1723−1−13 mod 23 = 12 · 179 mod 23 = 12 · 7 mod 23 = 15.

Мы видим, что B смог расшифровать переданное сообщение.               ⊔
                                                                      ⊓
    Ясно, что по аналогичной схеме могут передавать сообщения все
абоненты в сети. Заметим, что любой абонент, знающий открытый
ключ абонента B , может посылать ему сообщения, зашифрованные
с помощью открытого ключа dB . Но только абонент B , и никто
другой, может расшифровать эти сообщения, используя известный
только ему секретный ключ cB . Отметим также, что объем шифра
в два раза превышает объем сообщения, но требуется только одна
передача данных (при условии, что таблица с открытыми ключами
заранее известна всем абонентам).
34                     Глава 2. Криптосистемы с открытым ключом

2.6.     Одностороння функция с «лазейкой» и
         шифр RSA
Названный в честь его разработчиков Ривеста (Ron Rivest), Шамира
(Adi Shamir) и Адлемана (Leonard Adleman), этот шифр до сих пор
является одним из самых широко используемых.
     Мы видели, что шифр Шамира полностью решает задачу об-
мена сообщениями, закрытыми для прочтения, в случае, когда або-
ненты могут пользоваться только открытыми линиями связи. Одна-
ко при этом сообщение пересылается три раза от одного абонента
к другому, что является недостатком. Шифр Эль-Гамаля позволяет
решить ту же задачу за одну пересылку данных, но объем передавае-
мого шифротекста в два раза превышает объем сообщения. Система
RSA лишена подобных недостатков. Интересно то, что она базирует-
ся на другой односторонней функции, отличной от дискретного лога-
рифма. Кроме того, здесь мы встретимся с еще одним изобретением
современной криптографии – односторонней функцией с «лазейкой»
(trapdoor function).
     Эта система базируется на следующих двух фактах из теории
чисел:

     1) задача проверки числа на простоту является сравнительно лег-
        кой;

     2) задача разложения чисел вида n = pq (p и q — простые числа)
        на множители является очень трудной, если мы знаем только
        n , а p и q — большие числа (это так называемая задача фак-
        торизации).

    Пусть в нашей системе есть абоненты A, B , C , . . . . Каждый
абонент выбирает случайно два больших простых числа P и Q. За-
тем он вычисляет число
                           N = P Q.                          (2.28)
(Число N является открытой информацией, доступной другим або-
нентам.) После этого абонент вычисляет число φ = (P − 1)(Q − 1)
и выбирает некоторое число d < φ , взаимно простое с φ, и по обоб-
щенному алгоритму Евклида находит число c, такое, что

                            cd mod φ = 1.                     (2.29)
2.6. Одностороння функция с «лазейкой» и шифр RSA                35


      Т а б л и ц а 2.4. Ключи пользователей в системе RSA
          Абонент        Секретный ключ       Открытый ключ
            A                 cA                  dA , NA
            B                 cB                  dB , NB
            C                 cC                  dC , NC


Вся информация, связанная с абонентами и являющаяся их откры-
тыми и секретными ключами, представлена в табл. 2.4.
    Опишем протокол RSA. Пусть Алиса хочет передать сообщение
m Бобу, причем сообщение m рассматривается как число, удовле-
творяющее неравенству m < NB (далее индекс B указывает на то,
что соответствующие параметры принадлежат Бобу).
Шаг 1. Алиса шифрует сообщение по формуле
                             e = mdB mod NB ,                 (2.30)
     используя открытые параметры Боба, и пересылает e по от-
     крытой линии.
Шаг 2. Боб, получивший зашифрованное сообщение, вычисляет
                             m′ = ecB mod NB .                (2.31)

    Утверждение 2.12. Для описанного протокола m′ = m, т.е.
абонент B получает исходящее от A сообщение.
    Д о к а з а т е л ь с т в о . По построению протокола
                m′ = ecB mod NB = mdB cB mod NB .
Равенство (2.29) означает, что для некоторого k
                           cB dB = kφB + 1.
Согласно утверждению 2.5
                    φB = (PB − 1)(QB − 1) = ϕ(NB ),
где ϕ(·) — функция Эйлера. Отсюда и из теоремы 2.8 следует
                     m′ = mkϕ(NB )+1 mod NB = m.
                                                                  ⊔
                                                                  ⊓
36                    Глава 2. Криптосистемы с открытым ключом

      Утверждение 2.13 (свойства протокола RSA).

     1) Протокол шифрует и дешифрует информацию корректно;

     2) злоумышленник, перехватывающий все сообщения и знаю-
        щий всю открытую информацию, не сможет найти исходное
        сообщение при больших P и Q.

    Д о к а з а т е л ь с т в о . Первое свойство протокола следует из
утверждения 2.12. Для доказательства второго свойства заметим,
что злоумышленник знает только открытые параметры N и d . Для
того чтобы найти c, он должен знать значение φ = (P − 1)(Q − 1),
а для этого, в свою очередь, ему требуется знать P и Q. Вообще
говоря, он может найти P и Q, разложив N на множители, однако
это трудная задача (см. пункт 2 в начале раздела). Отметим, что
выбор больших случайных P и Q возможен за приемлемое время,
так как справедлив пункт 1.                                         ⊔
                                                                    ⊓
    Односторонняя функция y = xd mod N , применяемая в систе-
ме RSA, обладает так называемой «лазейкой», позволяющей легко
                                   √
вычислить обратную функцию x = d y mod N , если известно разло-
жение N на простые множители. (Действительно, легко вычислить
φ = (P − 1)(Q − 1), а затем c = d−1 mod φ.) Если P и Q неизвест-
ны, то вычисление значения обратной функции практически невоз-
можно, а найти P и Q по N очень трудно, т.е. знание P и Q —
это «лазейка» или «потайной ход»). Такие односторонние функции
с лазейкой находят применение и в других разделах криптографии.
    Отметим, что для схемы RSA важно, чтобы каждый абонент
выбирал собственную пару простых чисел P и Q, т.е. все моду-
ли NA , NB , NC , . . . должны быть различны (в противном случае
один абонент мог бы читать зашифрованные сообщения, предназна-
ченные для другого абонента). Однако этого не требуется от второ-
го открытого параметра d . Параметр d может быть одинаковым у
всех абонентов. Часто рекомендуется выбирать d = 3 (при соответ-
ствующем выборе P и Q, см. [28]). Тогда шифрование выполняется
максимально быстро, всего за два умножения.
    П р и м е р 2.17. Допустим, Алиса хочет передать Бобу сообще-
ние m = 15 . Пусть Боб выбрал следующие параметры:

                PB = 3, QB = 11, NB = 33, dB = 3
2.6. Одностороння функция с «лазейкой» и шифр RSA                          37

(3 взаимно просто с ϕ(33) = 20). Найдем cB с помощью обобщенного
алгоритма Евклида:
                                  cB = 7

(проверим: 3 · 7 mod 20 = 1). Кодируем m по формуле (2.30):

       e = 153 mod 33 = 152 · 15 mod 33 = 27 · 15 mod 33 = 9.

Число 9 Алиса передает Бобу по открытому каналу связи. Только
Боб знает cB = 7, поэтому он декодирует принятое сообщение, ис-
пользуя (2.31):

                        2
  m′ = 97 mod 33 = 92        · 92 · 9 mod 33 = 152 · 15 · 9 mod 33 = 15.

Таким образом, Боб расшифровал сообщение Алисы.                            ⊔
                                                                           ⊓

     Рассмотренная система невскрываема при больших P и Q, но
обладает следующим недостатком: A передает сообщение B , исполь-
зуя открытую информацию абонента B (числа NB и dB ). Злоумыш-
ленник не может читать сообщения, предназначенные для B , однако
он может передать сообщение к B от имени A . Избежать этого мож-
но, используя более сложные протоколы, например, следующий.
     A хочет передать B сообщение m. Сначала A вычисляет чис-
ло e = mcA mod NA . Злоумышленник не может этого сделать, так
как cA секретно. Затем A вычисляет число f = edB mod NB и пе-
редает f к B . B получает f и вычисляет последовательно числа
u = f cB mod NB и w = udA mod NA .
     В результате абонент B получает сообщение w = m . Как и в ис-
ходной схеме RSA, злоумышленник не может прочитать переданное
сообщение, но здесь, в отличие от RSA, он не может также послать
сообщение от имени A (поскольку не знает секретного cA ).
     Здесь мы встречаемся с новой ситуацией. B знает, что сооб-
щение пришло от A , т.е. A как бы «подписал» его, зашифровав
своим секретным cA . Это пример так называемой электронной или
цифровой подписи. Она — одно из широко используемых на практи-
ке изобретений современной криптографии и будет систематически
изучаться в главе 4.
38                   Глава 2. Криптосистемы с открытым ключом

Задачи и упражнения
 2.1. Привести результат выражений 5, 16, 27, -4, -13, 3 + 8, 3 − 8,
      3 · 8 , 3 · 8 · 5:

        а. по модулю 10,
        б. по модулю 11.

 2.2. Вычислить, используя быстрые алгоритмы возведения в сте-
      пень, 28 mod 10 , 37 mod 10 , 719 mod 100 , 757 mod 100 .

 2.3. Разложить на простые множители числа 108, 77, 65, 30, 159.

 2.4. Определить, какие из пар чисел (25, 12), (25, 15), (13, 39),
      (40, 27) взаимно просты.

 2.5. Найти значения функции Эйлера ϕ(14), ϕ(20).

 2.6. Используя свойства функции Эйлера, вычислить ϕ(53), ϕ(21),
      ϕ(159).

 2.7. Используя теорему Ферма, вычислить 313 mod 13 , 522 mod 11 ,
      317 mod 5 .

 2.8. Используя теорему Эйлера, вычислить 39 mod 20 , 214 mod 21 ,
      2107 mod 159 .

 2.9. С помощью алгоритма Евклида найти gcd(21, 12), gcd(30, 12),
      gcd(24, 40), gcd(33, 16).

2.10. С помощью обобщенного алгоритма Евклида найти значения
      x и y в уравнениях

        а. 21x + 12y = gcd(21, 12),
        б. 30x + 12y = gcd(30, 12),
        в. 24x + 40y = gcd(24, 40),
        г. 33x + 16y = gcd(33, 16).

2.11. Вычислить 3−1 mod 7 , 5−1 mod 8 , 3−1 mod 53 , 10−1 mod 53 .

2.12. Выписать все простые числа, меньшие 100. Какие из них со-
      ответствуют виду p = 2q + 1, где q также простое?
Задачи и упражнения                                         39

2.13. Найти все допустимые варианты выбора параметра g в систе-
      ме Диффи–Хеллмана при p = 11 .
2.14. Вычислить секретные ключи YA , YB и общий ключ ZAB для
      системы Диффи–Хеллмана с параметрами:
       а. p = 23 , g = 5 , XA = 5, XB = 7,
       б. p = 19 , g = 2 , XA = 5, XB = 7,
       в. p = 23 , g = 7 , XA = 3, XB = 4,
       г. p = 17 , g = 3 , XA = 10, XB = 5 ,
       д. p = 19 , g = 10 , XA = 4, XB = 8 .
2.15. Для шифра Шамира с заданными параметрами p , cA , cB най-
      ти недостающие параметры и описать процесс передачи сооб-
      щения m от A к B :
       а. p = 19 , cA = 5, cB = 7, m = 4,
       б. p = 23 , cA = 15, cB = 7, m = 6 ,
       в. p = 19 , cA = 11, cB = 5, m = 10 ,
       г. p = 23 , cA = 9, cB = 3, m = 17,
       д. p = 17 , cA = 3, cB = 13 , m = 9 .
2.16. Для шифра Эль-Гамаля с заданными параметрами p , g , cB ,
      k найти недостающие параметры и описать процесс передачи
      сообщения m пользователю B :
       а. p = 19 , g = 2 , cB = 5, k = 7 , m = 5,
       б. p = 23 , g = 5 , cB = 8, k = 10 , m = 10,
       в. p = 19 , g = 2 , cB = 11, k = 4, m = 10,
       г. p = 23 , g = 7 , cB = 3, k = 15 , m = 5,
       д. p = 17 , g = 3 , cB = 10, k = 5, m = 10.
2.17. В системе RSA с заданными параметрами PA , QA , dA найти
      недостающие параметры и описать процесс передачи сообще-
      ния m пользователю A:
       а. PA = 5, QA = 11 , dA = 3, m = 12 ,
       б. PA = 5, QA = 13 , dA = 5, m = 20 ,
40                  Глава 2. Криптосистемы с открытым ключом

        в. PA = 7 , QA = 11, dA = 7 , m = 17,
        г. PA = 7 , QA = 13, dA = 5 , m = 30,
        д. PA = 3 , QA = 11, dA = 3 , m = 15.

2.18. Пользователю системы RSA с параметрами N = 187, d = 3
      передано зашифрованное сообщение e = 100. Расшифровать
      это сообщение, взломав систему RSA пользователя.

Темы лабораторных работ
2.19. Написать и отладить набор подпрограмм, реализующих базо-
      вые алгоритмы, используемые в изученных криптосистемах:
      возведение в степень по модулю ( ax mod m), вычисление наи-
      большего общего делителя ( gcd(a, b)), вычисление инверсии
      (x−1 mod m).
2.20. Написать программу, реализующую систему Диффи–Хелл-
      мана. Рекомендуемые значения параметров p = 30803 , g = 2.
      Секретные ключи генерировать случайным образом.
2.21. Написать программу, реализующую шифр Шамира. В каче-
      стве простого модуля можно взять число p = 30803. Осталь-
      ные параметры генерировать случайным образом.
2.22. Написать программу, реализующую шифр Эль-Гамаля. Реко-
      мендуемые значения параметров p = 30803 , g = 2. Секретные
      ключи и другие параметры генерировать случайным образом.

2.23. Написать программу, реализующую шифр RSA для передачи
      секретных сообщений в адрес абонентов A или B . Рекомен-
      дуемые значения параметров PA = 131 , QA = 227, PB = 113 ,
      QB = 281 , dA = dB = 3.
Глава 3.    МЕТОДЫ ВЗЛОМА ШИФРОВ,
            ОСНОВАННЫХ НА ДИСКРЕТНОМ
            ЛОГАРИФМИРОВАНИИ




3.1.   Постановка задачи
Для построения надежной криптосистемы необходимо принимать во
внимание те методы взлома, которые может применить злоумыш-
ленник, и выбирать параметры криптосистемы (в частности, длины
чисел) так, чтобы сделать эти методы практически нереализуемыми.
В данном параграфе мы рассмотрим два таких метода, для того что-
бы дать читателю некоторое представление об этой «таинственной»
области.
    Мы видели, что многие рассматриваемые шифры основываются
на односторонней функции

                          y = ax mod p                      (3.1)

и знаем, что можно вычислить y , если даны a и x, затратив не
более, чем 2 log x операций (утверждение 2.1). Однако отыскание
x по известным a и y , т.е. вычисление дискретного логарифма, —
задача намного более трудная.
     Как уже было показано при рассмотрении шифра Шамира (см.
(2.23)), на основании теоремы Ферма при возведении в степень по
простому модулю p показатели степени приводятся по модулю p−1.
Поэтому нам достаточно рассматривать только показатели x, удо-
влетворяющие неравенству 0 ≤ x ≤ p − 1 .
     Обозначим через ty число операций умножения, необходимых
для вычисления y в (3.1) по a и x, и будем для краткости называть
ty временем вычисления. Время возведения в степень по алгоритмам
из разд. 2.1 не больше 2 log x, причем x < p. Отсюда

                           ty ≤ 2 log p                     (3.2)

при любом показателе степени x.
42                                   Глава 3. Методы взлома шифров

     Теперь перейдем к задаче отыскания x в (3.1) по данным a и
y . Сначала оценим сложность прямого перебора. Для этого можно
было бы сначала вычислить a1 и проверить, верно ли равенство
a1 = y . Если нет, то проверяем a2 = y , если нет, то a3 = y и т.д. до
ap−1 . В среднем потребуется (p−1)/2 раз умножать на a и проверять
равенство. Таким образом, время прямого перебора

                              tп.п. ≈ p/2.

    В описываемом ниже методе «шаг младенца, шаг великана» вре-
мя отыскания x существенно меньше:
                                                 √
                          tш.м.ш.в. ≈ 2 ·            p,

а в методе исчисления порядка это время еще меньше:
                                         √
                      tи.п. ≈ c1 · 2c2       log p log log p
                                                               ,

где c1 , c2 — некоторые положительные константы.
    Чтобы сделать сравнение более наглядным, выразим время вы-
числения через длину числа p в (3.1). Обозначим эту длину в битах
через n . При вычислениях по модулю p имеем n ≈ log p . Поэтому
порядок трудоемкости (в смысле количества операций) упомянутых
алгоритмов будет следующий:

                              ty   ≈ n,
                          tп.п.    ≈ 2n−1 ,
                      tш.м.ш.в.    ≈ 2n/2 ,
                                                 √
                           tи.п.   ≈ 2c2             n log n
                                                               ,

где ≈ означает «пропорционально».
    Мы видим, что количество операций при возведении в степень
растет линейно с ростом длины числа n , а время решения обратной
задачи различными методами растет экспоненциально либо субэкс-
поненциально (для метода исчисления порядка). Вопрос о существо-
вании более быстрых алгоритмов для вычисления дискретных лога-
рифмов, как и для решения других обратных задач, возникающих в
криптоанализе, остается открытым.
3.2. Метод «шаг младенца, шаг великана»                              43

3.2.    Метод «шаг младенца, шаг великана»
В открытой литературе этот метод был впервые описан Шенксом
(Daniel Shanks); ссылки на него известны с 1973 года. Это был один
из первых методов, который показал, что задача вычисления дис-
кретного логарифма может быть решена значительно быстрее, чем
методом перебора. Перейдем к описанию этого метода отыскания x
в (3.1).

Шаг 1. Сначала берем два целых числа m и k , такие, что

                                       mk > p.                     (3.3)

Шаг 2. Вычислим два ряда чисел

                  y,    ay,   a2 y,    ...,   am−1 y   (mod p);    (3.4)

                       am ,   a2m ,    ...,   akm   (mod p)        (3.5)
       (все вычисления проводятся по модулю p ).

Шаг 3. Найдем такие i и j , для которых выполняется равенство

                                      aim = aj y.                  (3.6)

    Утверждение 3.1. Число

                                x = im − j                         (3.7)

является решением уравнения (3.1). Кроме того, целые числа i, j ,
удовлетворяющие (3.6), существуют.

    Д о к а з а т е л ь с т в о . Справедливость (3.7) следует из приво-
димой ниже символической цепочки равенств, где все вычисления
даны по модулю p , а деление соответствует умножению на обрат-
ный элемент:
                                aim   aim y   aim y
                ax = aim−j =        =       =       = y.
                                 aj    aj y   aim

Докажем теперь, что числа i и j , удовлетворяющие (3.6), существу-
ют. Для этого сведем все числа вида (3.7) в таблицу 3.1.
44                                          Глава 3. Методы взлома шифров


         Т а б л и ц а 3.1. Распределение чисел вида im − j
         i↓        j→     0         1             2    ...           m−1
         1               m     m−1          m−2        ...                1
         2              2m    2m − 1       2m − 2      ...            m+1
         ...            ...      ...          ...      ...              ...
         k              km    km − 1       km − 2      ...     (k − 1)m + 1


    Мы видим, что в таблице содержатся все числа от 1 до km.
Значит, из (3.3) следует, что в таблице содержатся все числа от 1
до p . Таким образом, любой показатель степени x < p будет содер-
жаться в таблице, т.е. число x, удовлетворяющее (3.1), может быть
представлено в виде (3.7) и всегда найдется в таблице, поэтому урав-
нение (3.6) всегда имеет решение.                                 ⊔
                                                                  ⊓
    П р и м е р 3.1. Найдем решение уравнения 2x mod 23 = 9, ис-
пользуя метод «шаг младенца, шаг великана».
    Выберем m, k . Пусть m = 6 , k = 4 . Мы видим, что (3.3) вы-
полняется. Вычислим числа (3.4), (3.5):
                          (3.4) :       9, 18, 13, 3, 6, 12;
                          (3.5) :       18.
Дальнейшие вычисления не проводим, так как уже нашлись одина-
ковые числа в (3.4) и (3.5) при i = 1, j = 1. По (3.7) получаем
                               x = 1 · 6 − 1 = 5.
               5
Проверим: 2 mod 23 = 9. Действительно, x = 5 есть решение.                    ⊔
                                                                              ⊓
    Объясним происхождение названия рассмотренного метода. Мы
знаем, что в криптографии p — большое простое число, значит m и
k тоже большие. В ряду (3.4) степень увеличивается на 1 (шаг мла-
денца), а в ряду (3.5) степень увеличивается на m (шаг великана).
    Оценим сложность этого метода.
    Утверждение 3.2. Время вычислений по данному методу при
больших p удовлетворяет неравенству
                                    √
                 tш.м.ш.в. ≤ const · p log2 p.         (3.8)
(Здесь речь идет о полном времени вычислений, а не о числе умно-
жений).
3.3. Алгоритм исчисления порядка                                        45

    Д о к а з а т е л ь с т в о . Мы можем взять
                                      √ 
                             k=m=       p + 1,                        (3.9)

так что, очевидно, (3.3) выполняется. Тогда в (3.4) и (3.5) потребует-
              √
ся не более 2 p операций умножения. Мы знаем, что для «обычных»
(«школьных») методов умножения и деления время вычисления ре-
зультата для двух r -значных чисел пропорционально r2 . У нас все
числа берутся из множества {1, . . . , p} , значит, r ≤ log p , и время вы-
числения пропорционально log2 p . Отсюда мы сразу получаем вре-
мя, затраченное на вычисление рядов (3.4) и (3.5). Однако мы не
учли все этапы алгоритма. Мы не учли время, требуемое для нахож-
дения равных чисел в этих рядах. При больших k и m это далеко не
простая задача. Она может быть решена следующим образом: сна-
чала каждому числу припишем его номер в ряду и еще один бит, в
котором указана принадлежность к ряду (3.4) или (3.5), затем преоб-
разуем обе последовательности в список и отсортируем (упорядочим
                                                            √
по величине). Длина общего ряда равна k + m ≈ 2 p . Для луч-
ших методов сортировки требуется S log S операций сравнения, где
S — число элементов в списке (см., например, [1]). В нашем случае
       √                                     √        √       √
S = 2 p и, следовательно, требуется 2 p log 2 p ≈ p log p опе-
раций сравнения над словами длины log p бит, т.е. всего требуется
           √
порядка p log2 p операций. После сортировки объединенного ряда
его надо просмотреть и найти два равных числа из разных рядов
(3.4), (3.5), используя битовый признак. Таким образом, суммируя
время вычисления на всех этапах, получаем (3.8).                         ⊔
                                                                         ⊓

3.3.    Алгоритм исчисления порядка
Основные идеи алгоритма исчисления порядка (index-calculus algo-
rithm) были известны в теории чисел еще с 20-х годов XX века. Од-
нако только в 1979 году Адлеман, один из создателей RSA, указал
на этот алгоритм как на средство решения уравнения (3.1) и иссле-
довал его трудоемкость. В настоящее время алгоритм исчисления
порядка и его улучшенные варианты дают наиболее быстрый способ
вычисления дискретных логарифмов в уравнениях типа (3.1).
    Для удобства описания алгоритма введем следующее понятие.
    Определение 3.1. Число n называется p -гладким, если оно
разлагается только на простые множители, меньшие либо равные p .
46                                   Глава 3. Методы взлома шифров

    П р и м е р 3.2. Числа 15, 36, 45, 270, 2025 являются 5-гладкими
(в их разложении участвуют только множители 2, 3, и 5).            ⊔
                                                                   ⊓
     Перейдем непосредственно к описанию алгоритма.

Шаг 1. Формируем множество базовых множителей

                           S = {p1 , p2 , . . . , pt },

      состоящее из первых t простых чисел (замечание о выборе зна-
      чения t будет дано ниже).

Шаг 2. Задавая последовательно значения k = 1, 2, 3 . . . , находим
   t + ǫ (ǫ — небольшое целое число, см. ниже) pt -гладких чисел
   вида ak mod p , проверяя гладкость путем деления на элементы
   множества S . Каждое из найденных pt -гладких чисел записы-
   вается через произведение базовых множителей:
                                      t
                                      Y
                       ak mod p =           pci i ,   ci ≥ 0,   (3.10)
                                      i=1


      (для каждого значения k получаем свой набор чисел ci ).

Шаг 3. Переходим к логарифмам в (3.10):

                                   t
                                   X
                             k=          ci loga pi             (3.11)
                                   i=1

      для каждого pt -гладкого числа, найденного на шаге 2. Мы по-
      лучили систему из t + ǫ уравнений вида (3.11) с t неизвестны-
      ми. В качестве неизвестных здесь выступают величины loga pi ,
      при этом число уравнений на ǫ больше числа неизвестных, что
      повышает вероятность получения решения системы в случае,
      если некоторые из уравнений окажутся линейно зависимыми.
      Решаем систему методами линейной алгебры, проводя все вы-
      числения по модулю p − 1 (напомним, что показатели степени,
      а следовательно и логарифмы, приводятся по модулю p − 1).
      В результате получаем значения логарифмов чисел из множе-
      ства S : loga p1 , loga p2 , . . . , loga pt .
3.3. Алгоритм исчисления порядка                                  47

Шаг 4. Случайным образом выбирая r , находим pt -гладкое число
   вида (y · ar ):
                                     t
                                     Y
                    y · ar mod p =         pei i ,   ei ≥ 0.   (3.12)
                                     i=1


Шаг 5. Логарифмируя (3.12), получаем конечный результат
                       t
                                       !
                      X
         x = loga y =    ei loga pi − r mod (p − 1)     (3.13)
                         i=1

     (величина r вычитается из всей суммы, а не из каждого сла-
     гаемого).

     Справедливость описанного метода довольно очевидна из по-
строения алгоритма, а его эффективность связана со следующим
наблюдением. Если мы выбираем случайно наугад число из беско-
нечного множества целых чисел, то с вероятностью 1/2 оно делит-
ся на 2, с вероятностью 1/3 — на 3, с вероятностью 1/5 — на 5 и
т.д. Поэтому мы можем ожидать, что в промежутке от 1 до p − 1
существует достаточно много чисел, в разложении которых участву-
ют только маленькие простые множители из множества S . Именно
такие числа отыскиваются на шагах 2 и 4 алгоритма. Чем боль-
ше t , т.е. количество простых множителей в S , тем меньше неудач
при поиске гладких чисел происходит на шагах 2 и 4, т.е. эти шаги
выполняются быстрее. Однако при больших t резко увеличивает-
ся трудоемкость шага 3, когда приходится решать систему из t + ǫ
уравнений. Нахождение значения t , дающего минимальное общее
время вычислений, обычно может быть выполнено с использованием
численных методов. Аналитические выражения получить довольно
трудно. Параметр ǫ принимается равным небольшому целому чис-
лу для того, чтобы увеличить вероятность существования решения
системы уравнений на шаге 3. Дело в том, что полученная система
может содержать линейно зависимые уравнения (как это будет по-
казано в приводимом ниже примере). Считается, что при больших p
значение ǫ порядка 10 гарантирует существование единственного ре-
шения системы с высокой вероятностью (см. [28]). Если же все-таки
полученная система имеет бесконечно много решений, то необходимо
вернуться к шагу 2 и использовать другие значения k .
48                                    Глава 3. Методы взлома шифров

    Адлеман показал, что при оптимальном значении t для трудо-
емкости алгоритма имеем
                                             √
                   tи.п. < c1 2̇(c2 +o(1))       log p log log p
                                                                   ,
где c1 , c2 — некоторые положительные константы.
    П р и м е р 3.3. Решим с помощью алгоритма исчисления поряд-
ка уравнение
                          37 = 10x mod 47.                 (3.14)
Имеем y = 37, a = 10, p = 47. Возьмем множество базовых мно-
жителей S = {2, 3, 5}, t = 3, и примем ǫ = 1, т.е. будем строить
систему из четырех уравнений. Обозначим логарифмы чисел из S
через u1 , u2 , u3 соответственно, например, u3 = log10 5 mod 47 . Мы
выполнили первый шаг алгоритма, перейдем ко второму.
    Проведем поиск четырех 5-гладких чисел:
                                                   √
                  101 mod 47 = 10 = 2 · 5,         √
                  102 mod 47 = 6     = 2 · 3,
                  103 mod 47 = 13 = 13,            √
                  104 mod 47 = 36 = 2 · 2 · 3 · 3,
                  105 mod 47 = 31 = 31,
                  106 mod 47 = 28 = 2 · 2 · 7,     √
                  107 mod 47 = 45 = 3 · 3 · 5.
Мы нашли четыре 5-гладких числа, соответствующих степеням 1, 2,
4 и 7.
     Начинаем третий шаг алгоритма. Перейдем к логарифмам и со-
ставим систему уравнений
               √         из равенств, отмеченных на предыдущем
шаге символом :
                               1 = u 1 + u3 ,                          (3.15)
                               2 = u 1 + u2 ,                          (3.16)
                               4 = 2u1 + 2u2 ,                         (3.17)
                               7 = 2u2 + u3 .                          (3.18)
Мы видим, что в полученной системе уравнения (3.16) и (3.17) ли-
нейно зависимы, так что мы не зря нашли четвертое гладкое число.
Чтобы решить систему, вычтем (3.15) из (3.16). Получим
                                 1 = u2 − u3 .                         (3.19)
3.3. Алгоритм исчисления порядка                                      49

Прибавим (3.19) к (3.18). Получим

                                  8 = 3u2 .                        (3.20)

Из (3.20) непосредственно находим u2 :

      u2 = (8/3) mod 46 = 8 · 3−1 mod 46 = 8 · 31 mod 46 = 18.

Мы можем сделать проверку, вычислив 1018 mod 47 = 3, таким обра-
зом, u2 — действительно логарифм числа 3. Теперь из (3.19) находим
u3 :
                    u3 = u2 − 1 = 18 − 1 = 17
(действительно, 1017 mod 47 = 5). Наконец, из (3.16) находим u1 :

         u1 = 2 − u2 = (2 − 18) mod 46 = −16 mod 46 = 30

(1030 mod 47 = 2).
    Итак, теперь мы знаем логарифмы чисел из S . Самый трудоем-
кий этап алгоритма позади. Переходим к четвертому шагу. Начнем
с k = 3:
      37 · 103 mod 47 =   37 · 13 mod 47 = 11,                 √
      37 · 104 mod 47 =   37 · 36 mod 47 = 16 = 2 · 2 · 2 · 2.

    Переходим в последнем равенстве к логарифмам (это пятый
шаг) и получаем конечный результат:

          log10 37 = 4 log10 2 − 4 = (4 · 30 − 4) mod 46 = 24.

Мы нашли решение уравнения (3.14) x = 24. Можем сделать про-
верку: 1024 mod 47 = 37.                                  ⊔
                                                          ⊓
    Самым быстрым на данное время считается вариант рассмот-
ренного алгоритма исчисления порядка, называемый Number Field
Sieve. Этот метод использует тонкие алгебраические конструкции и
довольно сложен для описания. Его трудоемкость дается оценкой
                                          √
                                          3                2
                tn.f.s. < c1 · 2(c2 +o(1)) log p(log log p) , (3.21)

где c1 , c2 — некоторые положительные константы. Именно этот
метод диктует сегодня условия для выбора длин модулей крипто-
систем, стойкость которых основана на трудности вычисления дис-
кретных логарифмов (из рассмотренных во второй главе это система
50                              Глава 3. Методы взлома шифров

Диффи-Хеллмана, шифры Шамира и Эль-Гамаля). Для достижения
долговременной стойкости этих криптосистем рекомендуется брать
модули длиной не менее 1024 бит (по данным на 2005 год).
    В заключение отметим, что в нашей книге мы не рассматрива-
ем методы взлома криптосистем, основанных на факторизации чи-
сел (таких как RSA). Дело в том, что описание современных алго-
ритмов разложения числа на множители потребоволо бы введения
дополнительных понятий и алгоритмов из теории чисел, нигде боль-
ше в книге не используемых. Однако скажем, что по состоянию на
2005 год самые быстрые методы разложения чисел на множители
характеризуются такой же оценкой времени, которую дает выраже-
ние (3.21). Как следствие, для обеспечения стойкости системы RSA
длина модуля должна также быть не менее 1024 бит (т.е. простые
числа, дающие в произведении модуль RSA, должны быть длиной
минимум по 512 бит).


Задачи и упражнения
 3.1. Используя метод “шаг младенца, шаг великана”, решить сле-
      дующие уравнения:

        а. 2x mod 29 = 21,
        б. 3x mod 31 = 25,
        в. 2x mod 37 = 12,
        г. 6x mod 41 = 21,
       д. 3x mod 43 = 11.

 3.2. Используя алгоритм исчисления порядка, решить следующие
      уравнения:

        а. 2x mod 53 = 24,
        б. 2x mod 59 = 13,
        в. 2x mod 61 = 45,
        г. 2x mod 67 = 41,
       д. 7x mod 71 = 41.
Темы лабораторных работ                                    51

Темы лабораторных работ
3.3. Выполнить программную реализацию метода “шаг младенца,
     шаг великана” и алгоритма исчисления порядка и решить с
     помощью компьютера следующие уравнения:
       а. 2x mod 30203 = 24322 ,
       б. 2x mod 30323 = 21740 ,
       в. 2x mod 30539 = 28620 ,
       г. 2x mod 30803 = 16190 ,
       д. 5x mod 31607 = 30994
     (при недостатке времени достаточно реализовать программно
     только отдельные шаги алгоритмов).
Глава 4.    ЭЛЕКТРОННАЯ, ИЛИ ЦИФРОВАЯ
            ПОДПИСЬ




4.1.   Электронная подпись RSA
После появления криптографии с открытым ключом произошла на-
стоящая революция в современных компьютерных и сетевых техно-
логиях. Появилась возможность решать задачи, которые ранее счи-
тались неразрешимыми, а теперь находят широкое применение на
практике. В настоящее время при помощи этих технологий ежеднев-
но проводятся расчеты и совершаются сделки на многие миллиарды
долларов, рублей, евро и т.п. Одним из важных элементов этих тех-
нологий является электронная, или цифровая подпись. Во многих
странах и, в частности, в России введены стандарты на электронную
(цифровую) подпись, а само это понятие введено в гражданское за-
конодательство. Термин «электронная подпись» более привычен для
России, хотя в последнее время все чаще используется принятый в
других странах (прежде всего, в США) термин «цифровая подпись»,
что отражено и в новых российских стандартах. Оба термина озна-
чают одно и то же.
    Прежде чем начать рассмотрение криптографической цифровой
подписи, сформулируем три свойства, которым (в идеале) должна
удовлетворять любая, в частности, обычная рукописная подпись:

  1. Подписать документ может только «законный» владелец под-
     писи (и, следовательно, никто не может подделать подпись).

  2. Автор подписи не может от нее отказаться.

  3. В случае возникновения спора возможно участие третьих лиц
     (например, суда) для установления подлинности подписи.

    Разумеется, цифровая (электронная) подпись также должна об-
ладать всеми этими свойствами, однако лица, подписывающие доку-
менты и проверяющие их подлинность, могут находиться за тысячи
4.1. Электронная подпись RSA                                       53

километров друг от друга и взаимодействовать только через ком-
пьютерную сеть.
    Кроме обычной подписи, в реальной жизни используется так на-
зываемая нотариальная подпись, когда специально выделяемое лицо
(нотариус) заверяет документы своей подписью и печатью, так что
любое другое лицо может удостовериться в их подлинности. Аналог
этой подписи также востребован в киберпространстве. Электронная
нотариальная подпись реализуется точно так же, как и подпись лю-
бого другого лица.
    В этом разделе мы рассмотрим электронную подпись, базирую-
щуюся на схеме RSA.
    Если Алиса планирует подписывать документы, то она должна
вначале выбрать параметры RSA точно так же, как это описано в
разд. 2.6. Для этого Алиса выбирает два больших простых числа P
и Q, вычисляет N = P Q и φ = (P − 1)(Q − 1). Затем она выбирает
число d , взаимно простое с φ, и вычисляет c = d−1 mod φ. Нако-
нец, она публикует числа N и d , например, помещает их на своем
сайте, ассоциировав со своим именем, и хранит в секрете число c
(остальные числа P , Q и φ можно забыть, они больше не потре-
буются). Теперь Алиса готова ставить свои подписи на документах
или сообщениях.
    Пусть Алиса хочет подписать сообщение m̄ = m1 , . . . , mn . Тогда
вначале она вычисляет так называемую хеш-функцию
                         y = h(m1 , . . . , mn ),
которая ставит в соответствие сообщению m̄ число y . Предполага-
ется, что алгоритм вычисления хеш-функции всем известен. Но мы
пока не будем останавливаться на свойствах и способах вычисления
хеш-функции, так как этот вопрос будет более подробно рассмот-
рен в главе 8. Отметим только наиболее важное для нас свойство:
практически невозможно изменить основной текст m1 , . . . , mn , не
изменив y . Поэтому на следующем шаге Алисе достаточно снабдить
подписью только число y , и эта подпись будет относиться ко всему
сообщению m̄ .
    Алиса вычисляет число
                            s = y c mod N,                       (4.1)
т.е. она возводит число y в свою секретную степень. Число s это и
есть цифровая подпись. Она просто добавляется к сообщению m̄, и
54                     Глава 4. Электронная, или цифровая подпись

тем самым Алиса имеет сформированное подписанное сообщение

                                 hm̄, si .                           (4.2)

    Теперь каждый, кто знает открытые параметры Алисы, ассоци-
ированные с ее именем, т.е. числа N и d , может проверить подлин-
ность ее подписи. Для этого необходимо, взяв подписанное сообще-
ние (4.2), вычислить значение хеш-функции h(m̄), число

                             w = sd mod N                            (4.3)

и проверить выполнение равенства w = h(m̄).
     Утверждение 4.1. Если подпись подлинная, то w = h(m̄).
    Д о к а з а т е л ь с т в о . Из (4.3), (4.1) и свойств схемы RSA (см.
разд. 2.6) следует

               w = sd mod N = y cd mod N = y = h(m̄).                   ⊔
                                                                        ⊓


   Утверждение 4.2. Описанная электронная подпись удовле-
творяет всем требованиям, предъявляемым к подписи.
    Д о к а з а т е л ь с т в о . Проверим первое свойство подписи. Ни-
кто не может разложить число N на простые множители (при боль-
ших N порядка 1024 бит по состоянию на 2005 год эта задача прак-
тически неразрешима). Поэтому, зная N и d невозможно найти
c. Действительно, чтобы вычислить c = d−1 mod φ, нужно знать
φ = (P − 1)(Q − 1), а для этого нужно знать простые множители
P и Q. Таким образом, первое свойство выполнено — никто, кро-
ме Алисы, не может знать число c и поэтому не может подписать
сообщение.
    Второе свойство выполнено вследствие первого. Автор подписи
не может от нее отказаться, так как никто другой не может «сфаб-
риковать» подпись от его имени.
    Третье свойство также очевидно — в случае спора заинтересо-
ванная сторона может предъявить судье все вычисления для их про-
верки и выяснения истины.                                            ⊔
                                                                     ⊓
    П р и м е р 4.1. Пусть P = 5, Q = 11. Тогда N = 5 · 11 =
55, φ = 4 · 10 = 40. Пусть d = 3. Такой выбор d возможен, так
4.2. Электронная подпись на базе шифра Эль-Гамаля                       55

как gcd(40, 3) = 1. Параметр c = 3−1 mod 40 вычисляем с помощью
обобщенного алгоритма Евклида (см. разд. 2.3), c = 27.
    Пусть, например, Алиса хочет подписать сообщение m̄ = abbbaa,
для которого значение хеш-функции равно, скажем, 13:

                           y = h(abbbaa) = 13.

В этом случае Алиса вычисляет по (4.1)

                          s = 1327 mod 55 = 7

и формирует подписанное сообщение

                               habbbaa, 7i .

   Теперь тот, кто знает открытые ключи Алисы N = 55 и d = 3,
может проверить подлинность подписи. Получив подписанное сооб-
щение, он заново вычисляет значение хеш-функции

                             h(abbbaa) = 13

(если содержание сообщения не изменено, то значение хеш-функции
совпадет с тем, которое вычисляла Алиса) и вычисляет по (4.3)

                          w = 73 mod 55 = 13.

Значения w и хеш-функции совпали, значит, подпись верна.                 ⊔
                                                                         ⊓
     З а м е ч а н и е. Обратим внимание на то, что одна и та же схема RSA,
сгенерированная Алисой, может использоваться для решения двух задач.
Во-первых, Алиса может подписывать сообщения, как это было показано в
данном разделе, используя свой секретный ключ c . Во-вторых, кто угодно
может послать Алисе зашифрованное сообщение (число), расшифровать
которое, как это было показано в разд. 2.6, сможет только она, используя
для шифрования ее открытый ключ d .


4.2.    Электронная подпись на базе шифра
        Эль-Гамаля
В предыдущем разделе была описана схема электронной подписи,
необходимые свойства которой определяются сложностью решения
задачи разложения числа на множители. В этом разделе мы опишем
56                      Глава 4. Электронная, или цифровая подпись

вариант подписи, основанный на задаче дискретного логарифмиро-
вания.
    Пусть, как и выше, Алиса собирается подписывать документы.
Алиса выбирает большое простое число p и число g , такие, что раз-
личные степени g суть различные числа по модулю p (см. разд. 2.2).
Эти числа передаются или хранятся в открытом виде и могут быть
общими для целой группы пользователей. Алиса выбирает случай-
ное число x, 1 < x < p − 1, которое она держит в секрете. Это ее
секретный ключ, только она его знает. Затем она вычисляет число
                              y = g x mod p.                    (4.4)
Это число y Алиса публикует в качестве своего открытого ключа.
Заметим, что при больших p , зная y , невозможно найти x(это за-
дача дискретного логарифмирования).
    Теперь Алиса может подписывать сообщения. Допустим, она хо-
чет подписать сообщение m̄ = m1 , . . . , mn . Опишем последователь-
ность действий для построения подписи.
    Вначале Алиса вычисляет значение хеш-функции h = h(m̄), ко-
торое должно удовлетворять неравенству 1 < h < p. Затем Алиса
выбирает случайно число k ( 1 < k < p−1), взаимно простое с p−1,
и вычисляет число
                          r = g k mod p.                        (4.5)
Далее Алиса вычисляет числа
                         u = (h − xr) mod (p − 1),              (4.6)
                          s = k −1 u mod (p − 1).               (4.7)
        −1
Под k        в (4.7) подразумевается число, удовлетворяющее уравнению
                          k −1 k mod (p − 1) = 1.               (4.8)
Такое k −1 существует, так как k и p − 1 взаимно просты, и может
быть найдено по обобщенному алгоритму Евклида. Наконец, Алиса
формирует подписанное сообщение
                                hm̄; r, si.                     (4.9)
    Получатель подписанного сообщения (4.9), прежде всего, заново
вычисляет значение хеш-функции h = h(m̄). Затем он проверяет
подпись, используя равенство
                             y r rs = g h mod p.               (4.10)
4.2. Электронная подпись на базе шифра Эль-Гамаля                                            57

    Утверждение 4.3. Если подпись верна, то условие (4.10) вы-
полняется.

    Д о к а з а т е л ь с т в о . Действительно,
                          s
                               = g xr g k(k        (h−xr))
                 r
   y r rs = (g x )   gk                                      = g xr g h g −xr = g h mod p.
                                              −1




(Здесь первое равенство следует из (4.4) и (4.5), второе из (4.7).)                          ⊔
                                                                                             ⊓

   Утверждение 4.4. Описанная электронная подпись удовле-
творяет всем требованиям, предъявляемым к подписи.

     Д о к а з а т е л ь с т в о . Проверим первое свойство подписи (ни-
кто не может подделать подпись, другими словами, никто кроме
Алисы не может подписать сообщение ее подписью). Действитель-
но, из (4.6) мы видим, что при формировании подписи используется
секретное число x. Более того, сомножитель xr , используемый при
формировании подписи в (4.6), меняется от сообщения к сообщению
(так как k выбирается случайно, то и r случайно).
     По той же самой причине Алиса не сможет отказаться от своей
подписи, так как никто кроме нее не знает x, т.е. выполняется второе
свойство подписи.
     Понятно также, что в случае возникновения конфликта между
Алисой и Бобом, они могут обратиться к третьим лицам для вы-
явления истины. Судья может проверить все вычисления, если ему
предъявят числа x, m̄ и r .                                           ⊔
                                                                      ⊓
    П р и м е р 4.2. Пусть общие параметры для некоторого сообще-
ства пользователей p = 23, g = 5. Алиса выбирает свой секретный
ключ x = 7 и вычисляет открытый ключ y по (4.4):

                                  y = 57 mod 23 = 17.

Пусть Алиса создала документ m̄ = baaaab и хочет его подписать.
    Перейдем к вычислению подписи по алгоритму. Прежде всего
она вычисляет хеш-функцию, пусть ее значение h(m̄) = 3. Затем
Алиса генерирует случайное число k , например, k = 5. Вычисления
по (4.5), (4.6) дают
                      r = 55 mod 23 = 20,
                           u = (3 − 7 · 20) mod 22 = 17.
58                  Глава 4. Электронная, или цифровая подпись

Далее Алиса находит k −1 mod 22 :

                  k −1 mod 22 = 5−1 mod 22 = 9.

Вычисления по (4.7) дают

                      s = 9 · 17 mod 22 = 21.

Наконец, Алиса формирует подписанное сообщение в виде (4.9):

                         hbaaaab, 20, 21i.

Подписанное сообщение передается, Боб его получает и проверяет
подлинность подписи. Вначале он вычисляет значение хеш-функции

                           h(baaaab) = 3,

затем вычисляет левую часть (4.10)

              1720 · 2021 mod 23 = 16 · 15 mod 23 = 10

и после этого правую часть (4.10)

                           53 mod 23 = 10.

Боб делает вывод, что подпись верна.                           ⊔
                                                               ⊓
     Рассмотренный метод электронной подписи сложнее, чем RSA,
а его стойкость базируется на другой, нежели в RSA, односторонней
функции. Это важно для криптографии, так как в случае дискре-
дитации одного метода можно использовать другой. Кроме того, на
основе подписи Эль-Гамаля может быть построен более эффектив-
ный алгоритм, в котором время вычислений значительно сокраща-
ется за счет использования «коротких» показателей степени. Такой
алгоритм представлен в следующем разделе.

4.3.   Стандарты на электронную (цифровую)
       подпись
Во многих странах сегодня существуют стандарты на электронную
(цифровую) подпись. В этом разделе мы опишем российский госу-
дарственный стандарт ГОСТ Р34.10-94 и стандарт США FIPS 186.
4.3. Стандарты на электронную (цифровую) подпись                     59

Российский стандарт, как следует из его обозначения, был принят в
1994 году, американский — в 1991. В основе обоих стандартов лежит
по сути один и тот же алгоритм, называемый DSA (Digital Signature
Algorithm) и являющийся вариацией подписи Эль-Гамаля. Мы по-
дробно рассмотрим российскую версию алгоритма, а затем укажем
на отличия американской версии.
    Вначале для некоторого сообщества пользователей выбирают-
ся общие несекретные параметры. Прежде всего необходимо найти
два простых числа, q длиной 256 бит и p длиной 1024 бита, между
которыми выполняется соотношение

                              p = bq + 1                          (4.11)

для некоторого целого b . Старшие биты в p и q должны быть равны
единице. Затем выбирается число a > 1, такое, что

                             aq mod p = 1.                        (4.12)

В результате получаем три общих параметра — p , q и a.
    З а м е ч а н и е. Равенство (4.12) означает, что при возведении a в
степени по модулю p показатели приводятся по модулю q , т.е. ab mod
p = ab mod q mod p (мы уже проводили обоснование подобного феномена
при доказательстве утверждения 2.10 на стр. 30). Такое приведение будет
постоянно выполняться при генерации и проверке подписи, в результате
чего длина показателей степени в рамках рассматриваемого алгоритма
никогда не будет превышать 256 бит, что упрощает вычисления.
    Далее, каждый пользователь выбирает случайно число x, удо-
влетворяющее неравенству 0 < x < q , и вычисляет

                            y = ax mod p.                         (4.13)

Число x будет секретным ключом пользователя, а число y — от-
крытым ключом. Предполагается, что открытые ключи всех поль-
зователей указываются в некотором несекретном, но «сертифициро-
ванном» справочнике, который должен быть у всех, кто собирается
проверять подписи. Отметим, что в настоящее время найти x по
y практически невозможно при указанной выше длине модуля p .
На этом этап выбора параметров заканчивается, и мы готовы к то-
му, чтобы формировать и проверять подписи.
    Пусть имеется сообщение m̄, которое необходимо подписать. Ге-
нерация подписи выполняется следующим образом:
60                     Глава 4. Электронная, или цифровая подпись

     1. Вычисляем значение хеш-функции h = h(m̄) для сообщения
        m , значение хеш-функции должно лежать в пределах 0 < h < q
        (в российском варианте хеш-функция определяется ГОСТом
        Р34.11-94).

     2. Формируем случайное число k , 0 < k < q .
                                 
     3. Вычисляем r = ak mod p mod q . Если оказывается так, что
        r = 0, то возвращаемся к шагу 2.

     4. Вычисляем s = (kh + xr) mod q . Если s = 0, то возвращаемся
        к шагу 2.

     5. Получаем подписанное сообщение hm̄; r, si.

      Для проверки подписи делаем следующее.

     1. Вычисляем хеш-функцию для сообщения h = h(m̄).

     2. Проверяем выполнение неравенств 0 < r < q , 0 < s < q .

     3. Вычисляем u1 = s · h−1 mod q , u2 = −r · h−1 mod q .

     4. Вычисляем v = (au1 y u2 mod p) mod q .

     5. Проверяем выполнение равенства v = r .

    Если хотя бы одна из проверок на шагах 2 и 5 не дает нужно-
го результата, то подпись считается недействительной. Если же все
проверки удачны, то подпись считается подлинной.

    Утверждение 4.5. Если подпись к сообщению была сформиро-
вана законно, т.е. обладателем секретного ключа x, то v = r .

    Д о к а з а т е л ь с т в о . Запишем следующую цепочку равенств,
которая следует непосредственно из описания метода (напомним, что
показатели степени приводятся по модулю q ):
                       −1                   
                        ash y −rh mod p mod q =
                                    −1
             v =
                                                
                        a(kh+xr)h a−xrh mod p mod q =
                                   −1     −1
                 =
                                              
                        ak+xrh −xrh mod p mod q =
                                −1     −1
                 =
4.3. Стандарты на электронную (цифровую) подпись                      61
                                 
                       = ak mod p mod q = r.                           ⊔
                                                                       ⊓

     З а м е ч а н и е. Чтобы найти параметр a , удовлетворяющий (4.12),
рекомендуется использовать следующий метод. Берем случайное число
g > 1 и вычисляем
                             a = g (p−1)/q mod p.                  (4.14)
Если a > 1 , то это то, что нам нужно. Действительно, на основании (4.14)
и теоремы Ферма имеем
             aq mod p = g ((p−1)/q)q mod p = g p−1 mod p = 1,
т.е. выполняется равенство (4.12). Если при вычислении по (4.14) мы по-
лучаем a = 1 (крайне маловероятный случай), то нужно просто взять
другое число g .

    П р и м е р 4.3. Выберем общие несекретные параметры
                       q = 11,   p = 6q + 1 = 67,
возьмем g = 10 и вычислим
                         a = 106 mod 67 = 25.
Выберем секретный ключ x = 6 и вычислим открытый ключ
                         y = 256 mod 67 = 62.
Сформируем подпись для сообщения m̄ = baaaab. Пусть для хеш-
функции этого сообщения h(m̄) = 3. Возьмем случайно число k = 8.
Вычислим
                                 
              r = 258 mod 67 mod 11 = 24 mod 11 = 2,
              s = (8 · 3 + 6 · 2) mod 11 = 36 mod 11 = 3.
Получаем подписанное сообщение
                            hbaaaab; 2, 3i.
     Теперь выполним проверку подписи. Если сообщение не измене-
но, то h = 3. Вычислим
      h−1 = 3−1 mod 11 = 4,
      u1 = 3 · 4 mod 11 = 1,
      u2 = −2 · 4 mod 11 = −8 mod 11 = 3,
                           
      v = 251 · 623 mod 67 mod 11 =
                         = (25 · 9 mod 67) mod 11 = 24 mod 11 = 2.
62                      Глава 4. Электронная, или цифровая подпись

Мы видим, что v = r , значит подпись верна.                     ⊔
                                                                ⊓
    Теперь остановимся на отличиях американского стандарта от
российского. Они сводятся к следующему.

     1. Длина числа q берется равной 160 бит.

     2. В качестве хеш-функции используется алгоритм SHA-1.

     3. При генерации подписи на шаге 4 параметр s вычисляется по
        формуле s = k −1 (h + xr) mod q .

     4. При проверке подписи на шаге 3 u1 и u2 вычисляются по фор-
        мулам u1 = h · s−1 mod q , u2 = r · s−1 mod q .

С учетом этих отличий нетрудно переписать всю схему подписи в
«американском» стиле. Доказательство корректности алгоритма про-
водится совершенно аналогично.

Задачи и упражнения
        Во всех задачах будем предполагать, что h(m) = m для всех
        значений m .

 4.1. Построить подпись RSA для сообщения m при следующих
      параметрах пользователя:

          а. P = 5, Q = 11, c = 27 , m = 7 ,
          б. P = 5, Q = 13, c = 29 , m = 10 ,
          в. P = 7, Q = 11, c = 43 , m = 5 ,
          г. P = 7, Q = 13, c = 29 , m = 15 ,
          д. P = 3, Q = 11, c = 7 , m = 24.

 4.2. Для указаннных открытых ключей пользователя RSA прове-
      рить подлинность подписанных сообщений:

          а. N = 55 , d = 3 : h7, 28i, h22, 15i, h16, 36i,
          б. N = 65, d = 5 : h6, 42i, h10, 30i, h6, 41i,
          в. N = 77 , d = 7 : h13, 41i, h11, 28i, h5, 26i,
          г. N = 91, d = 5: h15, 71i, h11, 46i, h16, 74i,
Задачи и упражнения                                         63

       д. N = 33, d = 3: h10, 14i, h24, 18i, h17, 8i.

 4.3. Абоненты некоторой сети применяют подпись Эль-Гамаля с
      общими параметрами p = 23 , g = 5 . Для указанных сек-
      ретных параметров абонентов найти открытый ключ ( y ) и
      построить подпись для сообщения m:

       а. x = 11, k = 3, m = h = 15 ,
       б. x = 10, k = 15 , m = h = 5,
       в. x = 3, k = 13 , m = h = 8 ,
       г. x = 18, k = 7, m = h = 5 ,
       д. x = 9, k = 19 , m = h = 15 .

 4.4. Для указаннных открытых ключей ( y ) пользователей систе-
      мы Эль-Гамаля с общими параметрами p = 23, g = 5 прове-
      рить подлинность подписанных сообщений:

       а. y = 22: h15; 20, 3i, h15; 10, 5i, h15; 19, 3i,
       б. y = 9: h5; 19, 17i, h7; 17, 8i, h6; 17, 8i,
       в. y = 10: h3; 17, 12i, h2; 17, 12i, h8; 21, 11i,
       г. y = 6: h5; 17, 1i, h5; 11, 3i, h5; 17, 10i,
       д. y = 11: h15; 7, 1i, h10; 15, 3i, h15; 7, 16i.

 4.5. Сообщество пользователей ГОСТа Р34.10-94 имеют общие па-
      раметы q = 11, p = 67, a = 25. Вычислить открытый ключ
      (y ) и построить подпись для сообщения m при следующих
      секретных параметрах:

       а. x = 3, h = m = 10, k = 1 ,
       б. x = 8, h = m = 1, k = 3,
       в. x = 5, h = m = 5, k = 9,
       г. x = 2, h = m = 6, k = 7,
       д. x = 9, h = m = 7, k = 5.

 4.6. Для указаннных открытых ключей ( y ) пользователей ГОСТа
      Р34.10-94 с общими параметрами q = 11, p = 67, a = 25
      проверить подлинность подписанных сообщений:
64                         Глава 4. Электронная, или цифровая подпись

       а.   y   = 14 :   h10; 4, 5i, h10; 7, 5i, h10; 3, 8i,
       б.   y   = 24 :   h1; 3, 5i, h1; 4, 3i, h1; 4, 5i,
       в.   y   = 40 :   h7; 7, 4i, h7; 9, 2i, h5; 9, 2i,
       г.   y   = 22 :   h6; 9, 5i, h8; 8, 3i, h7; 4, 1i,
       д.   y   = 64 :   h10; 7, 3i, h7; 7, 10i, h8; 7, 5i.

Темы лабораторных работ
4.7. Разработать программы для генерации и проверки подписей
     RSA. Параметры пользователей необходимо выбрать самосто-
     ятельно. Для тестирования программы проверки подписи ре-
     комендуется использовать подписанное сообщение h500, 46514i
     для открытых ключей пользователя N = 52891 , d = 3 (пред-
     полагаем, что h(m) = m). Данное сообщение должно призна-
     ваться подлинным. Любое изменение компонентов подписан-
     ного сообщения с большой вероятностью будет делать подпись
     недействительной.
4.8. Разработать программы для генерации и проверки подписей
     Эль-Гамаля. Рекомендуемые значения общих открытых пара-
     метров p = 31259 , g = 2 . Остальные параметры пользова-
     телей выбрать самостоятельно. Для тестирования программы
     проверки подписи рекомендуется использовать подписанное
     сообщение h500; 27665, 26022i для открытого ключа пользо-
     вателя y = 16196 (предполагаем, что h(m) = m). Данное
     сообщение должно признаваться подлинным. Любое измене-
     ние компонентов подписанного сообщения с большой вероят-
     ностью будет делать подпись недействительной.
4.9. Разработать программы для генерации и проверки подписей
     по ГОСТ Р34.10-94. Рекомендуемые значения общих откры-
     тых параметров q = 787 , p = 31481 , a = 1928. Остальные па-
     раметры пользователей выбрать самостоятельно. Для тести-
     рования программы проверки подписи рекомендуется исполь-
     зовать подписанное сообщение h500; 655, 441i для открытого
     ключа пользователя y = 12785 (предполагаем, что h(m) =
     m). Данное сообщение должно признаваться подлинным. Лю-
     бое изменение компонентов подписанного сообщения с боль-
     шой вероятностью будет делать подпись недействительной.
Глава 5.    КРИПТОГРАФИЧЕСКИЕ
            ПРОТОКОЛЫ




Рассмотренные в предыдущих главах криптографические методы
часто используются в качестве инструментов для решения других
практически важных задач. Современная криптография позволяет
решать проблемы, которые ранее считались в принципе неразреши-
мыми. Причем в настоящее время многие такие возможности крип-
тографии используются в реальных компьютерных системах. Это и
заключение коммерческих сделок в режиме удаленного взаимодей-
ствия участников, и осуществление денежных расчетов по сети, и
проведение выборов по компьютерным сетям, и многое другое. Ме-
тоды решения подобных задач обычно описываются в форме так на-
зываемых криптографических протоколов. Некоторые из них будут
представлены в этой главе.
    Обратим внимание читателя на то, что криптографические ал-
горитмы не просто предоставляют новые возможности пользователю
(например, не нужно ходить в банк, можно произвести все необхо-
димые операции со своего домашнего компьютера). Важно то, что
они способны обеспечивать надежность значительно более высокую,
чем традиционные механизмы. Например, если бумажную банкно-
ту можно подделать, и случаи подделок весьма многочисленны, то
электронную банкноту, созданную при помощи криптографических
методов, подделать практически невозможно.
    Часто практически важные задачи формулируются в игровой,
забавной форме, для того чтобы представить идею в «чистом» виде,
не загромождая ее техническими деталями. Одна из таких задач —
«ментальный покер» — рассматривается в следующем разделе.

5.1.   Ментальный покер
Рассмотрим задачу проведения честной игры в карты, когда парт-
неры находятся далеко друг от друга, но связаны компьютерной се-
тью. Мы рассмотрим предельно упрощенную постановку задачи, где
66                          Глава 5. Криптографические протоколы

участвуют всего два игрока и всего три карты. Однако все основные
идеи будут продемонстрированы, а обобщения на другие случаи оче-
видны.
     Задача ставится следующим образом. Имеются два игрока Али-
са и Боб и три карты α , β , γ . Необходимо раздать карты следующим
образом: Алиса должна получить одну карту, Боб — также одну, а
одна карта должна остаться в прикупе. При этом необходимо, чтобы:
     1) каждый игрок мог получить с равными вероятностями любую
        из трех карт α , β или γ , а одна карта оказалась в прикупе;
     2) каждый игрок знал только свою карту, но не знал карту про-
        тивника и карту в прикупе;
     3) в случае спора возможно было пригласить судью и выяснить,
        кто прав, кто виноват;
     4) при раздаче карт с помощью компьютерной сети никто не знал,
        кому какая карта досталась (хотя раздача происходит по от-
        крытой линии связи и Ева может записать все передаваемые
        сообщения).
Дадим описание протокола, позволяющего организовать такую
раздачу карт. Его удобно разбить на два этапа.
    Предварительный этап необходим для выбора параметров про-
токола. Участники выбирают несекретное большое простое число p .
Затем Алиса выбирает случайно число cA , взаимно простое с p − 1,
и вычисляет по обобщенному алгоритму Евклида число dA , такое,
что
                      cA dA mod (p − 1) = 1.                (5.1)
      Независимо и аналогично Боб находит пару cB , dB ,такую, что

                        cB dB mod (p − 1) = 1.                  (5.2)

     Эти числа каждый игрок держит в секрете. Затем Алиса выби-
рает случайно три (различных) числа α̂ , β̂ , γ̂ в промежутке от 1 до
p − 1, в открытом виде передает их Бобу и сообщает, что α̂ соответ-
ствует α , β̂ — β , γ̂ — γ (т. е., например, число 3756 соответствует
тузу и т.д.).
     После этого начинается второй этап — собственно раздача карт,
который удобно описать по шагам.
5.1. Ментальный покер                                                     67

Шаг 1. Алиса вычисляет числа

                                u1 = α̂cA mod p,
                                u2 = β̂ cA mod p,
                                u3 = γ̂ cA mod p

     и высылает u1 , u2 , u3 Бобу, предварительно перемешав их
     случайным образом.
Шаг 2. Боб получает три числа, выбирает случайно одно из них,
   например u2 , и отправляет его Алисе по линии связи. Это и
   будет карта, которая достанется ей в процессе раздачи. Алиса,
   получив это сообщение, может вычислить

                   û = ud2A mod p = β̂ cA dA mod p = β̂,               (5.3)

     т.е. она узнает, что ей досталась карта β (можно и не вычис-
     лять (5.3), так как она знает, какое число ui какой карте соот-
     ветствует).
Шаг 3. Боб продолжает свои действия. Он вычисляет для остав-
   шихся двух чисел

                                v1 = uc1B mod p,                        (5.4)
                                v3 = uc3B mod p.                        (5.5)

     С вероятностью 1/2 он переставляет эти два числа и отправ-
     ляет Алисе.
Шаг 4. Алиса выбирает случайно одно из полученных чисел, на-
   пример v1 , вычисляет число

                              w1 = v1dA mod p                           (5.6)

     и отправляет это число обратно к Бобу. Боб вычисляет число

                               z = w1dB mod p                           (5.7)

     и узнает свою карту (у него получается α̂). Действительно,

          z = w1dB = v1dA dB = u1cB dB dA = α̂cA cB dA dB = α̂ mod p.

     Карта, соответствующая v2 , остается в прикупе.
68                          Глава 5. Криптографические протоколы

    Утверждение 5.1. Описанный протокол удовлетворяет всем
свойствам честной раздачи карт.

     Д о к а з а т е л ь с т в о . Мы дадим только идею доказательства.
Алиса перемешивает числа u1 , u2 , u3 перед отправкой к Бобу. Затем
Боб выбирает одно из этих чисел, не зная, какое число какой карте
соответствует . При этом, если Боб выбирает карту случайно, обес-
печивается то, что Алиса получает любую из карт с вероятностью
1/3. Аналогично, если Алиса выбирает одну из оставшихся двух карт
случайно с равными вероятностями, то Боб также получает любую
из трех карт с вероятностью 1/3. Очевидно, что при этих условиях
и в прикупе каждая из карт может оказаться с вероятностью 1/3.
     Интересно отметить, что если Алиса или Боб будут нарушать
некоторые требования протокола, то это может быть использовано
им во вред. Поэтому каждый участник заинтересован в точном вы-
полнении всех правил. Проверим это, считая, что игра повторяется
многократно.
     Предположим, что Алиса не перемешивает карты u1 , u2 , u3 ,
а всегда посылает их в одной и той же последовательности или ру-
ководствуется каким-либо другим простым правилом. Если раздача
карт выполняется несколько раз, то Боб может использовать это в
своих интересах (например, он всегда будет отправлять Алисе са-
мую младшую карту и в каждом случае будет знать, какая карта
ей досталась), т.е. Алисе выгодно перемешивать карты. Аналогично,
можно проверить, что при необходимости выбора каждому игроку
лучше выбирать карту случайно, с равными вероятностями.
     Проверим выполнение второго требования, предъявляемого к
честной раздаче карт. Когда Боб выбирает число ui , соответствую-
щее карте Алисы (шаг 2), он не знает секретное cA , следовательно,
он не может узнать, какое ui какой карте соответствует, а вычисле-
ние cA по ui эквивалентно задаче дискретного логарифмирования
и практически невозможно при больших p . Вообще говоря, когда
Алиса выбирает карту для Боба, а он для нее, никто из них не мо-
жет определить достоинство этой карты, так как оно зашифровано
при помощи либо cA , либо cB .
     Заметим, что ни Алиса, ни Боб не могут также знать, какая
карта осталась в прикупе, так как соответствующее число имеет вид
acA cB (см. (5.4) и (5.5)). Алиса не знает dB , а Боб не знает dA .
     Проверим третье свойство. В случае возникновения спора су-
5.1. Ментальный покер                                                69

дья может повторить все вычисления по записанным предаваемым
числам и выяснить, кто прав.
     Проверим четвертое свойство. По линии связи передаются числа
u1 , u2 , u3 , v1 , v2 , v3 и w1 . Каждое из них может быть представлено
в виде ax mod p , где x неизвестно Еве. Мы знаем, что нахождение
x — задача дискретного логарифмирования, которая практически
неразрешима. Значит Ева ничего не может узнать.                        ⊔
                                                                       ⊓
    П р и м е р 5.1. Пусть Алиса и Боб хотят честно раздать три кар-
ты: тройку (α ), семерку ( β ) и туза (γ ). (Точнее, обычно в крипто-
графии предполагается, что никто из них не хочет быть обманутым.
Большей «честности» от них не ожидают.) Пусть на предваритель-
ном этапе выбраны следующие параметры:

                  p = 23,    α̂ = 2,   β̂ = 3,   γ̂ = 5.

Алиса выбирает cA = 7, Боб выбирает cB = 9.
    Найдем по обобщенному алгоритму Евклида dA и dB : dA = 19 ,
dB = 5.
    Шаг 1. Алиса вычисляет

                            u1 = 27 mod 23 = 13,
                            u2 = 37 mod 23 = 2,
                            u3 = 57 mod 23 = 17.

Затем она перемешивает u1 , u2 , u3 и высылает их Бобу.
    Шаг 2. Боб выбирает одно из полученных чисел, пусть, напри-
мер, выбрано число 17. Он отправляет число 17 к Алисе. Она знает,
что число 17 соответствует карте γ , и, таким образом, ее карта при
раздаче — туз.
    Шаг 3. Боб вычисляет

                            v1 = 139 mod 23 = 3,
                            v2 = 29 mod 23 = 6

и отправляет эти числа к Алисе, возможно, переставив их местами.
    Шаг 4. Алиса получает числа 3 и 6, выбирает одно из них, пусть
это будет 3, и вычисляет число

                         w1 = 319 mod 23 = 6.
70                         Глава 5. Криптографические протоколы

Это число она отправляет Бобу, который вычисляет число

                         z = 65 mod 23 = 2

и узнает свою карту α , т.е. ему досталась тройка. В прикупе осталась
семерка, но ни Алиса, ни Боб этого не знают. Ева же, следившая
за всеми передаваемыми сообщениями, не может ничего узнать в
случае большого p .                                                ⊔
                                                                   ⊓


5.2.   Доказательства с нулевым знанием
Рассмотрим следующую задачу, возникающую в некоторых
криптографических приложениях. Снова участвуют Алиса и Боб.
Алиса знает решение некоторой сложной задачи, она хочет убедить
Боба в этом, однако так, чтобы Боб не узнал самого решения задачи.
Т.е. в результате Боб должен убедиться в том, что Алиса знает ре-
шение, но не должен узнать что-нибудь о самом решении. На первый
взгляд сама задача кажется абсурдной, а возможность ее решения —
фантастической! Для того чтобы лучше понять ситуацию, рассмот-
рим случай из жизни пиратов. Пусть, например, Алиса знает карту
острова, где спрятан клад, а Боб — капитан корабля, который может
доставить ее на остров. Алиса хочет доказать, что карта у нее есть,
не показывая ее Бобу (иначе Боб обойдется без Алисы, и весь клад
достанется ему).
     Такая же задача актуальна для компьютерных сетей в тех слу-
чаях, когда Боб (сервер или контроллер домена) должен принять
решение о допуске Алисы к информации, хранящейся в сети, но при
этом Алиса не хочет, чтобы кто-либо, прослушивающий канал пере-
дачи данных и сам сервер, получил какие-либо знания о ее пароле.
Т.е. Боб получает «нулевое знание» о пароле (или карте) Алисы, но
уверен, что у Алисы такой пароль (или карта) есть.
     Итак, наша задача — построить протокол «доказательства с ну-
левым знанием». При этом мы считаем, что каждый из участников
может вести «нечестную» игру и пытаться обмануть другого.
     В качестве сложной задачи, решение которой известно Алисе,
мы вначале рассмотрим задачу раскраски графа тремя красками.
Мы опишем достаточно простой в идейном плане протокол доказа-
тельства для этой задачи. Затем мы рассмотрим задачу нахожде-
ния гамильтонова цикла в графе с более сложным в идейном плане,
5.2. Доказательства с нулевым знанием                                71

но более эффективным в плане реализации протоколом доказатель-
ства. Отметим, что обе задачи — раскраски графа тремя красками
и нахождения гамильтонова цикла — являются NP-полными. Мы
не приводим формального определения NP-полноты, которое может
быть найдено, например, в [1]. Для читателя, не знакомого с этим
определением, отметим только, что NP-полнота задачи неформаль-
но означает, что время решения задачи растет экспоненциально с
ростом размера задачи (объема исходных данных).


Задача о раскраске графа

В задаче о раскраске графа рассматривается граф с множеством
вершин V и множеством ребер E (числа элементов в этих множе-
ствах будем обозначать через |V | и |E|). Алиса знает правильную
раскраску этого графа тремя красками (красной (R), синей (B) и
желтой (Y)). Правильная раскраска — это такая, когда любые две
вершины, соединенные одним ребром, окрашены разными цветами.
Приведем пример (рис. 5.1).

              Y                                R


 R                      R           Y                     Y




          R            B       Y           B             R       R

                  а                                б

     Рис. 5.1. Примеры раскрасок: а — правильная, б — неправильная



    Для получения правильной раскраски графа тремя красками
известны только экспоненциальные алгоритмы, т.е. такие, у кото-
рых время решения растет экспоненциально с ростом числа вершин
и ребер в графе. Поэтому в случае больших |V | и |E| эта задача
практически неразрешима.
72                        Глава 5. Криптографические протоколы

     Итак, Алиса знает (правильную) раскраску графа с большими
|V | и |E|. Она хочет доказать это Бобу, но так, чтобы он ничего не
узнал об этой раскраске.
     Протокол доказательства состоит из множества одинаковых эта-
пов. Опишем сначала один этап.

Шаг 1. Алиса выбирает случайно перестановку Π из трех букв R,
   B, Y и перенумеровывает все вершины графа согласно этой пе-
   рестановке. Очевидно, что раскраска останется верной. Напри-
   мер, если Π = (Y, R, B), то граф слева на рис. 5.1 превращается
   в граф на рис. 5.2.

                               B


                  Y                       Y



                          Y              R       B


                 Рис. 5.2. Другой вариант раскраски




Шаг 2. Для каждой вершины v из множества V Алиса генерирует
   большое случайное число r и заменяет в нем два последних
   бита на 00, что соответствует красной вершине, 01 — синей, 10
   — желтой.

Шаг 3. Для каждой вершины v Алиса формирует данные, исполь-
   зуемые в RSA, а именно, Pv , Qv , Nv = Pv Qv , cv и dv .

Шаг 4. Алиса вычисляет

                              Zv = rvdv mod Nv

     и посылает Бобу значения Nv , dv и Zv для каждой вершины
     графа.
5.2. Доказательства с нулевым знанием                                   73

Шаг 5. Боб выбирает случайно одно ребро из множества E и со-
   общает Алисе, какое именно ребро он выбрал . В ответ Алиса
   высылает числа cv1 и cv2 , соответствующие вершинам этого
   ребра. После этого Боб вычисляет
                   c                              c
           Ẑv1 = Zv1v1 mod Nv1 = rv1 ,   Ẑv2 = Zv2v2 mod Nv2 = rv2

     и сравнивает два младших бита в полученных числах. При пра-
     вильной раскраске два младших бита в числах Ẑv1 и Ẑv2 долж-
     ны быть различны. Если значения совпали, значит, Алиса пы-
     талась обмануть Боба, и на этом все заканчивается. Если не
     совпали, то весь описанный процесс повторяется a|E| раз, где
     a > 0 — параметр.

    Утверждение 5.2. Если Алиса не располагает правильной рас-
краской графа, то вероятность того, что она сможет обмануть
Боба не превышает e−a , где e ≈ 2.718 — число Эйлера (основание
натурального логарифма).
      З а м е ч а н и е. Если взять большое a , то вероятность обмана можно
сделать сколь угодно малой. Например, при a = 5 эта вероятность меньше
0.01.
    Д о к а з а т е л ь с т в о . Пусть Алиса не располагает правиль-
ной раскраской графа. Значит, хотя бы для одного ребра из E вер-
шины окрашены в один цвет. Если Алиса будет действовать по про-
токолу, то вероятность того, что Боб обратится к такому ребру, не
меньше 1/|E| (в этом случае Алиса разоблачена). Значит, вероят-
ность того, что Алиса не разоблачена во время одного этапа, не
превышает 1 − 1/|E| и, следовательно, вероятность того, что она
не будет разоблачена за a|E| этапов, не превышает (1 − 1/|E|)a|E| .
Используя известное неравенство 1 − x ≤ e−x , получаем
                                          a|E|
                 (1 − 1/|E|)a|E| ≤ e−1/|E|       = e−a .                 ⊔
                                                                         ⊓


    Проверим все свойства, необходимые для протокола с нулевым
знанием.

  1. Мы видим, что вероятность возможности обмана для Алисы
     может быть сделана сколь угодно малой.
74                           Глава 5. Криптографические протоколы

     2. Посмотрим, почему Боб не получает никакой информации о
        раскраске. Из-за того, что цвета переставляются случайно на
        каждом этапе (см. шаг 1), он не сможет узнать истинную рас-
        краску, перебирая все ребра одно за другим, и вообще он ничего
        не узнает о правильной раскраске. То, что на втором шаге вы-
        бирается случайное число rv , не позволяет Бобу вычислить по
        имеющимся Nv и dv коды соответствующих красок. Он не мо-
        жет декодировать полученное Zv потому, что он не знает чисел
        cv , так как они для всех вершин не высылаются, а вычислить
        их он не может , не зная Pv и Qv .

     3. Рассмотрим еще одну возможность обмана, которая в принципе
        может быть у Алисы. Казалось бы, Алиса может подменить cv1
        и cv2 , если ей это выгодно. Однако это невозможно в силу того,
        что число cv , удовлетворяющее равенству

                       cv dv mod ((Pv − 1)(Qv − 1)) = 1,

       единственно.

      Таким образом, выполнены все свойства:

     1) Алиса доказывает Бобу, что знает решение задачи, и вероят-
        ность того, что Боб обманут, не больше e−a ;

     2) Боб не получает никаких сведений о раскраске.

     Рассмотрим последнюю возможность обмана для всех участни-
ков. Что будет, если они будут уклоняться от указанного алгоритма,
выбирая параметры не случайно?
     Пусть, например, Боб запрашивает ребра графа не случайно, а
по какому-нибудь простому правилу (например, в соответствии с их
номерами). В этом случае, если у Алисы нет правильной раскраски,
то она сможет обмануть Боба, «правильно» раскрашивая те ребра,
которые будут запрошены. Таким образом, Боб заинтересован в том,
чтобы его запросы были случайны и не содержали в себе какой-либо
закономерности.
     Стойкость остальных шагов определяется стойкостью RSA, и
при больших Pv и Qv система достаточно надежена.
5.2. Доказательства с нулевым знанием                                 75

Задача о нахождении гамильтонова цикла в графе
Рассматриваемая в данном разделе задача не просто предоставляет
нам возможность описать еще одну схему построения протокола до-
казательства с нулевым знанием, но и имеет важное теоретическое
значение. Блюм (Manuel Blum) показал, что, выражаясь неформаль-
но, любое математическое утверждение может быть представлено в
виде графа, причем доказательство этого утверждения соответству-
ет гамильтонову циклу в этом графе (см., например, [34]). Поэтому
наличие протокола доказательства с нулевым знанием для гамиль-
тонова цикла означает, что доказательство любого математического
утверждения может быть представлено в форме доказательства с
нулевым знанием.
    Определение 5.1. Гамильтоновым циклом в графе называет-
ся непрерывный путь, проходящий через все вершины графа ровно
по одному разу.
    П р и м е р 5.2. Рассмотрим граф, изображенный на рис. 5.3.


                   1                           3
                              2


                                                   G

                                  7
                       8                           4



                                  6
                                              5


     Рис. 5.3. Граф с гамильтоновым циклом (8, 2, 4, 6, 3, 5, 7, 1)


      Путь, проходящий последовательно через вершины 8, 2, 4, 6, 3,
5, 7, 1, представляет собой гамильтонов цикл. Действительно, в этом
76                        Глава 5. Криптографические протоколы

пути содержатся все вершины графа, и каждая вершина посещается
только один раз.                                            ⊔
                                                            ⊓

     Ясно, что если в графе G с n вершинами гамильтонов цикл су-
ществует, то при некоторой нумерации вершин он пройдет точно че-
рез вершины с последовательными номерами 1, 2, 3, . . . , n. Поэтому
путем перебора всех возможных нумераций вершин мы обязатель-
но найдем гамильтонов цикл. Но количество возможных нумераций
равно n! , и поэтому уже при умеренно больших n , например, при
n = 100, такой подход становится практически нереализуемым. До-
казано, что задача нахождения гамильтонова цикла в графе явля-
ется NP-полной. Мы уже говорили кратко о понятии NP-полноты.
Неформально, NP-полнота рассматриваемой задачи означает, что
для ее решения не существуют (точнее, неизвестны) алгоритмы су-
щественно более быстрые, чем указанный метод перебора.
     Нашей задачей будет построение криптографического протоко-
ла, с помощью которого Алиса будет доказывать Бобу, что она знает
гамильтонов цикл в некотором графе G так, чтобы Боб не получил
никаких знаний о самом этом цикле. Иными словами, Алиса будет
предоставлять Бобу доказательство с нулевым знанием. Еще раз на-
помним читателю, что «нулевое знание» означает, что независимо от
числа реализаций протокола доказательства Боб будет располагать
точно такими же сведениями о гамильтоновом цикле, какие он мог
бы получить, просто изучая представленный ему граф G .
     Итак, допустим, что Алиса знает гамильтонов цикл в графе G .
Теперь она может это доказывать Бобу и всем, кто имеет граф G , с
помощью описываемого ниже протокола. Алиса может использовать
это доказательство, например, для идентификации своей личности.
Но прежде чем мы перейдем к описанию протокола, договоримся о
некоторых обозначениях.
     Мы будем обозначать графы буквами G , H , F , понимая под
этим одновременно соответствующие матрицы смежности. Элемент
матрицы Hij = 1, если в графе H есть ребро, соединяющее вершины
i и j ; Hij = 0 в противном случае. Символом k будем обозначать
конкатенацию (сцепление) двух чисел, точнее, двоичных слов, им
соответствующих. Нам понадобится шифр с открытым ключом. Во-
обще говоря, это может быть любой шифр, но для определенности
будем использовать шифр RSA (разд. 2.6). Будем считать, что Али-
са сформировала систему RSA с открытыми параметрами N и d .
5.2. Доказательства с нулевым знанием                        77

Важно, что зашифрованные в этой системе сообщения может рас-
шифровать только Алиса и больше никто.
    Протокол доказательства состоит из следующих четырех шагов
(пояснения будут даны ниже).

Шаг 1. Алиса строит граф H , являющийся копией исходного гра-
   фа G , где у всех вершин новые, случайно выбранные номера.
   На языке теории графов говорят, что H изоморфен G . Иными
   словами, H получается путем некоторой перестановки вершин
   в графе G (с сохранением связей между вершинами). Алиса
   кодирует матрицу H , приписывая к первоначально содержа-
   щимся в ней нулям и единицам случайные числа rij по схеме
   H̃ij = rij kHij . Затем она шифрует элементы матрицы H̃ , по-
                                              d
   лучая зашифрованную матрицу F , Fij = H̃ij   mod N . Матрицу
   F Алиса передает Бобу.

Шаг 2. Боб, получив зашифрованный граф F , задает Алисе один
   из двух вопросов.

      1. Каков гамильтонов цикл для графа H ?
      2. Действительно ли граф H изоморфен G ?

Шаг 3. Алиса отвечает на соответствующий вопрос Боба.

      1. Она расшифровывает в F ребра, образующие гамильто-
         нов цикл.
      2. Она расшифровывает F полностью (фактически передает
         Бобу граф H̃ ) и предъявляет перестановки, с помощью
         которых граф H был получен из графа G .

Шаг 4. Получив ответ, Боб проверяет правильность расшифровки
   путем повторного шифрования и сравнения с F и убеждается
   либо в том, что показанные ребра действительно образуют га-
   мильтонов цикл, либо в том, что предъявленные перестановки
   действительно переводят граф G в граф H .

    Весь протокол повторяется t раз.
    Обсудим вначале кратко несколько вопросов по построению про-
токола.
78                           Глава 5. Криптографические протоколы

     1. Зачем Алиса строит изоморфный граф? Если бы она этого не
        делала, то Боб, получив ответ на свой вопрос номер один, узнал
        бы гамильтонов цикл в графе G .
     2. Зачем Алиса кодирует матрицу H ? С этим приемом мы уже
        встречались при шифровании цветов вершин графа. Дело в
        том, что невозможно зашифровать непосредственно нули и еди-
        ницы (с помощью шифра RSA они вообще не шифруются). Да-
        же если заменить их на какие-то произвольные числа a и b ,
        то мы получим всего два различных шифротекста, и Бобу не
        составит труда понять, какой из них какому числу соответству-
        ет. Т.е. структура графа не будет скрыта. Здесь мы сталкива-
        емся с типичной ситуацией, когда требуется использовать так
        называемый рандомизированный шифр. И такой шифр стро-
        ится путем добавления случайных чисел в матрицу H перед
        шифрованием. Закодированная матрица H̃ точно также зада-
        ет граф (нечетность числа означает наличие ребра, четность —
        его отсутствие), но после шифрования H̃ структура графа пол-
        ностью скрывается (мы используем известное свойство шифра
        RSA — он полностью скрывает четность числа [26]).
     3. Зачем Боб задает два вопроса? Если бы он задавал только во-
        прос номер один, который по смыслу протокола является ос-
        новным, то Алиса, не зная в действительности гамильтонова
        цикла в графе G , могла бы предъявить Бобу совсем другой
        граф с таким же количеством вершин и искуственно заложен-
        ным в него гамильтоновым циклом. Поэтому Боб иногда просит
        Алису доказать изоморфизм графов H и G . Важно, что Алиса
        не знает заранее, какой из двух вопросов задаст Боб.
     4. Почему Боб не может задать сразу двух вопросов? В этом слу-
        чае он узнал бы гамильтонов цикл в G , так как ему был бы
        показан гамильтонов цикл в H и правило перехода от H к G .
     5. Зачем Боб проверяет правильность расшифровки? Если бы он
        этого не делал, то Алиса на четвертом шаге могла бы предоста-
        вить ему «выгодную» для себя информацию, а не ту, которую
        она посылала ему на втором шаге.
    Более точно основные детали протокола обосновываются в ходе
доказательства двух основных утверждений.
5.2. Доказательства с нулевым знанием                               79

    Утверждение 5.3. Вероятность обмана при t реализациях
протокола не превосходит 2−t .

     Д о к а з а т е л ь с т в о . Вначале покажем, что вероятность об-
мана в одной реализации протокола равна 1/2. Заметим, что если
Алиса действительно знает гамильтонов цикл в графе G , то она мо-
жет правильно ответить на любой вопрос Боба. Если же она не знает
гамильтонов цикл, то самое большее, что она может сделать, — это
подготовиться к ответу на первый либо на второй вопрос. В ожи-
дании первого вопроса, она создает новый граф с искусственно за-
ложенным в него гамильтоновым циклом. Но в этом случае она не
сможет доказать его изоморфизм графу G . В ожидании второго во-
проса, она строит граф, изоморфный графу G . Но в этом случае она
не сможет показать в нем гамильтонов цикл. Таким образом, веро-
ятность успешности обмана равна вероятности угадывания номера
вопроса. В предположении, что Боб задает оба вопроса с одинако-
выми вероятностями, мы получаем, что вероятность обмана равна
1/2.
     Так как Боб прекращает игру при первом же неправильном от-
вете, вероятность обмана при t реализациях протокола не превосхо-
дит (1/2)t .                                                         ⊔
                                                                     ⊓

    Утверждение 5.4. Представленный протокол реализует до-
казательство с нулевым знанием.

     Д о к а з а т е л ь с т в о . Чтобы доказать, что Боб не получает
никаких знаний в ходе реализации протокола, достаточно показать,
что все, что он получает от Алисы, он мог бы получить сам, не
вступая с ней ни в какое общение.
     Рассмотрим вначале второй вопрос Боба. В ответ на этот вопрос
он получает граф, изоморфный графу G . Но он сам мог строить
сколько угодно изоморфных графов, и то, что присылает ему Алиса,
это просто один из них.
     Случай с первым вопросом не столь очевиден. В ответ на первый
вопрос Боб получает гамильтонов цикл в графе, изоморфном графу
G . На первый взгляд может показаться, что это дает Бобу какую-
то информацию. Однако это не так. Заметим, что если в G есть
гамильтонов цикл, то при некоторой нумерации вершин существует
80                           Глава 5. Криптографические протоколы

изоморфный граф, который задается матрицей смежности вида

                                              
                       ∗ 1 ∗       ···   ∗ ∗ ∗
                      ∗ ∗ 1       ···   ∗ ∗ ∗ 
                                              
                                  ···         
                     
                      ∗ ∗ ∗
                                               ,                (5.8)
                                  ···   ∗ 1 ∗ 
                                               
                      ∗ ∗ ∗       ···   ∗ ∗ 1 
                       1 ∗ ∗       ···   ∗ ∗ ∗


где ∗ означает неопределенность в наличии или отсутствии ребра.
Т.е. при такой нумерации гамильтонов цикл проходит через вершины
в порядке возрастания номеров. Изменяя нумерацию вершин, Боб
может получать из (5.8) всевозможные изоморфные матрицы. Когда
Алиса, отвечая на его первый вопрос, открывает гамильтонов цикл,
Боб видит как раз одну из таких матриц.
    Таким образом, Боб не получает от Алисы никакой информации,
которую он не мог бы получить сам.                           ⊔
                                                             ⊓

    Рассмотрим пример, иллюстрирующий все основные этапы опи-
санного протокола.

   П р и м е р 5.3. Возьмем в качестве основного граф G , изобра-
женный на рис. 5.3. Его матрица смежности имеет вид

                                                           
                     1   2     3     4    5   6     7   8
          
                1   0   0     1     0    0   1   1     1   
                                                            
                                                           
                2   0   0     1     1    0   0   0     1   
                                                           
                3   1   1     0     0    1   1   1     0   
                                                           
        G=
                4   0   1     0     0    0   1   0     0   .
                                                            
          
                5   0   0     1     0    0   0   1     1   
                                                            
                               1
                                                           
                6   1   0           1    0   0   0     0   
                                                           
                7   1   0     1     0    1   0   0     0   
                 8   1   1     0     0    1   0   0     0


В матрице с помощью · показан гамильтонов цикл. Алиса выбирает
некоторую случайную нумерацию вершин, скажем, 7, 4, 5, 3, 1, 2, 8,
5.2. Доказательства с нулевым знанием                       81

6, и получает изоморфный граф
                                                   
                   7   4   5    3   1   2   8   6
         
              7   0   0   1    1   1   0   0   0   
                                                    
                                                   
              4   0   0   0    0   0   1   0   1   
                                                   
              5   1   0   0    1   0   0   1   0   
                                                   
       H=
              3   1   0   1    0   1   1   0   1   .
                                                    
         
              1   1   0   0    1   0   0   1   1   
                                                    
                       1
                                                   
              2   0       0    1   0   0   1   0   
                                                   
              8   0   0   1    0   1   1   0   0   
               6   0   1   0    1   1   0   0   0
Для шифрования матрицы будем использовать систему RSA с пара-
метрами N = 55, d = 3. Вначале закодируем матрицу H . В рам-
ках данного примера просто припишем слева к каждому элементу
матрицы выбираемую случайно с равными вероятностями цифру из
множества {1, 2, 3, 4, 5}:
                                              
                     50 20 11 31 21 40 20 10
                  40 30 50 20 10 41 50 21 
                                              
                  41 30 50 11 30 20 51 40 
                                              
                  11 10 41 30 51 41 30 21 
           H̃ =  31 20 40 11 50 10 41 31  .
                                               
                                              
                  50 41 20 21 40 10 21 50 
                                              
                  40 30 31 50 41 21 30 40 
                     20 41 10 51 41 20 30 40

Теперь мы шифруем матрицу H̃ , возводя каждый ее элемент в куб
по модулю 55:
                                               
                40 25 11 36 21 35 25 10
               35 50 40 25 10 06 40 21 
                                               
               06 50 40 11 50 25 46 35 
                                               
               11 10 06 50 46 06 50 21 
           F =
                                               .
               36 25 35 11 40 10 06 36 
                                                
               40 06 25 21 35 10 21 40 
                                               
               35 50 36 40 06 21 50 35 
                25 06 10 46 06 25 50 35
(При внимательном просмотре матрицы F может показаться, что
использованный нами шифр плохо скрывает исходную матрицу H .
82                              Глава 5. Криптографические протоколы

Это объясняется тем, что, во-первых, модуль 55 слишком мал и, во-
вторых, в матрице H̃ много чисел, не взаимно простых с модулем.
Для реальных систем RSA, где N — большое число, такая ситуация
практически исключена.)
     Боб получает матрицу F и задает один из двух вопросов. Если
он просит доказать изоморфизм графов, то Алиса просто посыла-
ет ему кодированную матрицу H̃ и использованную нумерацию 7,
4, 5, 3, 1, 2, 8, 6. Боб проверяет соответствие матрицы H̃ матри-
це F , т.е.выполнение равенств 503 mod 55 = 40, 203 mod 55 = 25 и
т.д. Из матрицы H̃ Боб получает граф H (просто отбросив стар-
шую десятичную цифру). Затем он переставляет вершины графа G
в соответствии с полученной нумерацией, как это делала Алиса, и
убеждается в том, что H и G — один и тот же граф.
     Если Боб просит показать ему гамильтонов цикл, то Алиса по-
сылает ему соответствующий список (закодированных) ребер графа
H : (1, 5, 21), (5, 7, 41), (7, 6, 21), . . . , (3, 1, 41). Каждый элемент содер-
жит номера вершин и код ребра. Боб проверяет соответствие указан-
ных в списке ребер матрице F , например, 213 mod 55 = 21 = F1,5 ,
413 mod 55 = 06 = F5,7 и т.д. Затем он убеждается, что указанный в
списке путь проходит через все вершины графа по одному разу. ⊓                 ⊔

5.3.    Электронные деньги
Во многих странах люди оплачивают покупки при помощи электрон-
ных карточек, заказывают авиабилеты через Интернет, покупают
самые разнообразные товары в Интернет-магазинах. Сведения о по-
купках накапливаются в магазинах и банках. Поэтому появилась
новая проблема, иногда называемая «проблема Большого Брата».
    Суть проблемы состоит в том, что исчезает анонимность про-
цесса покупки, т.е. информация о покупках любого человека может
стать известной третьим лицам и использоваться против него. На-
пример, сведения о покупке билета на поезд или самолет могут пред-
ставлять интерес для преступников, информация о закупках алко-
гольных напитков политическим деятелем может быть использована
против него его противниками и т.д., и т.п.
    Поэтому возникла идея разработать такие схемы электронных
платежей, которые сохраняли бы анонимность покупателя в той же
степени, что и при расчете наличными деньгами. Такие протоколы
называются электронными или цифровыми деньгами (digital cache),
5.3. Электронные деньги                                         83

что подчеркивает их основное свойство — они обеспечивают ту же
степень анонимности, что и обычные деньги. Некоторые схемы уже
используются в реальной жизни. Описываемая ниже схема была
предложена Д. Чаумом (David Chaum), см. [2, 26].
    Мы рассмотрим две «плохие» схемы, а затем «хорошую», чтобы
было легче понять суть метода.
    Вначале дадим более точную постановку задачи. Имеются три
участника: банк, покупатель и магазин. Покупатель и магазин име-
ют соответствующие счета в банке, и покупатель хочет купить неко-
торый товар в магазине. Покупка осуществляется в виде трехсту-
пенчатого процесса:
  1) покупатель снимает нужную сумму со своего счета в банке;
  2) покупатель «пересылает» деньги в магазин;
  3) магазин сообщает об этом в банк, соответствующая сумма де-
     нег зачисляется на счет магазина, а покупатель забирает то-
     вар(или последний ему доставляется).
    Наша цель — разработать такую схему, чтобы
   • она была надежна;
   • чтобы банк не знал, кто купил товар, т.е. была сохранена ано-
     нимность обычных денег.
    Опишем первую «плохую» схему (она базируется на RSA). Банк
имеет следующую информацию: секретные числа P , Q, c и откры-
тые
                         N = P Q,
                   d = c−1 mod (P − 1)(Q − 1).               (5.9)
Допустим, покупатель решил израсходовать некоторую заранее ого-
воренную с банком сумму (например, 100$). (Мы сначала рассмот-
рим случай, когда может использоваться «банкнота» только одного
номинала (скажем, 100$).) Покупатель высылает в банк число n ,
которое будет номером банкноты (обычно требуется, чтобы генери-
ровалось случайное число в промежутке [2, N − 1]).
    Банк вычисляет число

                          s = nc mod N                      (5.10)
84                              Глава 5. Криптографические протоколы

и формирует банкноту hn, si, которую возвращает покупателю, пре-
дварительно уменьшив его счет на 100$. Параметр s в банкноте —
это подпись банка. Никто не может подделать подпись, так как число
c секретно.
     Покупатель предъявляет банкноту hn, si в магазине, чтобы ку-
пить товар. Магазин отправляет эту банкноту в банк для проверки.
Прежде всего, банк проверяет правильность подписи (эту проверку
мог бы сделать и магазин, используя открытые ключи банка). Но
кроме этого банк хранит все номера возвратившихся к нему банк-
нот и проверяет, нет ли числа n в этом списке. Если n есть в списке,
то платеж не принимается (кто-то пытается использовать банкноту
повторно), и банк сообщает об этом магазину. Если же все проверки
прошли успешно, то банк добавляет 100$ на счет магазина, а магазин
отпускает товар покупателю.
     Недостаток этой схемы — отсутствует анонимность. Банк, а так-
же все, кто имеет доступ к открытым линиям связи, могут запом-
нить, какому покупателю соответствует число n , и тем самым вы-
яснить, кто купил товар.
     Рассмотрим вторую «плохую» схему, которая уже обеспечи-
вает анонимность. Эта схема базируется на так называемой «слепой
подписи».
     Снова покупатель хочет купить товар. Он генерирует число n ,
которое теперь не будет посылаться в банк. Затем он генерирует
случайное число r , взаимно простое с N , и вычисляет число

                             n̂ = (n · rd ) mod N.                      (5.11)

Число n̂ покупатель отправляет в банк.
   Банк вычисляет число

                                ŝ = n̂c mod N                          (5.12)

и отправляет ŝ обратно покупателю (не забыв при этом снять 100$
с его счета).
     Покупатель находит число r−1 mod N и вычисляет

                             s = (ŝ · r−1 ) mod N.                     (5.13)

      Заметим, что с учетом соотношений (5.12), (5.11) и (5.9) имеем

     s = n̂c · r−1 = (n · rd )c · r−1 = nc rdc · r−1 = nc r1 r−1 = nc mod N,
5.3. Электронные деньги                                          85

т.е. мы получили подпись банка к n (см. (5.10)), но самого числа n
ни банк, ни кто либо другой не видел. Вычисление (5.12) называется
«слепой подписью», так как реальное сообщение ( n ) подписываю-
щий не видит и узнать не может.
      Таким образом, покупатель имеет число n , которое никому не
известно и никогда не передавалось по каналам связи, и подпись бан-
ка s, совпадающую с вычисленной по (5.10). Покупатель формирует
банкноту hn, si и действует так же, как в первой «плохой» схеме.
Но теперь никто не знает, кому соответствует эта банкнота, т.е. она
стала анонимной, как обычная бумажная банкнота.
      Действия магазина и банка после предъявления покупателем
банкноты hn, si ничем не отличаются от действий, описанных в пер-
вой схеме.
      Почему же данная схема плохая? Она имеет следующий недоста-
ток: можно сфабриковать фальшивую банкноту, если известны хотя
бы две настоящие. Делается это так. Путь злоумышленник (будь то
покупатель или магазин) имеет две настоящие банкноты hn1 , s1 i и
hn2 , s2 i. Тогда он легко сможет изготовить фальшивую банкноту
hn3 , s3 i, вычислив числа

                             n3 = n1 n2 mod N,
                             s3 = s1 s2 mod N.

Действительно,

              nc3 = (n1 n2 )c = nc1 nc2 = s1 s2 = s3 mod N,   (5.14)

т.е. s3 является правильной подписью для n3 , и у банка нет никаких
оснований, чтобы не принять эту фальшивую банкноту (он просто
не сможет отличить ее от подлинной). Это так называемое «мульти-
пликативное свойство» системы RSA.
     Опишем, наконец, «хорошую» схему, в которой устранены все
недостатки первых двух. В одном варианте такой схемы использует-
ся некоторая односторонняя функция

                    f : {1, . . . , N } → {1, . . . , N }
(f вычисляется легко, а обратная к ней функция f −1 — очень труд-
но). Функция f не секретна и известна всем (покупателю, банку и
магазину).
86                        Глава 5. Криптографические протоколы

     Банкнота теперь определяется как пара чисел hn, sf i, где
                                   c
                        sf = (f (n)) mod N,

т.е. подписывается не n , а значение f (n).
      Покупатель генерирует n (никому его не показывая), вычисля-
ет f (n), подписывает в банке при помощи «слепой подписи» число
f (n) и формирует банкноту hn, sf i. Эта банкнота обладает всеми
хорошими свойствами, как и во второй схеме, в то же время подде-
лать такую банкноту невозможно, так как невозможно вычислить
f −1 . Для проверки подписи (т.е. подлинности банкноты) нужно вы-
числить f (n) и убедиться, что

                         sdf mod N = f (n).

     Заметим, что при выборе односторонней функции нужно прояв-
лять осторожность. Например, функция f (n) = n2 mod N , которая
действительно является односторонней, не годится для рассматри-
ваемого протокола. Читатель может проверить, что банкноты, со-
зданные с использованием такой функции, будут по-прежнему обла-
дать мультипликативным свойством (5.14). На практике в качестве
f (n) обычно используются криптографичесие хеш-функции, описы-
ваемые в главе 8.
     Все остальные действия магазина и банка остаются такими же,
как и в ранее описанных схемах.
     Есть еще один, более простой, способ борьбы с мультипликатив-
ным свойством системы RSA — внесение избыточности в сообщение.
Допустим, что длина модуля N — 1024 бита. Такой же может быть
и длина числа n . Будем записывать (случайно выбираемый) номер
банкноты только в младшие 512 бит n , а в старшие 512 бит n за-
пишем некоторое фиксированное число. Это фиксированное число
может нести полезную информацию, такую, как номинал банкно-
ты и наименование банка (с помощью 512 бит можно представить
строку из 64 символов ASCII). Теперь банк при предъявлении ему
банкноты будет обязательно проверять наличие фиксированного за-
головка в параметре n и отвергать банкноту в случае его отсутствия.
Вероятность того, что при перемножении двух чисел по модулю N
результат совпадет с ними в 512 битах пренебрежимо мала. Поэтому
получить фальшивую банкноту по формуле (5.14) не удастся.
5.3. Электронные деньги                                        87

     П р и м е р 5.4. Пусть в качестве секретных параметров банка
выбраны числа P = 17 , Q = 7, c = 77. Соответствующие им откры-
тые параметры будут N = 119 , d = 5. Для исключения возможности
подделки банкнот их допустимыми номерами считаются только чис-
ла, состоящие из двух одинаковых десятичных цифр, например, 11,
77, 99.
     Когда покупатель хочет получить банкноту, он вначале случай-
ным образом выбирает ее номер (из числа допустимых). Предпо-
ложим, он выбрал n = 33. Затем он находит случайное число r ,
взаимнопростое со 119. Допустим, r = 67, gcd(67, 119) = 1. Далее,
покупатель вычисляет

          n̂ = (33 · 675 ) mod 119 = (33 · 16) mod 119 = 52.

Именно число 52 он посылает в банк.
   Банк списывает со счета покупателя 100$ и отправляет ему чис-
ло
                    ŝ = 5277 mod 119 = 103.
    Покупатель вычисляет r−1 = 67−1 mod 119 = 16 и s = 103 ·
16 mod 119 = 101 и получает платежеспособную банкноту

                          hn, si = h33, 101i.

Эту банкноту он приносит (или посылает) в магазин, чтобы купить
товар.
    Магазин предъявляет банкноту в банк. Банк делает следующие
проверки:

  1) номер банкноты ( n = 33) состоит из двух одинаковых десятич-
     ных цифр (т.е. содержит требуемую избыточность);

  2) ранее банкнота с таким номером не предъявлялась;

  2) подпись банка верна, т.е. 335 mod 119 = 101.

Так как все проверки прошли успешно, банк зачисляет 100$ (это
фиксированный номинал банкноты) на счет магазина, о чем ему и
сообщает. Магазин отпускает товар покупателю.              ⊔
                                                           ⊓
    В завершение разберем еще две проблемы, возникающие в связи
с рассмотренной схемой электронных денег.
88                        Глава 5. Криптографические протоколы

      В представленной схеме независимо действующие покупатели
или даже один покупатель, который не помнит номеров ранее ис-
пользованных им банкнот, могут случайно сгенерировать две или
более банкноты с одинаковыми номерами. По условиям протокола
банк примет к оплате только одну из таких банкнот (ту, которая
будет предъявлена первой). Однако примем во внимание размеры
чисел, используемых в протоколе. Если номер банкноты — число
длиной 512 бит и покупатели генерируют его действительно случай-
ным образом, то вероятность получения когда либо двух одинаковых
номеров пренебрежимо мала.
      Вторая проблема состоит в том, что в рассмотренной схеме ис-
пользуются только банкноты одного фиксированного номинала, что,
конечно, неудобно для покупателя. Решение проблемы использова-
ния банкнот разного номинала возможно следующим образом. Банк
заводит несколько пар (ci , di ), обладающих свойством (5.9), и объ-
являет, что d1 соответствует, например, 1000 руб., d2 — 500 руб.
и т.д. Когда покупатель запрашивает слепую подпись в банке, он
дополнительно сообщает, какого номинала банкноту он хочет полу-
чить. Банк снимает с его счета сумму, равную указанному номиналу,
и формирует подпись, используя соответствующее секретное число
ci . Когда впоследствии банк получает подписанную банкноту, он ис-
пользует для проверки подписи по очереди числа d1 , d2 и т.д. Если
подпись оказалась верна для какого-то di , то принимается банкно-
та i-го номинала. В случае, когда параметр n банкноты содержит
фиксированный заголовок с указанием ее номинала, задача провер-
ки подписи облегчается — банк сразу использует нужный ключ di .


5.4.   Взаимная идентификация
       с установлением ключа

В данном разделе мы рассмотрим криптографически стойкий про-
токол, в результате реализации которого два абонента сети A и B
взаимно идентифицируют друг друга (т.е. A убеждается в том, что
взаимодействует с B , а B — в том, что он взаимодействует с A) и
формируют общий секретный ключ, который может использоваться
в дальнейшем для шифрования передаваемых ими сообщений. В ре-
альной жизни в качестве A и B могут выступать пользователь и
компьютерная система или две различные компьютерные системы
5.4. Взаимная идентификация с установлением ключа              89

— суть описываемого ниже протокола от этого не меняется.
     В процессе описания мы рассматриваем различные, все более
изощренные типы атак и средства защиты от них. Так мы уже рас-
сматривали ранее (см. разд. 2.1 и 2.2) подходы к решению задачи
идентификации и установления ключа. Однако мы исходили из то-
го, что противник может только прослушивать информацию, пере-
даваемую по открытому каналу. Но в современных сетях передачи
данных, например в Интернете, информация от одного пользователя
передается другому через множество промежуточных узлов (марш-
рутизаторы, шлюзы, почтовые серверы и т.д..), не контролируемых
этими пользователями. В результате противник, обосновавшийся на
одном таком промежуточном узле, может не только прослушивать
информацию, т.е. играть чисто пассивную роль, но и осуществлять
активные воздействия, например, изменять, добавлять или удалять
сообщения.
     Разберем, например, типичную атаку на систему Диффи–Хелл-
мана в сети связи с активным противником. Алиса выбирает свое
секретное число XA и посылает Бобу g XA . Боб выбирает свое сек-
ретное число XB и посылает Алисе g XB . Однако Ева перехватывает
эти числа и посылает вместо них и Алисе, и Бобу g XE , где XE — ее
число. Все эти числа выглядят как совершенно случайные, так что
ни Алиса, ни Боб ничего не подозревают. В результате Алиса фор-
мирует ключ KA = g XE XA , а Боб — ключ KB = g XE XB . Оба этих
ключа могут быть легко вычислены и Евой. Теперь, когда Алиса
посылает Бобу сообщение, зашифрованное с ключом KA , Ева рас-
шифровывает его, снова шифрует с ключом KB и отправляет Бобу.
Аналогично Ева действует и при передаче сообщений в обратном
направлении. Боб и Алиса взаимодействуют, как им кажется, в за-
щищенном режиме, но на самом деле Ева читает все их сообщения.
     Такая атака становится невозможной, если Алиса и Боб не пере-
дают открытые ключи (в системе Диффи–Хеллмана это YA = g XA
и YB = g XB ) по каналу связи, а выбирают их из некоторой таблицы
или справочника, который был получен ими ранее из «надежного»
источника (как это предполагалось в разд. 2.2).
     Вообще, большинство криптосистем с открытыми ключами тре-
буют наличия некоторой организационной структуры, занимающей-
ся сертификацией открытых ключей. Такая структура может, напри-
мер, выглядеть следующим образом. В сети, которой принадлежат
Алиса и Боб, имеется «честный» пользователь Трент (абонент T ),
90                         Глава 5. Криптографические протоколы

который заинтересован только в том, чтобы сеть работала надеж-
но (скорее всего это не человек, а хорошо охраняемый компьютер,
работающий по жестко заложенной программе). Трент располагает
какой-либо надежной криптосистемой (например, RSA с длиной мо-
дуля порядка 10000 бит) с соответствующими открытыми ключами
и выполняет всего две функции:
     1) он добавляет в свою базу данных информацию об открытом
        ключе пользователя, присылаемую в виде сообщения, зашиф-
        рованного с использованием открытого ключа Трента;
     2) он сообщает информацию о чьем-либо открытом ключе, снаб-
        женную своей подписью.
Открытые ключи Трента доводятся до сведения всех пользовате-
лей каким-либо способом, исключающим вмешательство Евы. На-
пример, они публикуются в виде рекламного сообщения в газете.
Теперь Алиса, вычислив свой открытый ключ, формирует сообще-
ние из своего имени и этого ключа, шифрует его с использованием
открытого ключа Трента и посылает Тренту (никто кроме Трента не
может расшифровать это сообщение). Боб, когда ему нужен откры-
тый ключ Алисы, посылает запрос Тренту, и Трент присылает ему
подписанный ключ Алисы (никто не может подделать подпись Трен-
та). Боб проверяет подпись Трента, используя его открытый ключ,
и принимает ключ Алисы как достоверный. Таким образом, каждый
пользователь сети получает достоверную информацию об открытых
ключах других пользователей, и Ева никак не может вмешаться в
этот процесс.
     Итак, если Алиса и Боб пользуются достоверными открыты-
ми ключами, то схема Диффи–Хеллмана решает задачу установле-
ния секретного ключа. Однако она непосредственно не обеспечивает
идентификацию пользователей. Действительно, если вместо Алисы
выступала Ева, которая не знает секретного ключа Алисы, то у них
с Бобом будут сформированы различные секретные ключи, но это
может выясниться только позднее, на стадии обмена данными, когда
Боб, например, не сможет расшифровать переданное ему сообщение
или обнаружит, что «Алиса» не понимает того, что он посылает ей.
Часто требуется обеспечить явную идентификацию, чтобы по завер-
шении протокола стороны точно знали, кто есть кто.
     У схемы Диффи–Хеллмана есть и другой недостаток: секрет-
ный ключ, который формируют Алиса и Боб, будет всегда один и
5.4. Взаимная идентификация с установлением ключа             91

тот же, пока они не поменяют открытые ключи. Но смена открытых
ключей — это относительно долгий процесс (например, обычно тре-
буется оповестить всех пользователей сети об изменении какого-то
открытого ключа, чтобы они могли скорректировать информацию в
своих справочниках). Хотелось бы иметь протокол, обеспечивающий
оперативное создание каждый раз различных, случайно выбираемых
секретных ключей.
     Решение состоит в использовании какого-либо шифра с откры-
тым ключом для передачи секретных ключей. Обозначим шифр со-
общения x, построенный с использованием открытого ключа пользо-
вателя A, через PA (x). (Например, PA (x) может быть шифром RSA
или шифром Эль-Гамаля. В случае RSA PA (x) = xdA mod NA , где
пара чисел dA и NA представляет собой открытый ключ пользова-
теля A.) Все, кто знает открытый ключ A, могут вычислить PA (x)
для сообщения x. В то же время только A, знающий соответствую-
щий секретный ключ, может получить x из y = PA (x). Аналогично
(PB (x)) будем обозначать шифр, построенный с помощью открыто-
го ключа пользователя B . Символом k , как и ранее, будем обозна-
чать конкатенацию чисел. Мы опишем протокол поэтапно, чтобы не
«утопить» читателя в деталях.
     Напомним, что мы решаем следующую задачу: Алиса и Боб хо-
тят взаимно идентифицировать друг-друга и установить общий сек-
ретный ключ. Рассмотрим вначале следующий (плохой) протокол,
состоящий из трех шагов, чтобы обсудить несколько важных вопро-
сов.
Шаг 1. Алиса придумывает секретный ключ k1 , шифрует его, ис-
   пользуя открытый ключ Боба, и посылает Бобу:
                         A −→ B :    PB (k1 ).             (5.15)

Шаг 2. Боб расшифровывает k1 , снова шифрует его, используя от-
   крытый ключ Алисы, и посылает Алисе:
                         A ←− B :    PA (k1 ).             (5.16)

Шаг 3. Алиса расшифровывает k1 и сравнивает его с тем, который
   она придумала на шаге 1.
    Что мы имеем в результате реализации этого протокола? Во-
первых, Алиса и Боб получили общий секретный ключ k1 , неиз-
вестный Еве (Ева не может расшифровать ни PB (k1 ), ни PA (k1 )).
92                        Глава 5. Криптографические протоколы

Во-вторых, Алиса получила криптографически стойкую идентифи-
кацию Боба, так как никто кроме него не смог бы расшифровать k1 .
Очевидно, что в данном протоколе Боб не получает никакой иденти-
фикации Алисы (сообщение (5.15) мог послать кто угодно). Он мог
бы провести симметричный протокол со своей стороны:


                     A ←− B :    PA (k2 ),                   (5.17)
                     A −→ B :    PB (k2 )                    (5.18)


и получить такую идентификацию. Проблема, однако, здесь состоит
в логической независимости двух протоколов, в результате чего нет
гарантии, что оба протокола проводятся одними и теми же участни-
ками.
    Но есть и более тонкая проблема. Алиса может использовать
описанный протокол для вскрытия криптосистемы Боба! Делается
это так. Допустим, Алиса перехватила какое-то сообщение y , пред-
назначенное для Боба, т. е. y = PB (x). Она притворяется, что хочет
войти в систему Боба, и запускает протокол (5.15), (5.16). Однако
вместо PB (k1 ) она передает Бобу сообщение y . Так как k1 — про-
извольно выбранное число, то Боб не может ничего заподозрить. Он
честно выполняет свой шаг в протоколе и расшифровывает для Али-
сы x!
    Урок, который следует отсюда извлечь, следующий: никогда ни
для кого не следует расшифровывать случайные числа. Это может
повредить вашей безопасности. Средство борьбы с такой «опасной»
случайностью — внесение избыточности в сообщения, например, вве-
дение какого-либо элемента, известного получателю и ожидаемого
им. В частности, в (5.15) Алиса могла бы послать свое имя. Она
могла бы построить сообщение, отведя 512 бит под случайное чис-
ло k1 и 512 бит под свое имя, адрес, фрагмент открытого ключа и
другую легко проверяемую информацию (будем обозначать все это
вместе через Â ), и послать Бобу PB (k1 kÂ). В этом случае Боб не
стал бы посылать Алисе сообщение x, так как его соответствующие
512 бит наверняка не содержали бы Â .
   Все вышеизложенное приводит нас к следующему протоколу
Нидхама–Шредера (Needham, Schroeder, см., например, [28]), кото-
рый полностью решает посталенную в начале раздела задачу.
5.4. Взаимная идентификация с установлением ключа              93

Шаг 1. Алиса выбирает случайное число k1 , объединяет его со сво-
   ей открытой информацией Â и посылает Бобу

                        A −→ B :     PB (k1 kÂ).           (5.19)

Шаг 2. Боб расшифровывает (5.19) и убеждается в том, что полу-
   ченное сообщение содержит открытую информацию Алисы Â .
   Затем он выбирает случайное число k2 , объединяет его с k1 и
   посылает Алисе

                        A ←− B :     PA (k1 kk2 ).          (5.20)

Шаг 3. Алиса расшифровывает (5.20) и убеждается в том, что по-
   лученное сообщение содержит k1 . Это является для нее надеж-
   ным признаком идентификации Боба, так как никто другой не
   мог бы извлечь k1 из (5.19). Алиса посылает Бобу

                          A −→ B :    PB (k2 ).             (5.21)

Шаг 4. Боб расшифровывает (5.21) и убеждается в том, что он по-
   лучил k2 . Это является для него надежным признаком иден-
   тификации Алисы, так как никто другой не мог бы извлечь k2
   из (5.20).
    Теперь Алиса и Боб могут сформировать из k1 , k2 общий ключ,
например, k = k1 ⊕ k2 , где ⊕ — побитовая сумма по модулю 2, или
использовать k1 и k2 по-отдельности для шифрования входящих и
исходящих сообщений.
    П р и м е р 5.5. Пусть в некоторой сети используется шифр Эль-
Гамаля с открытыми параметрами p = 107, g = 2. Пользователи A и
B имеют открытые ключи dA = 58, dB = 28, которым соответству-
ют секретные cA = 33 , cB = 45 . Рассмотрим реализацию протокола
Нидхама–Шредера для взаимной идентификации пользователей A
и B и установления общего секретного ключа. Учитывая неболь-
шую величину модуля p в нашем примере, будем использовать в
качестве идентификаторов пользователей одну цифру в десятичной
записи, пусть Â = 1 , B̂ = 2 , и секретный ключ будем получать
также в виде одной десятичной цифры.
    На первом шаге протокола A выбирает секретный ключ, пусть
k1 = 3, и формирует сообщение m = k1 kÂ = 31. Это сообщение
94                         Глава 5. Криптографические протоколы

шифруется шифром Эль-Гамаля на открытом ключе пользователя
B:

               k = 15, r = g k mod p = 215 mod 107 = 26,
               e = m · dB k mod p = 31 · 2815 mod 107 = 47.

Пара чисел (26, 47) и есть тот шифротекст, который необходимо по-
слать B . В использованных при описании протокола обозначениях
PB (k1 kÂ) = (26, 47) и

                        A −→ B :     (26, 47).

    На втором шаге протокола B расшифровывает (26, 47), исполь-
зуя свой секретный ключ:

        m′ = e · rp−1−cB mod p = 47 · 26106−45 mod 107 = 31.

B убеждается, что младшая цифра содержит идентификационный
номер пользователя A и извлекает k1 = 3. Затем он выбирает свое
секретное число, пусть k2 = 7, формирует сообщение m = k1 kk2 =
37 и шифрует его на открытом ключе A:

               k = 77, r = g k mod p = 277 mod 107 = 63,
               e = m · dA k mod p = 37 · 5877 mod 107 = 18.

Пара чисел (63, 18) — это то, что нужно послать A. Т.е. PA (k1 kk2 ) =
(63, 18) и
                        A ←− B : (63, 18).
     На третьем шаге A расшифровывает (63, 18):

        m′ = e · rp−1−cA mod p = 18 · 63106−33 mod 107 = 37.

A убеждается в том, что старшая цифра содержит k1 = 3 и извле-
кает k2 = 7. Теперь A шифрует k2 для B :

             k = 41,   r = g k mod p = 241 mod 107 = 82,
             e = m · dB k mod p = 7 · 2841 mod 107 = 49,

и посылает B
                        A −→ B :     (82, 49).
Задачи и упражнения                                               95

   На четвертом шаге B расшифровывает (82, 49):

        m′ = e · rp−1−cB mod p = 49 · 82106−45 mod 107 = 7.

B убеждается в том, что он получил свое число k2 = 7 .
    Теперь A и B могут сформировать общий ключ по заранее ого-
воренной схеме, например,

    k = k1 ⊕ k2 mod 10 = 3 ⊕ 7 = (011)2 ⊕ (111)2 = (100)2 = 4.     ⊔
                                                                   ⊓




Задачи и упражнения
 5.1. Для реализации протокола “ментальный покер” выбраны сле-
      дующие общие параметры: p = 23, α̂ = 5, β̂ = 7, γ̂ = 14.
      Кроме того, имеются следующие варианты для Алисы и Бо-
      ба:
       а. cA = 13 , cB = 5 , Алиса перемешивает карты по пра-
          вилу (1, 2, 3) −→ (3, 2, 1), Боб выбирает первое число и
          использует перестановку (1, 2) −→ (2, 1). Алиса выбира-
          ет второе из полученных чисел.
       б. cA = 7 , cB = 15 , Алиса перемешивает карты по пра-
          вилу (1, 2, 3) −→ (1, 3, 2), Боб выбирает второе число и
          использует перестановку (1, 2) −→ (1, 2). Алиса выбира-
          ет первое из полученных чисел.
       в. cA = 19 , cB = 3 , Алиса перемешивает карты по пра-
          вилу (1, 2, 3) −→ (2, 1, 3), Боб выбирает второе число и
          использует перестановку (1, 2) −→ (2, 1). Алиса выбира-
          ет второе из полученных чисел.
        г. cA = 9 , cB = 7 , Алиса перемешивает карты по прави-
           лу (1, 2, 3) −→ (3, 2, 1), Боб выбирает третье число и ис-
           пользует перестановку (1, 2) −→ (1, 2). Алиса выбирает
           второе из полученных чисел.
       д. cA = 15 , cB = 5 , Алиса перемешивает карты по пра-
          вилу (1, 2, 3) −→ (1, 2, 3), Боб выбирает первое число и
          использует перестановку (1, 2) −→ (2, 1). Алиса выбира-
          ет первое из полученных чисел.
96                       Глава 5. Криптографические протоколы

     Определить, какие карты достанутся Алисе и Бобу. Какие пе-
     редаваемые числа будет наблюдать Ева?

 5.2. В системе электронных денег выбраны секретные параметры
      банка P = 17, Q = 7 , c = 77, а соответствующие им откры-
      тые параметры N = 119, d = 5. Сформировать электронные
      банкноты со следующими номерами:
       а. n = 11 при r = 5 ,
       б. n = 99 при r = 6 ,
       в. n = 55 при r = 10 ,
       г. n = 44 при r = 15 ,
       д. n = 77 при r = 30 .

Темы лабораторных работ
5.3. Выполнить компьютерную реализацию протокола “Менталь-
     ный покер”, самостоятельно выбрав все необходимые пара-
     метры.
5.4. Выполнить компьютерную реализацию протокола доказатель-
     ства с нулевым знанием на основе задачи о раскраске графа,
     все необходимые параметры выбрать самостоятельно.
5.5. Выполнить компьютерную реализацию протокола доказатель-
     ства с нулевым знанием на основе задачи о гамильтоновом
     цикле в графе, все необходимые параметры выбрать самостоя-
     тельно.
5.6. Выполнить компьютерную реализацию протокола “Электрон-
     ные деньги”, все необходимые параметры выбрать самостоя-
     тельно.

5.7. Выполнить компьютерную реализацию протокола Нидхама–
     Шредера, конкретный вид шифра с открытым ключем и все
     необходимые параметры выбрать самостоятельно.
Глава 6.    КРИПТОСИСТЕМЫ НА
            ЭЛЛИПТИЧЕСКИХ КРИВЫХ




6.1.   Введение
В этой главе мы рассмотрим одно из новых направлений криптогра-
фии с открытыми ключами — системы на эллиптических кривых.
Эллиптические кривые давно изучались в математике, но их исполь-
зование в криптографических целях было впервые предложено Коб-
лицом (Neal Koblitz) и Миллером (Victor Miller) в 1985 году. Пят-
надцать лет интенсивных исследований этих систем подтвердили их
полезные свойства и привели к открытию множества эффективных
методов их реализации. С 1998 года использование эллиптических
кривых для решения криптографических задач, таких, как цифро-
вая подпись, было закреплено в стандартах США ANSI X9.62 и FIPS
186-2, а в 2001 году аналогичный стандарт, ГОСТ Р34.10-2001, был
принят и в России.
    Основное достоинство криптосистем на эллиптических кривых
состоит в том, что по сравнению с «обычными» криптосистемами,
которые мы рассматривали в предыдущих главах, они обеспечива-
ют существенно более высокую стойкость при равной трудоемкости
или, наоборот, существенно меньшую трудоемкость при равной стой-
кости. Это объясняется тем, что для вычисления обратных функ-
ций на эллиптических кривых известны только алгоритмы с экспо-
ненциальным ростом трудоемкости, тогда как для обычных систем
предложены субэкспоненциальные методы. В результате тот уровень
стойкости, который достигается, скажем, в RSA при использовании
1024-битовых модулей, в системах на эллиптических кривых реали-
зуется при размере модуля 160 бит, что обеспечивает более простую
как программную, так и аппаратную реализацию.
    Детальное изучение эллиптических кривых требует знаний выс-
шей алгебры, в особенности алгебраической геометрии. Мы, однако,
постараемся изложить материал без привлечения сложных алгебра-
ических конструкций и в объеме, достаточном для понимания прин-
98             Глава 6. Криптосистемы на эллиптических кривых

ципов построения и работы соответствующих криптосистем. Более
подробное изложение теории эллиптических кривых и их использо-
вания в криптографии может быть найдено, например, в [20, 27, 36].

6.2.   Математические основы
Кривая третьего порядка E , задаваемая уравнением вида
                     E:     Y 2 = X 3 + aX + b,               (6.1)
называется эллиптической кривой (на самом деле уравнение (6.1)
получено путем замены переменных из более общего уравнения, ко-
торое нас не будет интересовать).
                      √
    Поскольку Y = ± X 3 + aX + b , график кривой симметричен
относительно оси абсцисс. Чтобы найти точки его пересечения с осью
абсцисс, необходимо решить кубическое уравнение
                          X 3 + aX + b = 0.                   (6.2)
Это можно сделать с помощью известных формул Кардано. Дискри-
минант этого уравнения
                           3   2
                           a       b
                      D=        +      .                 (6.3)
                           3       2
Если D < 0, то (6.2) имеет три различных действительных корня
α , β , γ ; если D = 0, то (6.2) имеет три действительных корня,
скажем, α , β , β , по крайней мере два из которых равны; наконец,
если D > 0, уравнение (6.2) имеет один действительный корень α
и два комплексно сопряженных. Вид кривой во всех трех случаях
представлен на рисунках 6.1—6.3.
     Кривая, представленная на рис. 6.2, называется сингулярной.
В ее точке сингулярности (β, 0) имеются две касательные. Сингу-
лярные кривые мы будем исключать из нашего рассмотрения. По-
этому при задании кривой с помощью параметров a и b потребуем
выполнения условия D 6= 0 , что эквивалентно условию
                           4a3 + 27b2 6= 0.                   (6.4)
    Итак, пусть эллиптическая кривая E задана уравнением (6.1) с
ограничением на коэффициенты (6.4). Определим операцию компо-
зиции точек на кривой. Возьмем какие-либо две точки P = (x1 , y1 ),
6.2. Математические основы                           99


                             Y


                                           X
                 α           β
                              γ




              Рис. 6.1. Эллиптическая кривая D < 0



                             Y


                                 β         X
                 α




              Рис. 6.2. Эллиптическая кривая D = 0



                             Y


                                           X
                 α




              Рис. 6.3. Эллиптическая кривая D > 0
100               Глава 6. Криптосистемы на эллиптических кривых


                              Y


                                              R′

                                  Q

                                                         X


              P

                                              R




                  Рис. 6.4. Композиция точек R = P + Q




Q = (x2 , y2 ) ∈ E и проведем через них прямую (рис. 6.4). Эта прямая
обязательно пересечет кривую в третьей точке, которую обозначим
через R′ . (Третья точка обязательно существует. Дело в том, что ку-
бическое уравнение, получаемое после подстановки уравнения пря-
мой в (6.1), имеет два действительных корня, соответствующих точ-
кам P и Q, следовательно, его третий корень, соответствующий R′ ,
также действителен.) Точку R = (x3 , y3 ) получим путем изменения
знака ординаты точки R′ . Будем обозначать описанную операцию
композиции точек следующим образом: R = P + Q.
    Пусть точка P ∈ E имеет координаты (x, y). Тогда точку с ко-
ординатами (x, −y) будем обозначать −P . Будем считать, что вер-
тикальная прямая, проходящая через P и −P , пересекает кривую в
бесконечно удаленной точке O , т.е. P + (−P ) = O . По соглашению
P + O = O + P = P . Как мы увидим в дальнейшем, точка O будет
играть роль нуля в операциях на эллиптической кривой.
    Теперь представим, что точки P и Q (рис. 6.4) сближаются
6.2. Математические основы                                        101

друг с другом и, наконец, сливаются в одну точку P = Q = (x1 , y1 ).
Тогда композиция R = (x3 , y3 ) = P + Q = P + P будет получена
путем проведения касательной в точке P и отражения ее второго
пересечения с кривой R′ относительно оси абсцисс (рис. 6.5). Будем
использовать следующее обозначение: R = P + P = [2]P .


                            Y

                                               R′

                   P


                                                     X




                                               R




              Рис. 6.5. Удвоение точки R = P + P = [2]P


    Выведем формулы для определения координат результирующей
точки R = (x3 , y3 ) на основе координат исходных точек P = (x1 , y1 )
и Q = (x2 , y2 ). Рассмотрим вначале случай, когда P 6= ±Q, R =
P + Q (рис. 6.4). Обозначим через k угловой коэффициент прямой,
проходящей через P и Q. Очевидно, что
                                 y2 − y 1
                            k=            .                      (6.5)
                                 x2 − x1

Тогда уравнение прямой будет иметь вид Y − y1 = k(X − x1 ), откуда

                        Y = y1 + k(X − x1 ).                     (6.6)
102             Глава 6. Криптосистемы на эллиптических кривых

Подставим найденное выражение для переменной Y в уравнение
кривой (6.1). Получим
                                  2
                 (y1 + k(X − x1 )) = X 3 + aX + b.

Возводя в квадрат и группируя подобные члены, получим кубиче-
ское уравнение
                      X 3 − k 2 X 2 + · · · = 0.
Известно, что сумма корней кубического уравнения равна коэффи-
циенту при X 2 , взятому с противоположным знаком (теорема Виета
для кубических уравнений), т.е.

                         x1 + x2 + x3 = k 2 ,

откуда
                         x3 = k 2 − x1 − x2 .                  (6.7)
Подставив найденное значение x3 в уравнение прямой (6.6), найдем
ординату точки R′ , y3′ = y1 + k(x3 − x1 ), и, изменив знак, получим

                       y3 = k(x1 − x3 ) − y1 .                 (6.8)

Итак, мы нашли координаты интересующей нас точки R .
    Теперь рассмотрим случай, когда P = Q и результирующая
точка R = [2]P (рис. 6.5). Дифференцируя обе части (6.1) по X ,
получим
                        2Y Y ′ = 3X 2 + a.
Угловой коэффициент касательной равен значению производной в
точке P ,
                            3x2 + a
                        k= 1        .                   (6.9)
                              2y1
Дальнейшие рассуждения аналогичны первому случаю, и координа-
ты точки R определяются по тем же формулам (6.7) и (6.8). Заме-
тим, что если ордината точки P равна нулю, то касательная прохо-
дит параллельно оси ординат и [2]P = O .
    Используя полученные формулы для вычисления композиции и
принятые соглашения относительно точки в бесконечности, можно
доказать следующие свойства точек на эллиптической кривой:
  1) P + Q = Q + P для всех точек P, Q ∈ E ;
6.2. Математические основы                                      103

  2) P + (Q + S) = (P + Q) + S для всех точек P, Q, S ∈ E ;
  3) существует нулевой элемент O (точка в бесконечности), такой,
     что P + O = O + P = P для всех P ∈ E ;
  4) для каждой точки P ∈ E существует точка −P ∈ E , такая,
     что P + (−P ) = O .
Перечисленные свойства точек совпадают со свойствами целых чи-
сел при использовании операции сложения. Поэтому композицию то-
чек часто называют сложением точек, а операцию [2]P — удвоением
точки.
     Продолжая аналогию со сложением чисел, удобно ввести следу-
ющие обозначения. Для целого m

                     [m]P = P + P + · · · + P ,
                            |     {z         }
                                     m
                     [0]P = O,
                   [−m]P = −(P + P + · · · + P ).
                               |   {z         }
                                         m

     Теперь мы готовы к тому, чтобы сделать последний шаг, необхо-
димый для криптографического использования эллиптических кри-
вых. Мы видим, что при вычислении композиции точек на кривой
(см. формулы (6.5), (6.9), (6.7) и (6.8)) используются только опера-
ции сложения, вычитания, умножения и деления чисел. Это значит,
что все приведенные выше тождества сохранятся, если мы будем вы-
полнять вычисления с целыми числами по модулю простого числа p .
В этом случае сложение и умножение чисел выполняются по модулю
p , разность u − v вычисляется как u + (p − v) mod p , а деление u/v
выполняется путем умножения u на v −1 mod p (простота модуля га-
рантирует, что для любого положительного числа v < p существует
число v −1 , такое, что vv −1 mod p = 1).
     В результате мы получаем кривую

                E:    Y 2 = X 3 + aX + b     (mod p).         (6.10)

В уравнении (6.10) переменные X, Y и коэффициенты a, b прини-
мают целочисленные значения, а все вычисления выполняются по
модулю p . В соответствии с (6.4) на a, b налагается ограничение

                      (4a3 + 27b2 ) mod p 6= 0.               (6.11)
104               Глава 6. Криптосистемы на эллиптических кривых

Множество Ep (a, b) состоит из всех точек (x, y), 0 ≤ x, y < p, удо-
влетворяющих уравнению (6.10), и точки в бесконечности O . Коли-
чество точек в Ep (a, b) будем обозначать #Ep (a, b). Эта величина
имеет важное значение для криптографических приложений эллип-
тических кривых.
      П р и м е р 6.1. Рассмотрим кривую

               E7 (2, 6) :   Y 2 = X 3 + 2X + 6      (mod 7).        (6.12)

Проверим условие (6.11):

             4 · 23 + 27 · 62 = 4 · 1 + 6 · 1 = 3 6= 0   (mod 7).

Итак, данная кривая несингулярна. Найдем какую-нибудь (случай-
ную) точку в E7 (2, 6). Пусть x = 5 . Тогда

             Y 2 = 53 + 2 · 5 + 6 = 6 + 3 + 6 = 1        (mod 7)

и y = 1 (mod 7) или y = −1 = 6 (mod 7). Мы нашли сразу две точ-
ки: (5, 1) и (5, 6). Найдем еще пару точек путем вычисления ком-
позиции. Вначале найдем [2](5, 1). Используя (6.9), (6.7) и (6.8), вы-
числяем
                             3 · 52 + 2  0
                      k=                = =0       (mod 7),
                                2·1      2

                      x3 = 0 − 2 · 5 = 4 (mod 7),
                      y3 = 0 · (5 − 4) − 1 = 6 (mod 7).

Мы получили [2](5, 1) = (4, 6) (можно убедиться, что полученная
точка лежит на кривой, подставив ее координаты в уравнение (6.12)).
Найдем еще одну точку [3](5, 1) = (5, 1) + (4, 6). Используя (6.5),(6.7)
и (6.8), вычисляем
                      6−1  5
                k=        = =5·6=2              (mod 7),
                      4−5  6

                x3 = 22 − 5 − 4 = 2 (mod 7),
                y3 = 2 · (5 − 2) − 1 = 2 · 3 − 1 = 5      (mod 7).

Мы получили [3](5, 1) = (2, 5). Итак, мы нашли четыре точки. Для
криптографического использования кривой важно знать, сколько
6.2. Математические основы                                          105

всего точек в множестве E7 (2, 6). Ответ на этот вопрос мы дадим
в разд. 6.6.                                                   ⊔
                                                               ⊓
      Скажем несколько слов о свойствах множества точек Ep (a, b).
Совершенно очевидно, что это множество конечно, так как в него
входят только точки с целочисленными координатами 0 ≤ x, y < p.
Существует прямая аналогия между Ep (a, b) и множеством степеней
целых чисел, вычисляемых по модулю p . Так, Ep (a, b) имеет гене-
ратор, т.е. такую точку G , что ряд G, [2]G, [3]G, . . . , [n]G, где n =
#Ep (a, b), содержит все точки множества Ep (a, b), причем [n]G = O
(аналогично «действовал» параметр g в разд. 2.2). Число точек на
кривой, при надлежащем выборе параметров p , a и b , может быть
простым числом, #Ep (a, b) = q . В этом случае любая точка (кро-
ме O ) является генератором всего множества точек. Такая кривая
предпочтительна во многих отношениях и всегда может быть найде-
на за практически приемлемое время. Если по каким-то причинам
такую кривую найти не удалось и #Ep (a, b) = hq , где q — опять
простое число, то в Ep (a, b) существует подмножество из q точек
(т.е. мощности q ), генератором которого может служить любая точ-
ка G 6= O , такая, что [q]G = O . В дальнейшем, без потери общности,
мы будем считать, что работаем с таким подмножеством мощности
q (а при выборе кривой будем стремиться получить q = #Ep (a, b)).
      Основная криптографическая операция на эллиптической кри-
вой — m-кратная композиция, т.е. вычисление
                    Q = [m]P = P + P + · · · + P .                (6.13)
                               |     {z         }
                                         m

Эта операция выполняется очень эффективно и требует не более
2 log m композиций точек. Подходы к ее реализации абсолютно те
же, что и к возведению в степень. Например, чтобы получить точку
Q = [21]P , вычисляем [2]P , [4]P , [8]P , [16]P , каждый раз удваивая
предыдущую точку, и складываем P + [4]P + [16]P = Q (всего 4
удвоения и 2 сложения).
     Обратная задача, которая по традиции называется дискретным
логарифмированием на эллиптической кривой, формулируется сле-
дующим образом. Зная точки P и Q, найти такое число m , что
[m]P = Q. Эта задача оказывается очень трудной. Если тщательно
выбрать параметры кривой (как описывается в следующем разделе),
то наилучшие известные в настоящее время алгоритмы для нахож-
                     √
дения m требуют O( q) операций на кривой, где q — мощность
106            Глава 6. Криптосистемы на эллиптических кривых

подмножества точек, которому принадлежат точки P и Q. Все вы-
числения на кривой проводятся по модулю p , т.е. с числами длины
t ≈ log p бит. Для криптографических приложений log q ≈ log p ,
           √
поэтому O( q) = O(2t/2 ) означает экспоненциальный рост трудоем-
кости при увеличении длины чисел.


6.3.   Выбор параметров кривой
В этом разделе мы изложим основные рекомендации по выбору пара-
метров эллиптической кривой, предназначенной для решения крип-
тографических задач, а именно, по выбору коэффициентов a, b и мо-
дуля p . Фактически критерием выбора служит невозможность осу-
ществления определенного рода атак, предложенных для некоторых
классов кривых. Излагаемые ниже рекомендации следуют стратегии
выбора случайной кривой. Эта стратегия считается наиболее надеж-
ной с точки зрения обеспечения стойкости результирующей крип-
тосистемы. Альтернативный подход, не рассматриваемый нами, со-
стоит в систематическом конструировании кривой с заданными свой-
ствами, что обычно оказывается более эффективным с вычислитель-
ной точки зрения. Для реализации этого подхода предложены спе-
циальные методы, но получаемые кривые фактически выбираются
из относительно небольшого класса и вызывают подозрения на на-
личие некоторых специфических свойств, которые могут позволить
со временем изобрести алгоритмы для их взлома.
    Опишем по шагам процесс формирования хорошей случайной
кривой.

  1. Выбираем случайно простое число p . Как будет показано в
                                                          же
     разд. 6.6, количество точек на кривой — величина того      по-
     рядка, что и p . Поэтому битовая длина числа p , t = log p +1 ,
     должна быть такой, чтобы сделать невозможным применение
     общих методов нахождения логарифмов на кривой, имеющих
     трудоемкость O(2t/2 ). Величина t = 128 бит (четыре машин-
     ных слова на 32-битовых компьютерах) сегодня недостаточна,
     так как имеются сообщения о взломе соответствующих кри-
     вых за несколько месяцев интенсивных распределенных вы-
     числений. Но величина t = 160 бит (пять машинных слов) в
     настоящее время недосягаема для криптоаналитиков и может
     служить отправной точкой. Другое рассуждение основано на
6.3. Выбор параметров кривой                                  107

    том, что шифр на эллиптической кривой должен быть не менее
    стойким, чем блоковый шифр AES (см. разд. 8.2). Считается,
    что стойкость AES обеспечивается полной длиной его ключа,
    которая составляет 128, 196 или 256 бит. Так как стойкость
    шифра на эллиптической кривой определяется величиной t/2 ,
    длина модулей эллиптических кривых должна составлять со-
    ответственно 256, 392 и 512 бит.

  2. Выбираем случайные числа a и b , такие, что a, b 6= 0 (mod p)
     и 4a3 + 27b2 6= 0 (mod p). Обратим внимание на то, что при
     вычислении композиции точек параметр b нигде не фигуриру-
     ет. Поэтому для повышения эффективности счета иногда ре-
     комендуют случайно выбирать только b , а a принимать рав-
     ным небольшому целому числу. Так, стандарт США FIPS 186-2
     предполагает использование кривых с параметром a = −3, что,
     как мы увидим в разд. 6.5, немного упрощает вычисления.

  3. Определяем число точек на кривой n = #Ep (a, b) (это самый
     трудоемкий этап описываемого процесса, его базовый алгоритм
     будет рассмотрен в разд. 6.6). Важно, чтобы n имело большой
     простой делитель q , а лучше всего само было простым чис-
     лом, n = q . Если n разлагается на маленькие множители, то
     в Ep (a, b) существует много маленьких подмножеств со сво-
     ими генераторами, и алгоритм Полига–Хеллмана [28] быстро
     вычисляет логарифм на кривой через логарифмы в этих ма-
     леньких подмножествах. Если поиск кривой с n = q занимает
     слишком много времени, то можно допустить n = hq , где h
     — небольшое число. Еще раз подчеркнем, что стойкость крип-
     тосистемы на эллиптической кривой определяется не модулем
     p , а числом элементов q в подмножестве точек кривой. Но ес-
     ли множитель h — небольшое число, то q является величиной
     того же порядка, что и p . Если n не соответствует предъявля-
     емым требованиям, то необходимо вернуться к шагу 2.

  4. Проверяем, выполняются ли неравенства (pk − 1) mod q 6= 0
     для всех k , 0 < k < 32. Если нет, то возвращаемся к шагу
     2. Эта проверка предотвращает возможность MOV-атаки (на-
     званной по фамилиям ее авторов Menezes, Okamoto, Vanstone),
     а также исключает из рассмотрения так называемые суперсин-
     гулярные кривые и кривые с #Ep (a, b) = p − 1 (см. [20, 27]).
108             Глава 6. Криптосистемы на эллиптических кривых

       Метод MOV и указанные особые типы кривых позволяют све-
       сти задачу вычисления логарифма на кривой к более простым
       задачам.
  5. Проверяем, выполняется ли неравенство q =6 p . Если нет, то
     возвращаемся к шагу 2. Дело в том, что для кривых с q = p ,
     которые называются аномальными, предложены эффективные
     методы вычисления логарифмов (см. [20, 27]).
  6. На данном шаге подходящая для криптографических прило-
     жений кривая получена. Мы имеем параметры p , a, b , число
     точек n и размер подмножества точек q . Обычно еще требу-
     ется найти точку G — генератор этого подмножества. Если
     q = n , то любая точка (кроме O ) является генератором. Ес-
     ли q < n , то выбираем случайные точки G′ , пока не получим
     G = [n/q]G′ =6 O . Чтобы получить случайную точку на кривой,
     берем случайное число x < p, вычисляем e =√(x3 +ax+b) mod p
     и пытаемся извлечь квадратный корень y = e mod p . Если ко-
     рень существует, то получаем точку (x, y), в противном случае
     пробуем другое число x. Алгоритмы вычисления квадратных
     корней по модулю простого числа могут быть найдены, напри-
     мер, в [28, гл. 3].

6.4.    Построение криптосистем
Любая криптосистема, основанная на дискретном логарифмирова-
нии, легко может быть перенесена на эллиптические кривые. Основ-
ной принцип построения системы состоит в замене операции y =
g x mod p на Y = [x]G mod p (во втором случае указание модуля не
общепринято, хотя реально все вычисления на кривой проводятся по
модулю p ). Переход наиболее непосредствен, когда показатель степе-
ни x приводится по модулю q (как, например, в стандарте цифровой
подписи в разд. 4.3). На эллиптической кривой с мощностью рабо-
чего множества точек q то же самое происходит с множителем [x].
Отличие состоит в том, что y — это число, а Y — точка, и обыч-
но требуется переходить от точки к числу. Наиболее простой способ
такого перехода — использовать абсциссу точки.
     На эллиптических кривых можно построить и аналог системы
RSA. В этом случае кривая определяется по модулю n , где n — со-
ставное число. Однако здесь не получается выигрыша, так как длина
6.4. Построение криптосистем                                    109

модуля остается такой же, как в первоначальном варианте системы
RSA, чтобы было невозможно разложить n на простые множители.
    Мы продемонстрируем технику использования эллиптических
кривых на примере аналогов шифра Эль-Гамаля и цифровой под-
писи ГОСТ Р34.10-94.

Шифр Эль-Гамаля на эллиптической кривой
Для пользователей некоторой сети выбираются общая эллиптиче-
ская кривая Ep (a, b) и точка G на ней, такие, что G , [2]G, [3]G,
. . . , [q]G суть различные точки и [q]G = O для некоторого простого
числа q .
        Каждый пользователь U выбирает число cU , 0 < cU < q , ко-
торое хранит как свой секретный ключ, и вычисляет точку на кри-
вой DU = [cU ]G , которая будет его открытым ключом. Параметры
кривой и список открытых ключей передаются всем пользователям
сети.
        Допустим, пользователь A хочет передать сообщение пользова-
телю B . Будем считать, что сообщение представлено в виде числа
m < p . A делает следующее:

  1) выбирает случайное число k , 0 < k < q ;

  2) вычисляет R = [k]G , P = [k]DB = (x, y);

  3) шифрует e = mx mod p ;

  4) посылает B шифротекст (R, e).

      Пользователь B , после получения (R, e),

  1) вычисляет Q = [cB ]R = (x, y);

  2) дешифрует m′ = ex−1 mod p .

      Дадим обоснование протокола. Для этого достаточно показать,
что
               [cB ]R = [cB ]([k]G) = [k]([cB ]G) = [k]DB ,
т.е. Q = P . Поэтому m′ = m .
     Координата x точки Q остается секретной для противника, так
как он не знает числа k . Противник может попытаться вычислить k
110             Глава 6. Криптосистемы на эллиптических кривых

из точки R , но для этого ему нужно решить проблему дискретного
логарифмирования на кривой, что считается невозможным.
    Наиболее вероятным вариантом использования представленного
протокола будет передача в качестве числа m секретного ключа для
блокового или потокового шифра. В этом случае разумно выбирать
параметры кривой так, чтобы log q примерно вдвое превышал длину
ключа шифра.

Цифровая подпись по ГОСТ Р34.10-2001
Данный метод полностью аналогичен описанному ранее методу гене-
рации и проверки подписи ГОСТ Р34.10-94, но возведение в степень
заменяется операцией композиции на кривой [8]. Для сообщества
пользователей выбирается общая эллиптическая кривая Ep (a, b) и
точка G на ней, такая, что G , [2]G, [3]G, . . . , [q]G суть различные
точки, и [q]G = O для некоторого простого числа q (длина числа q
равна 256 бит).
    Каждый пользователь U выбирает случайное число xU (секрет-
ный ключ), 0 < xU < q , и вычисляет точку на кривой YU = [xU ]G
(открытый ключ). Параметры кривой и список открытых ключей
передаются всем пользователям.
    Чтобы подписать сообщение m̄, пользователь A делает следу-
ющее:
  1) вычисляет значение хеш-функции сообщения h = h(m̄);
  2) выбирает случайно число k , 0 < k < q ;
  3) вычисляет P = [k]G = (x, y);
  4) вычисляет r = x mod q (при r = 0 возвращается к шагу 2);
  5) вычисляет s = (kh + rxA ) mod q (при s = 0 возвращается к
     шагу 2);
  6) подписывает сообщение парой чисел (r, s).
    Для проверки подписанного сообщения (m̄; r, s) любой пользо-
ватель, знающий открытый ключ YA , делает следующее:
  1) вычисляет h = h(m̄);
  2) убеждается, что 0 < r, s < q ;
6.5. Эффективная реализация операций                         111

  3) вычисляет u1 = s · h−1 mod q и u2 = −r · h−1 mod q ;

  4) вычисляет композицию точек на кривой P = [u1 ]G + [u2 ]YA =
     (x, y) и, если P = O , отвергает подпись;

  5) если x mod q = r , принимает подпись, в противном случае от-
     вергает ее.

    Доказательство корректности протокола абсолютно аналогич-
но доказательству, приведенному в разд. 4.3.

6.5.   Эффективная реализация операций
В этом разделе мы рассмотрим основной подход, обычно необходи-
мый для эффективной реализации операций на эллиптической кри-
вой. Как уже говорилось, вычисление m-кратной композиции ( m —
большое число) осуществляется с помощью тех же методов, которые
используются для возведения в степень (умножение в них заменяет-
ся на сложение точек). Здесь для конкретности мы все же опишем
наиболее простой алгоритм — двоичный левосторонний метод (ср. с
алгоритмом 2.4). В литературе описаны более эффективные методы
возведения в степень, которые с успехом могут быть применены и
для вычисления композиций на эллиптических кривых. Эти методы
обычно дают несущественный выигрыш во времени (порядка 25%),
и их описание выходит за рамки нашей книги (см. описание этих
методов, например, в [28]).


Алгоритм 6.1. Вычисление m-кратной композиции
ВХОД:  Точка P , число m = (mt mt−1 . . . m1 )2 .
ВЫХОД: Q = [m]P .

(1)    Q ← O;
(2)    FOR i = t, t − 1, . . . , 1 DO
(3)       Q ← [2]Q,
(4)       IF mi = 1 THEN Q ← Q + P ;
(5)    RETURN Q.

    Данный алгоритм требует не более t сложений и t удвоений
точек (в среднем t удвоений и t/2 сложений).
112                 Глава 6. Криптосистемы на эллиптических кривых

    П р и м е р 6.2. Проиллюстрируем работу алгоритма на при-
мере вычисления [21]P . Здесь 21 = (10101)2 , t = 5. Покажем, что
происходит на каждой итерации цикла алгоритма.
      [i = 5   m5   = 1] :   Q ← O,               Q ← Q + P = P;
      [i = 4   m4   = 0] :   Q ← [2]Q = [2]P ;
      [i = 3   m3   = 1] :   Q ← [2]Q = [4]P,     Q ← Q + P = [5]P ;
      [i = 2   m2   = 0] :   Q ← [2]Q = [10]P ;
      [i = 1   m1   = 1] :   Q ← [2]Q = [20]P,    Q ← Q + P = [21]P.
                                                                       ⊔
                                                                       ⊓
   Напомним, что P3 = P1 +P2 , где P1 6= ±P2 (строка 4 алгоритма)
вычисляется с помощью формул
                     y 2 − y1
                 k=           ,
                     x2 − x1
                                                            (6.14)
                x3 = k 2 − x1 − x2 ,
                y3 = k(x1 − x3 ) − y1   (mod p).
Удвоение P3 = [2]P1 (строка 3 алгоритма) вычисляется с помощью
формул
                      3x2 + a
                  k= 1         ,
                         2y1
                                                          (6.15)
                 x3 = k 2 − 2x1 ,
                 y3 = k(x1 − x3 ) − y1 (mod p).
    Говорят, что при вычислениях по формулам (6.14) и (6.15) испо-
льзуется аффинное представление для точек, т.е. P = (x, y). Точка
в бесконечности O не имеет такого представления. Фактически в
алгоритме 6.1 она является просто «флажком», показывающим, что
нужно пропустить операции удвоения Q ← [2]Q до первого сложе-
ния Q ← Q + P , которое выполняется как простое присваивание
Q←P.
    Вычисления по формулам (6.14) и (6.15) были нами рассмотре-
ны в примере 6.1.
    Обозначим через M и I стоимость (время) умножения и ин-
версии по модулю p . Тогда из (6.14) и (6.15) следует, что при аф-
финном представлении стоимость сложения точек равна 1I + 3M ,
а стоимость удвоения равна 1I + 4M (операции сложения и умно-
жения на маленькие коэффициенты заметного влияния на время не
оказывают).
6.5. Эффективная реализация операций                           113

     Соотношение стоимости инверсии и умножения может быть раз-
личным в зависимости от реализации, но I всегда больше M . Если
умножение реализуется за счет сложений и сдвигов, то оно, вероят-
нее всего, будет незначительно (в 2—3 раза) опережать инверсию.
В этом случае использование аффинного представления для точек
на кривой вполне оправдано. Однако, если процессор, на котором
выполняются вычисления, имеет встроенный параллельный умно-
житель (как, например, Pentiumr ), то инверсия будет вычисляться
существенно медленнее произведения. Можно дать грубую оценку
стоимости соответствующих вычислений. Если t — длина чисел в
битах, то умножение потребует порядка (t/32)2 = t2 /1024 машинных
операций (32 бита — размер слова). С другой стороны, количество
итераций в обобщенном алгоритме Евклида, вычисляющем инвер-
сию, пропорционально t по своей природе. Даже если мы сможем
на каждой итерации реализовать линейные по t вычисления с помо-
щью 32-битовых машинных операций (что возможно), мы получим
общую трудоемкость порядка t(t/32) = t2 /32, т.е. одна инверсия бу-
дет соответствовать тридцати двум умножениям. В действительно-
сти на каждой итерации алгоритма Евклида нужно делать несколь-
ко операций, а умножение может быть реализовано более быстрыми
методами, так что I > 32M .
     Мы можем избавиться от инверсий на кажом шаге алгоритма
6.1, если будем работать с координатами в виде рациональных чи-
сел, производя вычисления отдельно с числителем и знаменателем.
Наиболее выгодной оказывается следующая замена переменных:
                             X            Y
                        x→      ,   y→       .               (6.16)
                             Z2           Z3
В этом случае точка на кривой представляется тройкой (X, Y, Z),
и говорят о переходе к взвешенному проективному представлению
(далее для простоты будем опускать слово «взвешенное»). Переход
от аффинной точки к проективной делается очень просто:

                         (x, y) → (x, y, 1).                 (6.17)

После этого все вычисления проводятся в проективных координатах
(без вычисления инверсий). Обратный переход от проективного к
аффинному представлению осуществляется следующим образом:

                    (X, Y, Z) → (X/Z 2 , Y /Z 3 ),           (6.18)
114                  Глава 6. Криптосистемы на эллиптических кривых

и стоит 1I+4M (одно вычисление инверсии Z −1 , два умножения для
получения Z −2 и Z −3 и, наконец, два умножения XZ −2 и Y Z −3 ).

    Получим формулы для сложения точек в проективном представ-
лении. Вначале в выражении (6.14) для x3 произведем замену пере-
менных в соответствии с (6.16). После приведения к общему знаме-
нателю и сокращения дроби получим


             X3   (Y2 Z13 − Y1 Z23 )2 − (X1 Z22 + X2 Z12 )(X2 Z12 − X1 Z22 )2
      x3 =    2 =                                                             .
             Z3                     Z12 Z22 (X2 Z12 − X1 Z22 )2
                                                                            (6.19)

Отсюда находим выражения для X3 и Z3 , взяв соответственно чис-
литель и квадратный корень из знаменателя правой части (6.19).
Чтобы получить выражение для Y3 , прибегнем к хитрости, позво-
ляющей в конечном итоге сэкономить одну операцию умножения.
Заметим, что P1 + P2 = P2 + P1 и


                       y 2 − y1                   y 2 − y1      
        y3 = (x1 − x3 )          − y1 + (x2 − x3 )          − y2    2.
                        x2 − x1                    x2 − x1


Произведем замену переменных по правилу (6.16), причем вместо Z3
используем его представление из (6.19). После приведения к общему
знаменателю, сокращения и приведения подобных членов получаем


                                                         
      Y3   (X1 Z22 + X2 Z12 )(X2 Z12 − X1 Z22 )2 − 2X3 (Y2 Z13 − Y1 Z23 )
  y3 = 3 =
      Z3                    2Z13 Z23 (X2 Z12 − X1 Z22 )3

                                      (Y1 Z23 + Y2 Z13 )(X2 Z12 − X1 Z22 )3
                                  −                                         . (6.20)
                                           2Z13 Z23 (X2 Z12 − X1 Z22 )3



    На основании выражений (6.19) и (6.20) запишем следующий
алгоритм.
6.5. Эффективная реализация операций                          115

Алгоритм 6.2. Сложение в проективном представлении
ВХОД:  P1 = (X1 , Y1 , Z1 ), P2 = (X2 , Y2 , Z2 ),
       P1 , P2 6= O , P1 6= ±P2
ВЫХОД: P3 = (X3 , Y3 , Z3 ) = P1 + P2
       (все вычисления выполняются по модулю p )

            λ1   = X1 Z22                        2M
            λ2   = X2 Z12                        2M
            λ3   = λ 2 − λ1
            λ4   = Y1 Z23                        2M
            λ5   = Y2 Z13                        2M
            λ6   = λ 5 − λ4
            λ7   = λ 1 + λ2
            λ8   = λ4 + λ5
            Z3   = Z1 Z2 λ3                      2M
            X3   = λ26 − λ7 λ23                  3M
            λ9   = λ7 λ23 − 2X3
            Y3   = (λ9 λ6 − λ8 λ33 )/2          3M
                                               16M

    Как видно из описания алгоритма, трудоемкость сложения в
проективных координатах равна 16M . Мы не учитываем простые
операции сложения, вычитания, а также умножения и деления на
2 (чтобы пояснить, как вычисляется v/2 mod p , заметим, что ес-
ли v четно, то v/2 mod p = v/2 (сдвиг вправо на один бит); если
v нечетно, то v/2 mod p = (v + p)/2 mod p , v + p четно, поэтому
v/2 mod p = (v + p)/2). Если одна из точек, скажем P2 , задана в
аффинных координатах, т.е. Z2 = 1 , то стоимость сложения сни-
жается до 11M . Это называется смешанным сложением. Алгоритм
6.1 построен таким образом, что он всегда использует смешанные
сложения, т.е. стоимость шага 4 алгоритма равна 11M .
    П р и м е р 6.3. Рассмотрим вычисление суммы (5, 1) + (4, 6) в
проективных координатах для кривой из примера 6.1 (все вычисле-
ния проводятся по модулю 7).
                     P1 = (5, 1, 1), P2 = (4, 6, 1).
                     λ1 = 5 · 1 = 5,
                     λ2 = 4 · 1 = 4,
                     λ3 = 4 − 5 = 6,
116              Глава 6. Криптосистемы на эллиптических кривых

         λ4 = 1 · 1 = 1,
         λ5 = 6 · 1 = 6,
         λ6 = 6 − 1 = 5,
         λ7 = 5 + 4 = 2,
         λ8 = 1 + 6 = 0,
         Z3 = 1 · 1 · 6 = 6,
         X3 = 52 − 2 · 62 = 2,
         λ9 = 2 · 62 − 2 · 2 = 2 − 4 = 5,
         Y3 = (5 · 5 − 0 · 63 )/2 = 25/2 = (25 + 7)/2 = 16 = 2;
         P3 = (2, 2, 6).

Для проверки переведем точку P3 в аффинное представление. Для
этого вычислим

              6−1 = 6,      6−2 = 6 · 6 = 1,     6−3 = 1 · 6 = 6.

В итоге получаем
                           P3 = (2 · 1, 2 · 6) = (2, 5),

что совпадает с результатом примера 6.1.                                ⊔
                                                                        ⊓
     Заметим, что условие P1 , P2 6= O эквивалентно Z1 , Z2 6= 0, а
условие P1 6= ±P2 эквивалентно X1 6= X2 . Если вычисления на кри-
вой проводятся, как это предполагалось нами, в подмножестве точек
мощности q , причем q — простое число, и m 6= 0 mod q , то условия
для сложения на шаге 4 алгоритма 6.1 автоматически выполняют-
ся (за исключением самого первого сложения, которое заменяется
присваиванием).
     Для удвоения точки в проективных координатах делаем замену
(6.16) в (6.15):

                           X3    (3X12 + aZ14 )2 − 8X1 Y12
                  x3 =         =                           ,        (6.21)
                           Z32          (2Z1 Y1 )2


              Y3   (4X1 Y12 − X3 )(3X12 + aZ14 )Z12 − 8Y14
       y3 =    3 =                                         ,        (6.22)
              Z3                 (2Z1 Y1 )3
что приводит к следующему алгоритму.
6.6. Определение количества точек на кривой                     117

Алгоритм 6.3. Удвоение в проективном представлении
ВХОД:   P1 = (X1 , Y1 , Z1 ), P1 6= O
ВЫХОД: P3 = (X3 , Y3 , Z3 ) = [2]P1

            λ1   = 3X12 + aZ14                4M
            λ2   = 4X1 Y12                    2M
            Z3   = 2Y1 Z1                     1M
            X3   = λ21 − 2λ2                  1M
            λ3   = 8Y14                       1M
            Y3   = λ1 (λ2 − X3 ) − λ3         1M
                                             10M

     Мы видим, что стоимость удвоения в проективных координатах
в общем случае равна 10M . Однако, если параметр кривой a = −3,
то λ1 = 3(X1 − Z12 )(X1 + Z12 ), и стоимость удвоения уменьшается до
8M .
     Отметим, что в вышеизложенных алгоритмах все вычисления
проводятся по модулю p . Поэтому многое зависит от эффектив-
ной реализации модульной арифметики. Для случайно выбранных
модулей наилучший на сегодняшний день подход — использование
для чисел представления Монтгомери (см., например, [28]). В пред-
ставлении Монтгомери умножение по модулю p эквивалентно двум
обычным умножениям.

6.6.   Определение количества точек на кривой
В этом разделе мы рассмотрим алгоритм Схоуфа (René Schoof, 1985)
для определения #Ep (a, b), т.е. количества точек, координаты ко-
торых удовлетворяют уравнению кривой (6.10) и являются неотри-
цательными целыми числами, меньшими p . Алгоритм Схоуфа был
первым полиномиальным алгоритмом подсчета количества точек на
эллиптической кривой, его трудоемкость составляет O(log6 p) опера-
ций по модулю p . Этот алгоритм лежит в основе всех современных
методов, применяемых для случайных кривых.
    Мы начнем с теоремы, доказанной Хассе (Helmut Hasse) еще в
1933 году.
    Теорема 6.1 (Хассе). #Ep (a, b) удовлетворяет неравенствам
                       √                          √
              p + 1 − 2 p ≤ #Ep (a, b) ≤ p + 1 + 2 p.
118               Глава 6. Криптосистемы на эллиптических кривых

      Оказывается удобным представлять #Ep (a, b) в виде

                           #Ep (a, b) = p + 1 − t.                (6.23)

    Параметр t в (6.23) может принимать как положительные, так
и отрицательные значения или быть равным нулю и называется сле-
дом Фробениуса для Ep (a, b). В соответствии с теоремой Хассе
                                   √
                            |t| ≤ 2 p.                      (6.24)

    До сих пор нас интересовали только точки на кривой с целочис-
ленными неотрицательными координатами, меньшими p . Но теперь
мы рассмотрим все множество решений уравнения кривой (6.10) в
комплексных числах. След Фробениуса замечательным образом свя-
зан с модулем p .
    Теорема 6.2. Для всех (комплексных чисел) x и y , удовле-
творяющих уравнению кривой (6.10) с параметрами 0 ≤ a, b < p,
справедливо равенство
                       2     2
                    (xp , y p ) + [p](x, y) = [t](xp , y p )      (6.25)

(сложение в формуле означает композицию точек на кривой).
    Чтобы научиться находить общее решение уравнения (6.25), за-
метим, что композиция точек вида Q = [m]P может быть выражена
через координаты точки P . Например,
                   2      2                               !
               ′   3x + a            ′  3x2 + a       ′
  [2](x, y) = x =             − 2x, y =         (x − x ) − y =
                      2y                  2y

  
      x4 − 2ax2 − 8bx + a2
                           ,
              4y 2
                                                                   
                      x6 + 5ax4 + 20bx3 − 5a2 x2 − 4abx − 8b2 − a3
                                                                     .
                                          8y 3
Точка [3](x, y) может быть получена как [2](x, y) + (x, y) путем под-
становки найденных выражений для координат точки [2](x, y) в фор-
мулы (6.5), (6.7), (6.8) (желающие могут это проделать). Процесс по-
лучения выражений для следующих точек кажется довольно слож-
ным, тем не менее он описывается следующей простой рекурсивной
6.6. Определение количества точек на кривой                             119

схемой.
          ψ0   = 0,
          ψ1   = 1,
          ψ2   = 2y,
          ψ3   = 3x4 + 6ax2 + 12bx − a2 ,
          ψ4   = 4y(x6 + 5ax4 + 20bx3 − 5a2 x2 − 4abx − 8b2 − a3 ),
                        3          3
     ψ2m+1     = ψm+2 ψm   − ψm−1 ψm+1 , m ≥ 2,
                         2            2
       ψ2m     = (ψm+2 ψm−1 − ψm−2 ψm+1   )ψm /2y, m > 2.

Для m ≥ 2 и P = (x, y)
           2                     2           2   
           ψm x − ψm−1 ψm+1 ψm+2 ψm−1 − ψm−2 ψm+1
   [m]P =           2
                           ,           3
                                                    .                 (6.26)
                  ψm                4yψm

    Полином ψm (x, y) называется полиномом деления порядка m.
Поскольку точка [m]P лежит на кривой, приводимой по модулю p ,
вычисление коэффициентов полиномов ψ достаточно также выпол-
нять по модулю p . С использованием приведенной выше рекурсив-
ной схемы полином деления порядка m может быть вычислен за
O(log m) шагов (читатель, не знакомый с арифметикой полиномов,
может обратиться к [9]). Заметим, что при нечетном m полиномы
ψm зависят только от одной переменной x, так как вторая перемен-
ная y входит в них только в четных степенях, а y 2 заменяется пра-
вой частью уравнения кривой (6.10). Заметим также, что полиномы
«второго слоя» ( ψ2m , ψ2m+1 ) включают в себя произведения четы-
рех полиномов «первого слоя» (от ψm−2 до ψm+2 ), поэтому степень
полинома ψm растет как O(m2 ).
    Комплексная точка P на кривой E называется торсионной точ-
кой порядка m , если [m]P = O . Множество торсионных точек по-
рядка m будем обозначать как E[m]. Вследствие (6.26) достаточно
очевидно, что точка P = (x, y) является торсионной порядка m то-
гда и только тогда, когда ψm (x, y) = 0.
    Идея алгоритма Схоуфа состоит в нахождении решений уравне-
ния (6.25) (относительно t ) на множествах торсионных точек малых
порядков с последующим вычислением общего решения. Для тор-
сионных точек порядка m множители приводятся по модулю m, а
полиномы — по модулю ψm , так что уравнение (6.25) принимает вид
                    2    2
                 (xp , y p )m + [pm ](x, y) = [tm ](xp , y p )m ,     (6.27)
120             Глава 6. Криптосистемы на эллиптических кривых

где pm = p mod m, tm = t mod m , (xk , y k )m = (xk mod ψm , y k mod
ψm ), кроме того, x и y связаны уравнением кривой y 2 = x3 + ax + b .
Возьмем в качестве модулей m простые числа вплоть до некоторого
mmax , такого, что          Y          √
                                  m > 4 p.                     (6.28)
                          m простое
                         2≤m≤mmax

Тогда по найденным числам tm мы однозначно восстановим след
Фробениуса t , удовлетворяющий (6.24), по китайской теореме об
остатках (см. [9, 28]).
     Рассмотрим кратко метод решения уравнения (6.27) для случая
m > 2 . Вначале вычисляем полином ψm . Так как m нечетно, то
ψm = ψm (x). (Далее все действия с полиномами производятся по
модулю ψm , степень y понижается до единицы с помощью уравне-
ния кривой, коэффициенты вычисляются по модулю p .) Вычисляем
                        2   2
полиномы xp , y p , xp , y p , используя тот же алгоритм возведения
в степень, что и для целых чисел. По формуле (6.26) вычисляем
Q = [pm ](x, y) и, используя формулы сложения на кривой, находим
                                                      2  2
в символическом виде композицию точек R = (xp , y p )m + Q. Если
R = O , то tm = 0. В противном случае, чтобы найти tm , вычисляем
абсциссу точки P = [τ ](xp , y p )m для всех τ , 0 < τ < m. Для каждо-
го значения τ нужно проверить равенство xR и xP . В общем случае
разность абсцисс представляется в виде xR − xP = u(x) − yv(x) = 0.
Берем отсюда y = u(x)/v(x), подставляем в уравнение кривой и
получаем некоторый полином hx (x) = 0. Если hx mod ψm 6= 0, то
xR и xP не равны, и нужно пробовать другое значение τ . Если же
xR = xP , вычисляем ординату точки P и, пользуясь аналогичными
приемами, переводим разность yR − yP в полином hy (x) = 0. Если
hy mod ψm = 0, то tm = τ , иначе tm = −τ mod m.
     Когда m = 2 , ψ2 = y и возникает затруднение с вычислением
xp mod y . Однако в этом случае помогает одно простое рассужде-
ние. Так как мы исключаем сингулярные кривые, то приведенная по
модулю p эллиптическая кривая может иметь одно или три пересе-
чения с осью x. Все другие точки идут парами (x, y), (x, −y), и есть
одна точка в бесконечности O . Таким образом, количество точек на
кривой четно или нечетно в зависимости от того, разлагается ли
X 3 + aX + b на множители по модулю p или нет. Известен простой
критерий неразложимости полинома по модулю p (см., например,
[28, 4]).
6.6. Определение количества точек на кривой                      121

    Теорема 6.3. Полином третьей степени F (X) неразложим
на множители по модулю p тогда и только тогда, когда

                      gcd(F (X), X p − X) = 1.


     В результате имеем t2 = 1 , если gcd(X 3 + aX + b, X p − X) = 1,
и t2 = 0 в противном случае.
    Оценим трудоемкость алгоритма Схоуфа. Вначале сформулиру-
ем следующее известное свойство простых чисел.

   Утверждение 6.4 (о простых числах). Количество про-
стых чисел, меньших n , примерно равно n/ ln n .

      (Точная формулировка и доказательство могут быть найдены в
[3].) Из утверждения 6.4 следует, что mmax = O(log p) и количество
модулей, для которых ведутся вычисления, равно O(log p). Наибо-
                                                         2
лее трудоемкая операция в алгоритме — вычисление xp и других
аналогичных полиномов. При использовании быстрых алгоритмов
возведения в степень эти вычисления требуют O(log p) операций ти-
па умножения с полиномами степени O(m2 ) = O(log2 p). Каждая
такая операция требует O(log4 p) операций типа умножения по мо-
дулю p , т.е. всего получается O(log5 p) операций по модулю p . Одна
операция по модулю p выполняется с помощью O(log2 p) битовых
                                            2
операций. Таким образом, вычисление xp требует O(log7 p) бито-
вых операций. Принимая во внимание число различных модулей,
                                   2
для которых нужно вычислять xp , получаем общую трудоемкость
       8
O(log p) битовых операций.

    П р и м е р 6.4. Определим количество точек на кривой, исполь-
зованной в примере 6.1 на стр.104:

            Y 2 = X 3 + 2X + 6 (mod 7) (a = 2, b = 6).


    Вначале воспользуемся алгоритмом, у которого время вычисле-
ний растет экспоненциально. Будем задавать значения X от 0 до
6 и вычислять соответствующие им значения Y . Запишем вначале
122             Глава 6. Криптосистемы на эллиптических кривых

таблицу квадратов по модулю 7:

                        02   =   0,
                        12   =   1,
                        22   =   4,
                        32   =   9 = 2,
                        42   =   2,
                        52   =   4,
                        62   =   1     (mod 7).

Используя эту таблицу, найдем множество точек E7 (2, 6):

        x = 0, y 2 = 6,                     y   не существует
        x = 1, y 2 = 1 + 2 + 6 = 9 = 2,     y   = 3 и y = −3 = 4,
        x = 2, y 2 = 8 + 4 + 6 = 4,         y   = 2 и y = −2 = 5,
        x = 3, y 2 = 27 + 6 + 6 = 4,        y   = 2 и y = −2 = 5,
        x = 4, y 2 = 64 + 8 + 6 = 1,        y   = 1 и y = −1 = 6,
        x = 5, y 2 = 125 + 10 + 6 = 1,      y   = 1 и y = −1 = 6,
        x = 6, y 2 = 216 + 12 + 6 = 3,      y   не существует .

Подсчитывая количество полученных точек и добавляя к ним точку
в бесконечности, получаем

                          #E7 (2, 6) = 11.

Ясно, что этот метод не годится при больших p , но мы будем ис-
пользовать полученное значение для проверки.
    Приступим к выполнению алгоритма Схоуфа. Нам достаточно√
будет трех модулей m = 2, 3, 5 , так как 2 · 3 · 5 = 30 > 4 7 = 10.58
(на самом деле двух модулей m = 3, 5 было бы достаточно, но мы
используем еще m = 2 для демонстрации алгоритма).
    В целях упрощения обозначений договоримся записывать поли-
номы в виде десятичных чисел (величина модуля позволяет нам это
сделать). Так, например,

            x4 + 5x2 + 2 = 1x4 + 0x3 + 5x2 + 0x + 2 = 10502,
            x4 + x = 1x4 + 0x3 + 0x2 + 1x + 0 = 10010.

Все вычисления с коэффициентами полиномов мы будем проводить
6.6. Определение количества точек на кривой                                    123

по модулю 7. Вначале вычислим необходимые полиномы деления:

       ψ0   =   0,
       ψ1   =   1,
       ψ2   =   2y,
       ψ3   =   30523,
       ψ4   =   4y · 1031115 = 4054446y,
       ψ5 = ψ4 ψ23 − ψ1 ψ33 = 4054446 · 10262 − 6025554626356
            = 5055036550230.

Решим уравнение (6.27) для m = 3. Вычисляем по модулю ψ3 :

                        x7    =   1363,
                        y7    =   (y 2 )3 y = 10263 y = 1360y,
                       x49    =   10 = x,
                       y 49   =   102624 y = 6y,
                        p3    =   7 mod 3 = 1.

Левая часть (6.27) превращается в

                              R = (x, 6y) + (x, y) = O.

Значит, t3 = 0 .
    Теперь решим уравнение (6.27) для m = 5 . Вычисляем по мо-
дулю ψ5 :
                      x7 = 10000000,
                      y 7 = 1064524266y,
                     x49 = 531353334500,
                     y 49 = 650465522521y,
                      p5 = 2.

Находим точку Q = [2](x, y). В общем случае это делается по фор-
муле (6.26):
                                                                    
                      4y 2 x − ψ3 ψ4                  10314 1031115y
            Q=                   , 4          =            ,               .
                          4y 2    4y                   4013 1045431
124              Глава 6. Криптосистемы на эллиптических кривых

Видим, что xQ 6= x49 , поэтому будем искать τ > 0. Найдем точку
R = (x49 , y 49 ) + Q по формулам (6.5), (6.7), (6.8):

           1031115y
                     − 650465522521y
       k = 1045431
              10314
                    − 531353334500
              4013
           (1031115 − 650465522521 · 1045431)4013y
         =
             1045431(10314 − 531353334500 · 4013

             541024434205y
         =                 ,
              115461562234

             5410244342052 y 2                  10314
      xR =                 2
                               − 531353334500 −
              115461562234                      4013

          552631612401
         =             ,
          533030166456
                                      
                          552631612401     541024434205y
      yR = 531353334500 −                ·               −
                          533030166456      115461562234

                               515441613166y
         − 650465522521y =                   .
                                115165441243

Пробуем τ = 1, P = (x7 , y 7 ). Проверяем гипотезу xR − xP = 0 :

             hx = 552631612401 − 533030166456 · 10000000
                = 61115566241 6= 0 mod ψ5 .

Пробуем τ = 2. Вычисляем P = [2](x7 , y 7 ). Здесь удобно исполь-
зовать формулы сложения точек, так как мы прибавляем (x7 , y 7 ) к
предыдущей точке P . Получаем

               3 · 100000002 + 2   434232361462
         k=                      =              ,
                2 · 1064524266y    2051341455y

               4342323614622                    213203662514
        xP =                   − 2 · 10000000 =              .
               20513414552 y 2                  220445441503
6.6. Определение количества точек на кривой                    125

Проверяем гипотезу xR − xP = 0:

  hx = 552631612401 · 220445441503 − 213203662514 · 533030166456
     = 0 mod ψ5 .

Значит, xR = xP . Теперь нужно сравнить yR и yP . Имеем
                                
                    213203662514     434232361462
  yP = 10000000 −                  ·              − 1064524266y
                    220445441503     2051341455y

          510334350655
     =                 .
         221015611231y
Проверяем гипотезу yR − yP = 0:

 hy = 515441613166y · 221015611231y − 510334350655 · 115165441243
    = 0 mod ψ5 .

Значит, t5 = 2.
    Наконец, определим t2 . Нам нужно найти наибольший общий
делитель для x3 + ax + b и xp − x. Сделаем это с помощью алго-
ритма Евклида для полиномов. Обратим внимание на то, что при
больших p , используемых в криптографии, мы не сможем непосред-
ственно записать полином xp − x. Однако на первом шаге алгоритма
Евклида вычисляется остаток (xp − x) mod (x3 + ax + b), поэтому до-
статочно подать на вход алгоритма не сам полином xp − x, а его
остаток. Вычисляем xp mod (x3 + ax + b) с помощью быстрых ме-
тодов возведения в степень и вычитаем x. После этого используем
алгоритм Евклида. В нашем примере

                               x7 = 304 mod 1026,
                                7
                          x − x = 364,
                   gcd(1026, 364) = 1.

Значит, t2 = 1 .
    Теперь используем китайскую теорему об остатках [9, 28]. Имеем

                            t   =   1 mod 2,
                            t   =   0 mod 3,
                            t   =   2 mod 5,
                           N    =   2 · 3 · 5 = 30.
126              Глава 6. Криптосистемы на эллиптических кривых

Решение t′ = t mod N находится по формуле
                                3
                                X
                         t′ =         ai Ni Mi mod N,
                                i=1

где
           a1 = 1,   N1 = 30/2 = 15,        M1 = 15−1 mod 2 = 1,
           a2 = 0,   N2 = 30/3 = 10,        M2 = 10−1 mod 3 = 1,
           a3 = 2,   N3 = 30/5 = 6,         M3 = 6−1 mod 5 = 1.
Подставляя числа, получаем

                 t′ = 1 · 15 · 1 + 0 · 10 · 1 + 2 · 6 · 1 = 27.

Чтобы получить решение, удовлетворяющее неравенству (6.24), вы-
читаем модуль:
                       t = t′ − N = −3.
      По формуле (6.23) находим

                     #E7 (2, 6) = 7 + 1 − (−3) = 11.               ⊔
                                                                   ⊓


    Как видим, определение числа точек на кривой — не слишком
простая задача. Ее решение требует использования мощной вычис-
лительной техники. На практике используются улучшенные вариан-
ты алгоритма Схоуфа, основанные на тонких конструкциях высшей
алгебры, главное достоинство которых состоит в снижении степени
полиномов деления с O(m2 ) до O(m). В результате трудоемкость
снижается до O(log6 p) и может быть снижена до O(log4+ǫ p) за счет
использования асимптотически более быстрых методов умножения
и деления (что обычно не оправдано при тех длинах чисел, которые
актуальны для криптосистем на эллиптических кривых).

6.7.    Использование стандартных кривых
Ввиду того, что формирование случайных кривых по рекомендаци-
ям разд. 6.3, особенно выполнение этапа подсчета количества точек
на кривой, может быть слишком трудной задачей, на практике часто
бывает достаточным использовать кривые, предлагаемые различны-
ми стандартами или другими источниками. Например, в американ-
ском стандарте FIPS 186-2 приводятся параметры эллиптических
6.7. Использование стандартных кривых                            127

кривых для различных длин модулей. Вообще говоря, нет никаких
ограничений на использование всеми одной хорошо выбранной кри-
вой. Однако такая кривая, при широком ее использовании, становит-
ся слишком притягательной для злоумышленников. Не исключено,
что со временем они смогут найти какие-либо эффективные атаки
именно на эту кривую, используя ее характерные особенности, не
принятые ранее во внимание. Но все это лишь возможность, веро-
ятность осуществления которой считается многими специалистами
ничтожно малой.
      Приведем пример реальной кривой, рекомендуемой в FIPS 186-2
(Curve P-256). Обратным слэшем \ обозначим продолжение числа на
следующей строке. Предполагается, что кривая задана уравнением
Y 2 = X 3 +aX +b mod p , число точек на кривой #Ep (a, b) = n , точка
G = (xG , yG ) является генератором подмножества точек мощности
q , где q — простое число.

    p = 2256 − 2224 + 2192 + 296 − 1
      = 115792 089210356 248762697 446949407 573530086\
        143415290 314195533 631308867 097853951
    a = −3
    b = 0x 5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0\
        cc53b0f6 3bce3c3e 27d2604b
    n = 115792 089210356 248762697 446949407 573529996\
        955224135 760342422 259061068 512044369
        (простое число)
    q=n
   xG = 0x 6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81\
        2deb33a0 f4a13945 d898c296
   yG = 0x 4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357\
        6b315ece cbb64068 37bf51f5

    Мы видим, что p и a вряд ли можно назвать случайно выбран-
ными числами и вся «случайность» кривой определяется случайным
выбором параметра b (это считается вполне обоснованным).
    Первый вопрос, который возникает, когда мы видим кривую,
подобную вышеприведенной, — это нет ли ошибки в записи пара-
метров. Три проверки могут быть сделаны для выяснения этого во-
проса.

  1. Проверяем, является ли число p простым.
128            Глава 6. Криптосистемы на эллиптических кривых

  2. Проверяем, удовлетворяет ли точка G = (xG , yG ) уравнению
     кривой.
  3. Удостоверяемся в том, что n — это действительно количество
     точек на кривой. Заметим, что такую проверку целесообразно
     делать и в том случае, когда мы сами вычисляем n , например,
     с помощью алгоритма Схоуфа. В общем случае n = hq , где h —
     небольшое число, а q — простое. Прежде всего путем последо-
     вательного деления и проверки на простоту следует убедиться,
     что n соответствует заявленной форме. Затем выбираем слу-
     чайно точку на кривой P (можно взять P = [k]G , где k —
     случайно выбранное число). Число n гарантированно являет-
     ся числом точек на кривой, если одновременно [n]P = O и
     [h]P 6= O . При невыполении этого условия возможны два ва-
     рианта. Если [n]P 6= O , то n — это не число точек. Если же
     [h]P = O (вероятность этого крайне мала), то нужно взять
     другую точку P .
В дополнение к указанным проверкам можно проверить выполнение
всех других требований, изложенных в разд. 6.3.
    Второй вопрос, который возникает, когда нам предъявляют «го-
товую» кривую, это действительно ли она была сгенерирована слу-
чайным образом. Этот вопрос вообще актуален для многих задач
криптографии. Возможно, предложенная кривая обладает каким-
либо редким свойством, позволяющим «взламывать» криптосисте-
му, и человек, изготовивший эту кривую, может в дальнейшем по-
лучить доступ, скажем, к информации, зашифрованной при помощи
этой кривой. Задача доказательства отсутствия заранее заданных
специальных свойств кривой сводится к задаче подобного же дока-
зательства для случайно выбираемых параметров. Например, для
рекомендованной выше кривой мы должны доказать случайность
выбора параметра b . Эту задачу можно решить следующим обра-
зом. Пусть h(x) — криптографически стойкая хеш-функция. Чтобы
сгенерировать число b , вначале выбираем число s, а затем вычис-
ляем b = h(s) и предъявляем оба числа b и s. Если хеш-функция
удовлетворяет всем требованиям стойкости, то b не может иметь
никаких заранее заданных свойств и мы можем спокойно им поль-
зоваться. Число s является «сертификатом», доказывающим «чи-
стоту» числа b . Приведенная выше эллиптическая кривая имеет по-
добный сертификат, основанный на хеш-функции SHA-1 [23], и стан-
Задачи и упражнения                                            129

дарт оговаривает процедуру использования этого сертификата. Так
что мы можем быть уверены в том, что кривая была сформирована
действительно случайным образом.


Задачи и упражнения

 6.1. Эллиптическая кривая задана параметрами p = 11, a = 4,
      b = 7. Определить, принадлежат ли кривой следующие точки:
      (1,1), (1,2), (2,1), (2,2), (5,8).

 6.2. Для эллиптической кривой с параметрами p = 7 , a = 2 , b =
      6 вычислить следующие композиции точек: [2](2, 2), [2](4, 6),
      (1, 3) + (1, 4), (2, 2) + (3, 2), (3, 5) + (5, 1).


Темы лабораторных работ

      В лабораторных работах рекомендуется использовать эллип-
      тическую кривую со следующими параметрами:

                p = 31991,   a = −3 = 31988,   b = 1000.

      Количество точек на этой кривой

                      n = 32089 (простое число).

      В качестве генератора можно взять точку

                             G = (0, 5585).

      Точку в бесконечности O удобно представлять как точку с
      координатами (0,0).

6.3. Написать набор подпрограмм для вычисления композиции и
     m-кратной композиции точек на эллиптической кривой. При-
     ведем несколько тождеств для тестирования разработанных
130           Глава 6. Криптосистемы на эллиптических кривых

      подпрограмм:

               (51, 7858) + (91, 5500) = (7252, 18353),
               (7777, 10935) + (16000, 20400) = (12395, 26268),
               (12405, 28624) + (2963, 16300) = (14905, 2313),
               (8020, 1740) + (8020, 30251) = O,

               [2](0, 5585) = (8, 19435),
               [2](23161, 17992) = (26775, 10831),
               [2](110, 13171) = (26948, 16087),

               [10000](31122, 9) = (31180, 29596),
               [12345](13140, 5033) = (9362, 27046),
               [11111](11007, 23704) = (850, 6718).

6.4. Выполнить программную реализацию шифра Эль-Гамаля на
     эллиптической кривой. При отладке и тестировании програм-
     мы можно воспользоваться следующим примером построения
     шифра:

                  c = 5103, D = (12507, 2027);
                  m = 10000, k = 523;
                  R = (9767, 11500), P = (25482, 16638);
                  e = 11685.

      Полученный шифротекст ((9767,11500),11685) должен дешиф-
      роваться в сообщение 10000 при помощи секретного ключа
      5103.
6.5. Выполнить программную реализацию алгоритмов генерации
     и проверки цифровой подписи на эллиптической кривой (как
     обычно, полагаем h(m) = m). В качестве q берем n = 32089
     (число точек на кривой). Подписанное сообщение

                            (1000; 4615, 5944)

      должно признаваться подлинным для пользователя, имеюще-
      го открытый ключ Y = (12224, 7207).
Глава 7.    ТЕОРЕТИЧЕСКАЯ СТОЙКОСТЬ
            КРИПТОСИСТЕМ




7.1.   Введение

По-видимому, одна из первых открытых работ по криптографии по-
явилась в 1949 году и принадлежала Шеннону (Claude Shannon,
см. [19]). В ней рассматривается классическая схема криптосисте-
мы с секретным ключом, которая была представлена на рис. 1.1
(стр. 7).
    В этой схеме имеется защищенный канал, предназначенный для
передачи секретных ключей. Однако отметим, что в настоящее вре-
мя можно рассмотреть в качестве защищенного канала схему вы-
числения секретного ключа на основе методов криптографии с от-
крытым ключом, например, схему Диффи–Хеллмана или протокол
Нидхама–Шредера. В дальнейшем мы будем рассматривать толь-
ко классическую схему с секретным ключом, но многие результаты
переносятся на случай создания секретного канала средствами крип-
тографии с открытым ключом.
    Все методы шифрования можно грубо разделить на два больших
класса:

  1) схемы, принципиально не вскрываемые, что доказывается
     строго;

  2) схемы, стойкость которых основана на том, что дешифрование
     без ключа, вообще говоря, возможно, но для этого требуется
     перебор очень большого количества вариантов.

    В этой главе мы будем заниматься системами первого типа,
стойкость которых теоретически доказана. Системы второго типа
будут рассмотрены в следующей главе.
132                 Глава 7. Теоретическая стойкость криптосистем

7.2.   Теория систем с совершенной секретностью
Пусть M = {M1 , M2 , M3 , . . . , Mm } — множество всех возможных
сообщений (например, множество всех текстов длины не более, чем
1000 букв), K = {K1 , K2 , K3 , . . . , Kn } — множество всех возможных
ключей, E = {E1 , E2 , . . . , Ek } — множество всех криптограмм (т.е.
зашифрованных сообщений). Зашифрованные сообщения зависят от
исходного сообщения и ключа, т.е. Ej = f (Mi , Kl ).
    Мы будем считать, что на всем множестве сообщений M задано
распределение вероятностей P , т.е. определены вероятности P (Mi ),
i = 1, 2, . . . , m. Это априорное распределение вероятностей, которое
известно и противнику. Запись вида P (A|B) будет, как обычно, обо-
значать условную вероятность события A при условии наступления
события B .
   Определение 7.1. Криптосистема называется совершенно сек-
ретной, если выполняется равенство
                         P (Mi |Ej ) = P (Mi )                    (7.1)
при всех Mi , Kl и Ej = f (Mi , Kl ).
     Поясним это определение. Пусть Ева перехватила криптограмму
Ej . Если (7.1) выполняется для всех возможных сообщений, то это
означает, что она не получила никакой информации о переданном
сообщении, т.е. знание Ej совершенно бесполезно для нее. Рассмот-
рим схематичный пример. Пусть M — множество всех сообщений
из шести букв на русском языке . Пусть априори известно, что для
некоторой системы
              P (сообщение = «доллар») = 0.00015,
              P (сообщение = «бутыль») = 0.0000012 и т.д.
Допустим, мы имеем несовершенную систему, и Ева после перехвата
и вычислений получила следующие данные:
                   P (сообщение = «доллар») = 10−20 ,
                   P (сообщение = «бутыль») = 0.9999.
Это означает, что Ева практически расшифровала сообщение: она
практически уверена, что передано слово «бутыль», так как вероят-
ность, что передано другое сообщение меньше 0.0001.
7.2. Теория систем с совершенной секретностью                        133

    Если же для рассмотренной системы при любой перехваченной
криптограмме Ej мы получаем

                  P (сообщение = «доллар»|Ej ) = 0.00015,
                  P (сообщение = «бутыль»|Ej ) = 0.0000012

и такие же равенства выполняются для всех остальных сообщений,
то Ева вообще может не обращать внимание на перехваченный шиф-
ротекст Ej , а, например, отгадывать сообщение на основе исход-
ных вероятностей. Другими словами, (7.1) — действительно разум-
ное определение совершенно секретной системы.
    Исследуем свойства совершенно секретной системы.

    Теорема 7.1. Если система является совершенно секретной
(выполняется (7.1)), то справедливо равенство

                            P (Ej |Mi ) = P (Ej )                   (7.2)

при всех i и j . Верно и обратное утверждение: если (7.2) выпол-
няется, то система совершенно секретна.

       Д о к а з а т е л ь с т в о . По определению условной вероятности

                                          P (AB)
                            P (A|B) =            ,
                                           P (B)

при P (B) 6= 0 (см., например, [17]). Поэтому при P (Ej ) 6= 0 можно
записать
                            P (Mi Ej )   P (Mi )P (Ej |Mi )
              P (Mi |Ej ) =            =                    .
                             P (Ej )         P (Ej )
Принимая во внимание (7.1), получаем

                                    P (Mi |Ej )P (Ej |Mi )
                    P (Mi |Ej ) =                          ,
                                           P (Ej )
т.е.
                              P (Ej |Mi )
                                          = 1.
                                P (Ej )
Таким образом, (7.2) доказано. Обратное утверждение теоремы до-
казывается «обратным ходом» приведенных равенств, см. [19].  ⊔
                                                             ⊓
134                   Глава 7. Теоретическая стойкость криптосистем

7.3.     Шифр Вернама
Этот шифр был предложен в 1926 году американским инженером
Вернамом (Gilbert Vernam) и использовался на практике, но дока-
зательство его невскрываемости было получено значительно позже
Шенноном [19]. Для шифра Вернама часто используется название
«одноразовая лента» (one-time pad). Мы опишем этот шифр для слу-
чая двоичного алфавита, чтобы упростить обозначения.
     Пусть множество сообщений M состоит из слов двоичного ал-
фавита длины n , т.е. всего сообщений не более, чем 2n . В шифре
Вернама множество ключей также состоит из слов той же длины n
и каждый ключ используется с вероятностью 1/2n . Другими слова-
ми, все ключи используются с одинаковой вероятностью.
     Пусть необходимо зашифровать сообщение m̄ = m1 m2 . . . mn и
пусть выбран ключ k̄ = k1 k2 . . . kn . Тогда зашифрованное сообщение
ē = e1 e2 . . . en получается по формуле:
                               ei = mi ⊕ ki ,                           (7.3)
где i = 1, 2, . . . , n и ⊕ обозначает сложение по модулю 2. Другими
словами, сообщение шифруется по схеме
                          m1    m2      ...     mn
                      ⊕
                          k1    k2      ...     kn
                                                     .
                          e1    e2      ...     en
    Так как сложение и вычитание по модулю 2 совпадают, то легко
видеть, что дешифрование осуществляется по формуле
                               mi = ei ⊕ ki .                           (7.4)
     П р и м е р 7.1. Пусть m̄ = 01001, k̄ = 11010. Тогда получаем
ē = 10011 . Сложив ē с k̄ , восстанавливаем m̄.                ⊔
                                                                 ⊓
    Теорема 7.2. Шифр Вернама является совершенно секретной
криптосистемой.
    Д о к а з а т е л ь с т в о . Согласно теореме 7.1 достаточно дока-
зать справедливость (7.2). Имеем
       P (Ej |Mi ) = P (en |mn ) =
          = P (k1 = e1 ⊕ m1 ; k2 = e2 ⊕ m2 ; . . . ; kn = en ⊕ mn ) =
          = P (ключ = k1 ...kn ) = 2−n
7.4. Элементы теории информации                               135

(в последнем равенстве мы использовали то, что, по предположению,
все ключи равновероятны).
     Найдем P (Ej ). По формуле полной вероятности
                                n
                               2
                               X
                   P (Ej ) =         P (Mi )P (Ej |Mi ).
                               i=1

Учитывая, что P (Ej |Mi ) = 2−n , получаем
                                           n
                                          2
                                          X
                                     −n
                      P (Ej ) = 2               P (Mi ).
                                          i=1

Так как сумма вероятностей всех возможных сообщений равна 1,
получаем
                        P (Ej ) = 2−n .
Таким образом, справедливо (7.2). Теорема доказана.             ⊔
                                                                ⊓
     Известно, что шифр Вернама использовался при защите пра-
вительственной связи: например, на так называемой горячей линии
«Москва – Вашингтон» [28], а также в других системах, где мож-
но позволить дорогой способ доставки секретного ключа. Однако
шифр Вернама можно использовать во многих других практически
важных ситуациях. Например, на основе этого шифра легко органи-
зовать связь между банком и его филиалами (или связи между бан-
ком и клиентами), когда они находятся в одном городе, или защитить
электронные письма, скажем, для студентов Алисы и Боба, расста-
ющихся на каникулы (мы предлагаем читателю придумать схему и
написать программу, считая, что общая длина писем, которыми они
будут обмениваться во время каникул, не превосходит 1.44 Мбайт,
т.е. объема стандартной дискеты).


7.4.   Элементы теории информации
Мы доказали, что шифр Вернама совершенен, однако при его ис-
пользовании длина ключа равна длине сообщения. К. Шеннон [19]
показал, что у любой совершенной системы длина ключа должна
быть больше энтропии сообщения (с которой мы кратко познакомим-
ся ниже), т.е. пропорциональна его длине. Во многих практически
136                    Глава 7. Теоретическая стойкость криптосистем

важных ситуациях приходится использовать короткие ключи (ска-
жем, сотни или тысячи бит) для шифрования длинных сообщений
(сотни килобайт и более). В этом случае можно построить только
так называемые идеальные системы, впервые описанные Шенноном.
Для построения идеальных систем и исследования их свойств Шен-
нон предложил использовать понятия теории информации. В этом
разделе мы определим и кратко проиллюстрируем эти понятия. До-
статочно полное и строгое их изложение может быть найдено, на-
пример, в [4].
    Начнем с определения основного понятия — энтропии Шеннона.
Пусть дана дискретная случайная величина ξ , принимающая значе-
ния a1 , a2 , · · · ar с вероятностями P1 , P2 , · · · , Pr .

    Определение 7.2. Энтропия случайной величины ξ определя-
ется равенством
                            r
                            X
                   H(ξ) = −    Pi log Pi ,              (7.5)
                                      i=1

где 0 log 0 = 0.

    Если используется двоичный логарифм, то энтропия измеряется
в битах, что общепринято в криптографии, теории информации и в
компьютерных науках. В случае натуральных логарифмов единица
измерения — нат, в случае десятичных — дит.
    При r = 2 можно (7.5) записать иначе, введя следующие обо-
значения: P1 = p , P2 = 1 − p . Тогда

                   H = − (p log p + (1 − p) log (1 − p)) .          (7.6)

График энтропии для этого случая приведен на рис. 7.1.
   Рассмотрим простейшие свойства энтропии.

      Утверждение 7.3.

  1) H (ξ) ≥ 0 ;

  2) H (ξ) ≤ log r ;

  3) H (ξ) = log r при Pi = 1/r , i = 1, 2, . . . , r .

     Д о к а з а т е л ь с т в о . Первое свойство довольно очевидно (см.
(7.5)). Второе свойство докажем только для случая r = 2, так как
7.4. Элементы теории информации                                    137


                      H(p)


                     1




                                                   p
                     0           1/2           1


                 Рис. 7.1. График двоичной энтропии



общий случай аналогичен. Исследуем график энтропии. Нужно най-
ти максимум функции (7.6). Для этого мы найдем первую и вторую
производные H(p), считая, что логарифм натуральный.
                                           
                         1              1−p
   H ′ (p) = − ln p + p · − ln(1 − p) −       = − ln p + ln(1 − p).
                         p              1−p
    Отсюда H ′ (p) = 0 при p = 1/2 . Найдем вторую производную
                                     1  1
                         H ′′ (p) = − −    .
                                     p 1−p
Мы видим, что H ′′ (p) < 0 при p ∈ (0; 1) . Это означает, что функция
H(p) достигает максимума в точке 1/2 и выпукла на отрезке (0; 1).
Таким образом, график, изображенный на рис. 7.1, обоснован. Оче-
видно, при любом основании логарифма график будет аналогичный.
    Для доказательства третьего свойства заметим, что наибольшее
значение энтропии для r = 2 равно
    max H(p) = H(1/2) = − ((1/2) log(1/2) + (1/2) log(1/2)) = 1,
т.е. составляет один бит в случае двоичного логарифма.              ⊔
                                                                    ⊓
     «Физический» смысл энтропии состоит в том, что энтропия —
это количественная мера неопределенности. В качестве примера рас-
смотрим три случайные величины для r = 2. Иными словами, будем
138                 Глава 7. Теоретическая стойкость криптосистем

считать, что у нас есть три источника сообщений, которые порожда-
ют буквы a1 , a2 , т.е. имеются три случайные величины ξi , i = 1, 2, 3,
принимающие значения a1 или a2 :

                  ξ1 : P (a1 ) = 1,    P (a2 ) = 0;
                  ξ2 : P (a1 ) = 0.5,  P (a2 ) = 0.5;
                  ξ3 : P (a1 ) = 0.01, P (a2 ) = 0.99.

Интуитивно ясно, что неопределенность случайной величины ξ1 рав-
на нулю. И действительно,

                  H(ξ1 ) = −(1 · log 1 + 0 · log 0) = 0.

Посмотрим на ξ2 и ξ3 . Интуитивно кажется, что неопределенность
у ξ2 выше неопределенности у ξ3 . Вычислим энтропии:

                             H (ξ2 ) = 1 бит

(уже считали выше),

        H (ξ3 ) = − (0.01 · log 0.01 + 0.99 · log 0.99) ≈ 0.08 бит.

     Мы видим, что энтропия действительно является разумной ме-
рой неопределенности. Но главное, конечно, не примеры такого ти-
па, а то, что эта величина играет ключевую роль во многих задачах
теории передачи и хранения информации. В частности, энтропия
характеризует максимальную степень сжатия данных. Точнее, если
источник сообщений порождает текст достаточно большой длины n
с определенной ниже предельной энтропией h на бит сообщения, то
этот текст может быть «сжат» в среднем до величины сколь угодно
близкой к nh . Например, если h = 1/2 , то текст сжимается вдвое
и т.п.. Подчеркнем, что речь идет о так называемом неискажающем
сжатии, когда по «сжатому» сообщению можно восстановить исход-
ное.
     Рассмотрим теперь двумерную случайную величину, заданную
рядом распределения

          Pij = P (ξ1 = ai , ξ2 = bj ) ,   1 ≤ i ≤ r, 1 ≤ j ≤ s.      (7.7)

    П р и м е р 7.2. Из многолетнего опыта преподавания в некото-
ром вузе известно, что оценки за первый и второй контрольный срок
7.4. Элементы теории информации                                           139


              Т а б л и ц а 7.1. Распределение оценок
                                 за контрольный срок
               ξ1 ↓ ξ2 →      0                1                  2
               0             0.20             0.05                0
               1             0.05             0.30               0.05
               2              0               0.05               0.30


по математике (соответственно ξ1 и ξ2 ) подчиняются закону распре-
деления, задаваемому табл. 7.1.                                 ⊔
                                                                ⊓
    Введем следующие обозначения:
                                                    s
                                                    P
                     Pi· = P (ξ1 = ai ) =                Pij ,
                                                   j=1
                                                   Pr
                     P·j = P (ξ2 = bj ) =                Pij .
                                                   i=1

    Напомним некоторые элементарные соотношения, известные из
теории вероятностей (см. [17]):

                                          P (AB)
                           P (A|B) =             ,                       (7.8)
                                           P (B)

             P (AB) = P (A) P (B|A) = P (B) P (A|B) ,                    (7.9)
                           X
                   P (A) =     P (Hi ) P (A|Hi )                        (7.10)
                                  i

((7.10) — уже встречавшаяся формула полной вероятности, в кото-
рой Hi — попарно несовместные события, сумма которых содержит
событие A ).
     В соответствии с (7.5) определим энтропию двумерной случай-
ной величины
                                    s
                                  r X
                                  X
                  H(ξ1 , ξ2 ) = −      Pij log Pij .       (7.11)
                                      i=1 j=1

Аналогично для трехмерной случайной величины (ξ1 , ξ2 , ξ3 ) и рас-
пределения вероятностей Pijk определим
                                  XXX
             H(ξ1 , ξ2 , ξ3 ) = −      Pijk log Pijk .       (7.12)
                                      i   j     k
140                     Глава 7. Теоретическая стойкость криптосистем

Подобным же образом определяется энтропия для n -мерной случай-
ной величины.
    Представим теперь, что значение случайной величины ξ1 из-
вестно, а ξ2 — неизвестно. Тогда естественно определить условную
энтропию
                                r       s
                               X       X  Pij     Pij
                H(ξ2 |ξ1 ) = −     Pi·        log     .     (7.13)
                               i=1
                                          P
                                       j=1 i·
                                                  Pi·
Это — средняя условная энтропия случайной величины ξ2 при усло-
вии, что значение ξ1 известно.
      Утверждение 7.4 (свойство двумерной энтропии).
                        H(ξ1 , ξ2 ) = H (ξ1 ) + H (ξ2 |ξ1 ) ,                   (7.14)
в частности, для независимых случайных величин ξ1 и ξ2
                             H(ξ2 |ξ1 ) = H (ξ2 ) ,
                             H(ξ1 , ξ2 ) = H (ξ1 ) + H (ξ2 ) .                  (7.15)
     Напомним, что ξ1 , ξ2 независимы, если Pij = Pi Pj для всех i
и j . Доказательство утверждения достаточно просто и может быть
найдено в [4]. Мы ограничимся только его интерпретацией. Пусть в
первом опыте порождается ξ2 , во втором — ξ1 . Тогда общая неопре-
деленность экперимента должна быть равна неопределенности пер-
вого опыта, сложенной с условной неопределенностью второго опы-
та. В случае независимых ξ1 и ξ2 знание одной величины не несет
никакой информации о другой, что соответствует (7.15).
     Пусть дана n -мерная случайная величина (ξ1 , ξ2 , . . . , ξn ). Спра-
ведливо следующее соотношение [4]:
H(ξ1 , . . . , ξn ) = H(ξ1 )+H(ξ2 |ξ1 )+H(ξ3 |ξ1 , ξ2 )+. . .+H(ξn |ξ1 , . . . , ξn−1 ).
                                                                                 (7.16)
Для независимых случайных величин
                                                    n
                                                    X
                            H(ξ1 , . . . , ξn ) =         H(ξi )                (7.17)
                                                    i=1

(заметим, что (7.14), (7.15) — частный случай (7.16), (7.17)).
    В общем случае
                          H(ξk |ξ1 , . . . , ξk−1 ) ≤ H (ξk ) .                 (7.18)
7.4. Элементы теории информации                                       141

      Рассмотрим последовательность случайных величин ξ1 , ξ2 , ξ3 , . . .
(ξi принимают значения в A), которую можно рассматривать как
случайный процесс с дискретным временем. Мы будем считать, что
этот процесс стационарный, т.е., неформально, вероятностные харак-
теристики для (ξ1 . . . ξn ) те же, что и для (ξ∆+1 . . . ξ∆+n ) при всех
положительных n и ∆ (точное определение дано в [4]).
      Пусть H(ξ1 , . . . , ξn ) — энтропия n -мерной случайной величины
(ξ1 . . . ξn ). Обозначим через

                                 1
                         h+
                          n =      H (ξ1 , . . . , ξn )
                                 n
удельную энтропию n -го порядка и определим

                       h−
                        n = H (ξn |ξ1 , . . . , ξn−1 ) .

    Отметим следующие свойства:
                                   +
                             h+
                              n ≤ hn−1 ,        n > 1,             (7.19)
                             h−    +
                              n ≤ hn ,                             (7.20)
                                   −
                             h−
                              n ≤ hn−1 ,        n > 1.             (7.21)

Их доказательство может быть найдено в [4].
    Для независимых ξ1 , ξ2 , . . . , ξn справедливы равенства

                              h+    −
                               n = hn = h.

(Процесс, порождающий независимые случайные величины, называ-
ется процессом без памяти.)

    Теорема 7.5. Для стационарного процесса существуют пре-
делы limn→∞ h+           −
             n и limn→∞ hn , причем эти пределы равны.

    Доказательство теоремы см. в [4].
    Обозначим общее значение этих пределов через h∞ ,

                       h∞ = lim h+        −
                                 n = lim hn .                      (7.22)
                              n→∞            n→∞

    Пусть дан алфавит A = (a1 , a2 , . . . ar ). Мы знаем, что

                           max H (ξ1 ) = log r
142                Глава 7. Теоретическая стойкость криптосистем

для процесса без памяти, поэтому, принимая во внимание (7.21) и
(7.22), получаем max h∞ = log r , причем максимум достигается для
процессов без памяти, у которых все буквы порождаются с равными
вероятностями 1/r . Естественно ввести величину

                           R = log r − h∞ ,                     (7.23)

называемую избыточностью (на букву сообщения). Неформально,
это как бы неиспользованная часть алфавита. Избыточность —
количественная мера взаимной зависимости символов и их «нерав-
новероятности». Отметим, что в примере из первой главы во втором
случае, когда даже простой шифр Цезаря не вскрываем, избыточ-
ность шифруемого сообщения равна нулю, так как все десять сим-
волов независимы и равновероятны, т.е. h∞ = log 10 и R = 0 .

7.5.   Расстояние единственности шифра с
       секретным ключом
Рассмотрим криптосистему с секретным ключом, схема которой по-
казана на рис. 1.1 (стр. 7). Пусть источник порождает сообщение
m̄ = m1 m2 . . . mn . Например, mi при каждом i — это буква из рус-
ского алфавита или знак пробела, а m̄ — сообщение на русском язы-
ке. Алиса и Боб обладают секретным ключом k , известным только
им, и пусть ē = e1 e2 . . . en — сообщение, зашифрованное при помощи
этого ключа.
      П р и м е р 7.3. Пусть источник порождает буквы из алфавита
A = {a, b, c} с вероятностями P (a) = 0.8, P (b) = 0.15, P (c) = 0.05,
и пусть это источник без памяти. Пусть шифратор, применяя ключ
k , заменяет буквы в исходном сообщении, используя какую-либо пе-
рестановку символов:

                           (a, b, c)   k   =1
                           (a, c, b)   k   =2
                           (b, a, c)   k   =3
                           (b, c, a)   k   =4
                           (c, a, b)   k   =5
                           (c, b, a)   k   = 6,

т.е. ключ принимает значения от 1 до 6, и если, например, k = 5,
7.5. Расстояние единственности шифра с секретным ключом                 143

то в исходном тексте осуществляется следующая замена символов:
a → c, b → a, c → b .
    Пусть Ева перехватила зашифрованное сообщение

                                 ē = cccbc

и хочет определить значение ключа. Оценим количественно вероят-
ности использования всех возможных ключей, используя формулу
Байеса
                               P (Ki )P (E|Ki )
                P (Ki |E) = Pt                     ,
                              j=1 P (Kj )P (E|Kj )

где E , K1 , . . . ,PKt — некоторые события, причем Ki попарно несов-
                      t
местны и E ⊂ i=1 Ki . В нашем случае событие E — это получение
зашифрованного сообщения ē = cccbc, t = 6, а Ki означает, что вы-
бран ключ k = i.
    Мы предполагаем, что все ключи равновероятны, т.е.

   P (K1 ) = P (K2 ) = P (K3 ) = P (K4 ) = P (K5 ) = P (K6 ) = 1/6.

Тогда

           P (E|K1 ) = P (m̄ = cccbc) = 0.054 · 0.15 ≈ 0.000001,
           P (E|K2 ) = P (m̄ = bbbcb) = 0.154 · 0.05 ≈ 0.000025,
           P (E|K3 ) = P (m̄ = cccac) = 0.8 · 0.054 ≈ 0.000005,
           P (E|K4 ) = P (m̄ = bbbab) = 0.8 · 0.154 ≈ 0.000405,
           P (E|K5 ) = P (m̄ = aaaca) = 0.84 · 0.05 ≈ 0.020480,
           P (E|K6 ) = P (m̄ = aaaba) = 0.84 · 0.15 ≈ 0.061440.

Отсюда легко находим
                   6
                   X
                         P (Kj ) P (E|Kj ) ≈ 0.013726,
                   j=1

и получаем по формуле Байеса апостериорную вероятность того, что
был использован ключ k = 1 , при условии, что получено сообщение
ē = cccbc:
                                              (1/6) · 0.000001
  P (K1 |E) = P (m̄ = cccbc|ē = cccbc) ≈                      ≈ 0.000011.
                                                 0.013726
144                Глава 7. Теоретическая стойкость криптосистем

Продолжая аналогично, находим, что наиболее вероятны ключи k =
5 и k = 6:

             P (K5 |E) = P (m̄ = aaaca|ē = cccbc) ≈ 0.25,

             P (K6 |E) = P (m̄ = aaaba|ē = cccbc) ≈ 0.75,
а вероятности всех остальных ключей меньше 0.01.                 ⊔
                                                                 ⊓
    Мы видим, что, перехватив всего 5 букв, Ева может опреде-
лить ключ почти однозначно. Таким образом, из этого примера и из
примера с шифром Цезаря в первой главе мы заключаем, что, по-
видимому, существует некоторая длина перехваченного сообщения,
после которой ключ может быть найден с вероятностью, близкой к
единице.
    Утверждение 7.6 (о расстоянии единственности шифра
(Шеннон [19])). Пусть рассматривается система с секретным
ключом, и пусть H(K) — энтропия ключа. Пусть R — избыточ-
ность шифруемого сообщения, а n — длина сообщения, такая, что

                        H (K|e1 , . . . , en ) ≈ 0,          (7.24)

т.е. при этой длине перехваченного сообщения ключ почти одно-
значно восстановлен. Тогда справедливо неравенство

                                    H(K)
                              n≥         .                   (7.25)
                                     R
      Дадим несколько замечаний к этому утверждению.
  1. Число n , удовлетворяющее неравенству (7.25), называется рас-
     стоянием единственности шифра. Это означает, что в среднем
     достаточно перехватить n букв зашифрованного сообщения
     для восстановления ключа.
  2. Мы видим, что если избыточность сообщения R = 0, то ключ
     никогда не будет определен, так как n = ∞. Т.е. шифр невоз-
     можно взломать (мы видели это в примере с номером замка из
     первой главы).
  3. Уменьшение избыточности может быть достигнуто за счет сжа-
     тия данных. Дело в том, что при сжатии данных энтропия
7.5. Расстояние единственности шифра с секретным ключом              145

     «сжатого» текста сохраняется, а длина уменьшается. Следо-
     вательно, энтропия на букву в сжатом тексте больше, чем в
     исходном, а избыточность меньше, см. (7.23). Значит, после
     сжимающего кодирования расстояние единственности шифра
     увеличивается.
  4. С практической точки зрения лучше использовать системы,
     в которых ключ меняется задолго до достижения расстояния
     единственности шифра.
    Д о к а з а т е л ь с т в о . Мы дадим здесь только основную идею
доказательства. Пусть противник, перехватив переданный шифро-
текст ē = e1 e2 . . . en , однозначно восстановил ключ, а тем самым
и исходное сообщение. Значит, неопределенность противника умень-
шилась на H (K) + H (m1 , . . . , mn ), так как он узнал и ключ, и ис-
ходное сообщение. При этом он получил n букв из r -буквенного
алфавита {a1 , . . . , ar }. Мы знаем, что максимальное значение эн-
тропии h∞ = log r , значит, неопределенность противника не может
уменьшаться больше, чем на n log r . Отсюда

                   n log r ≥ H (K) + H (m1 , . . . , mn ) ,

следовательно,

                 n (log r − H (m1 , . . . , mn ) /n) ≥ H (K) ,

откуда получаем, что
                                H(K)                    H(K)
                 n≥                                   =
                      log r − H (m1 , . . . , mn ) /n    R

(здесь мы воспользовались тем, что H (m1 , . . . , mn ) /n → h∞ , и опре-
делением избыточности (7.23)).                                         ⊔
                                                                       ⊓
    П р и м е р 7.4. Оценим расстояние единственности для шифра
из примера 7.3. Имеем H(K) = log 6 ≈ 2.58, log r = log 3 ≈ 1.58, и
энтропия на букву источника равна

        H = −(0.8 log 0.8 + 0.15 log 0.15 + 0.05 log 0.05) ≈ 0.88.

Поэтому
                                   2.58
                          n≥                ≈ 3.7.
                                1.58 − 0.88
146                Глава 7. Теоретическая стойкость криптосистем

    Мы видели, что пяти букв было практически достаточно для
раскрытия ключа. И неравенство (7.25) хорошо согласуется с нашим
примером.                                                      ⊔
                                                               ⊓
    Поясним еще на одном примере, как взаимная зависимость сим-
волов увеличивает избыточность и тем самым уменьшает расстояние
единственности.
    П р и м е р 7.5. Пусть дан марковский источник, т.е. источник с
памятью, в котором вероятность появления очередного символа за-
висит только от предыдущего символа. Источник описывается сле-
дующей матрицей переходов:

                            a   b   c
                          a 0   0.9 0.1
                          b 0   0.1 0.9
                          c 0.4 0.3 0.3

и начальными вероятностями P (a) = 0.19, P (b) = 0.34, P (c) = 0.47.
Пуcть, как и в примере 7.3, используется шифр с шестью возмож-
ными ключами, и пусть перехвачен зашифрованный текст

                            ē = bbacbac.

Мы видим по матрице переходов, что сочетание aa невозможно (по-
сле буквы a вероятность появления снова буквы a равна нулю), а
сочетание bb — маловероятно (вероятность появления b после b рав-
на 0.1). Следовательно, скорее всего первая пара букв соответствует
буквам cc исходного сообщения, т.е. при шифровании была исполь-
зована подстановка c → b . Тогда ac соответствует исходным парам
ab или ba. По матрице мы видим, что сочетание ba невозможно, а
возможно только ab. Поэтому мы можем предположить, что в каче-
стве ключа была использована перестановка номер 2:

                   k = 2 (a → a, b → c, c → b).

     Вычислим точные вероятности использования различных клю-
чей, как в примере 7.3. Заметим, что вероятность конкретного сооб-
щения источника равна произведению вероятности начальной буквы
7.5. Расстояние единственности шифра с секретным ключом                       147

и вероятностей переходов от одной буквы к другой.

  P (E|K1 ) = P (m̄ = bbacbac) = 0.34 · 0.1 · 0 = 0,
  P (E|K2 ) = P (m̄ = ccabcab) = 0.47 · 0.3 · 0.4 · 0.9 · 0.9 · 0.4 · 0.9 =
                               = 0.016446,
  P (E|K3 ) = P (m̄ = aabcabc) = 0.19 · 0 = 0,
  P (E|K4 ) = P (m̄ = aacbacb) = 0.19 · 0 = 0,
  P (E|K5 ) = P (m̄ = ccbacba) = 0.47 · 0.3 · 0.3 · 0 = 0,
  P (E|K6 ) = P (m̄ = bbcabca) = 0.34 · 0.1 · 0.9 · 0.4 · 0.9 · 0.9 · 0.4 =
                               = 0.003966.

Отсюда находим
                     6
                     X
                           P (Kj ) P (E|Kj ) ≈ 0.003402,
                     j=1


и получаем по формуле Бейеса апостериорные вероятности исполь-
зованных ключей при условии, что получено сообщение ē = bbacbac:

              P   (K1 |E) = 0,
              P   (K2 |E) = P (m̄ = ccabcab|ē = bbacbac) ≈ 0.8,
              P   (K3 |E) = 0,
              P   (K4 |E) = 0,
              P   (K5 |E) = 0,
              P   (K6 |E) = P (m̄ = bbcabca|ē = bbacbac) ≈ 0.2.

Эти вычисления подтверждают справедливость приведенного ранее
неформального рассуждения.                                 ⊔
                                                           ⊓
    Оценку расстояния единственности шифра можно использовать
при конструировании криптосистем. Например, кажется разумным
менять ключ на новый, когда общая длина зашифрованных с его по-
мощью сообщений приближается к величине расстояния единствен-
ности.
    Новые подходы к построению теоретически стойких криптоси-
стем, связанные с применением методов специального кодирования,
изложены в работах [10, 15, 16, 18, 30, 31] авторов данной книги.
148                  Глава 7. Теоретическая стойкость криптосистем

Предлагаемые там методы достаточно сложны для описания, од-
нако они эффективны с вычислительной точки зрения и позволя-
ют строить невскрываемые шифры с секретным ключом. Основная
идея этих методов состоит в обеспечении путем кодирования нулевой
избыточности сообщения, которое подлежит шифрованию. Один из
таких методов будет рассмотрен в следующем разделе.


7.6.    Идеальные криптосистемы
В разд. 7.2 было введено понятие совершенной секретности, а затем
было показано, что шифр Вернама совершенно секретен. Мы виде-
ли, что в этом шифре длина ключа равна длине сообщения и ключ
используется всего один раз. Если же мы хотим использовать корот-
кий многоразовый ключ (что актуально для большинства практи-
ческих приложений), то какой наилучший результат в смысле стой-
кости шифра мы можем достичь? При обсуждении утверждения 7.6
указывалось, что при нулевой избыточности сообщения расстояние
единственности шифра бесконечно. Это означает, что даже короткий
(или, что эквивалентно, применяемый много раз) ключ, используе-
мый для шифрования очень длинного сообщения нулевой избыточ-
ности, не может быть раскрыт. А это, в свою очередь, означает, что
у противника, пытающегося разгадать зашифрованный текст, оста-
ется неопределенность, равная неопределенности ключа. Очевидно,
это лучшее, что может быть достигнуто в данных условиях (здесь
можно снова вспомнить пример с кодовым замком из первой гла-
вы). Эти рассуждения подводят нас к понятию строго идеального
шифра, впервые введенному Шенноном [19].
    Пусть сообщение m1 m2 . . . mt шифруется при помощи секрет-
ного ключа k̄ = k1 k2 . . . ks , в результате чего получается зашифро-
ванное сообщение ē = e1 e2 . . . et . Обозначим через H(m1 m2 . . . mt )
энтропию сообщения, через H(ē) и H(k̄) — соответственно энтро-
пии шифротекста и ключа. Тогда H(m1 m2 . . . mt |ē) представляет
неопределенность сообщения, а H(k̄|ē) — неопределенность ключа
при условии, что известен шифротекст ē.

      Определение 7.3. Шифр называется строго идеальным, если

  H(m1 m2 . . . mt |ē) = H(k̄|ē) = min{H(m1 m2 . . . mt ), H(k̄)}.   (7.26)
7.6. Идеальные криптосистемы                                    149

     Если энтропия ключа меньше энтропии сообщения источника,
то (7.26) упрощается:

                H(m1 m2 . . . mt |ē) = H(k̄|ē) = H(k̄)      (7.27)

при всех достаточно больших t . Так как мы будем рассматривать
случай, когда длина сообщения t велика, то в качестве определения
строго идеального шифра будем использовать (7.27) .
    Неформально, строгая идеальность шифра означает, что коли-
чество решений криптограммы равно количеству различных ключей
и все решения равновероятны, как в примере с кодовым замком.
    В этом разделе мы рассмотрим конструкцию идеальной систе-
мы, недавно предложенную в [10], ограничившись описанием только
основной идеи применительно к случаю, когда сообщение порожда-
ется двоичным источником без памяти с неизвестной статистикой,
иными словами, делается последовательно и независимо случайный
выбор буквы из алфавита A = {a1 , a2 }, причем вероятности выбора
букв неизвестны.
    Пусть источник порождает потенциально неограниченные сооб-
щения m1 m2 . . . mt , t → ∞ , и имеется ключ фиксированной дли-
ны k̄ = k1 k2 . . . ks , s ≥ 1 . (Как мы упомянули выше, предполага-
ется также, что энтропия источника на букву отлична от нуля, так
как в противном случае вообще нет необходимости в передаче сооб-
щений.) Будем последовательно разбивать сообщение источника на
блоки символов длины n , где n > 1 — параметр метода. Обозначим
один из таких блоков через m̄. Опишем преобразования, выполняе-
мые над каждым таким n -буквенным блоком.
    Вначале определим количество букв a1 и a2 в блоке m̄. Пусть,
скажем, имеется n1 букв a1 и n2 = n − n1 букв a2 . Определим u(m̄)
как слово длины ⌈log(n + 1)⌉ бит, кодирующее n1 .
    Теперь рассмотрим множество S всех последовательностей, со-
стоящих из n1 букв a1 и n2 букв a2 . В этом множестве

                                          n!
                     |S| = Cnn1 =
                                    n1 !(n − n1 )!

элементов. Несмотря на то, что нам не известны вероятности после-
довательностей из множества S , одно мы можем сказать точно —
все они равны между собой (в силу независимости выбора отдельных
букв сообщения). Зададим на множестве S некоторый порядок, на-
150                 Глава 7. Теоретическая стойкость криптосистем

пример, расположим сообщения в порядке возрастания соответству-
ющих им двоичных чисел (считая, что a1 = 0, a2 = 1). Вычислим
номер данного конкретного блока m̄ внутри упорядоченного мно-
жества S (для вычисления такого номера известен эффективный
алгоритм [11], описание которого выходит за рамки нашей книги).
Обозначим этот номер через ω(m̄).
      Разобьем множество S на непересекающиеся подмножества S0 ,
S1 , . . . , Sν с числами элементов, равными различным степеням двой-
ки (например, если |S| = 21, то получаем три подмножества с чис-
лами элементов 16, 4 и 1). По ω(m̄) определим, какому подмноже-
ству принадлежит m̄ (обозначим номер такого подмножества через
v(m̄)), и найдем номер m̄ внутри данного подмножества (обозначим
этот номер через w(m̄)).
      Посмотрим внимательно на номер сообщения внутри подмноже-
ства, w(m̄). Замечательно то, что w(m̄) — это полностью случайная
последовательность нулей и единиц (т.е. такая, где символы незави-
симы, а вероятности нуля и единицы равны). Действительно, w(m̄)
— это номер одной из равновероятных последовательностей букв в
подмножестве из 2b элементов (для некоторого b ). Номера всех та-
ких последовательностей — это всевозможные последовательности
из b двоичных цифр. Но если все последовательности из b двоич-
ных цифр равновероятны, то отдельные символы равновероятны и
независимы.
      Итак, обрабатывая описанным образом последовательные блоки
сообщения, мы представляем сообщение в виде

              u(m̄1 )v(m̄1 )w(m̄1 )u(m̄2 )v(m̄2 )w(m̄2 ) . . . .

    Теперь перейдем к описанию процесса шифрования преобразо-
ванного сообшения. На первый взгляд это может показаться стран-
ным, но слова u(·) и v(·) вообще не шифруются! Шифруются только
слова w(·) с использованием секретного ключа k̄ . В качестве шиф-
ра можно, например, использовать побитовое сложение по модулю 2
с периодически продолженным ключом. Для описания этого шиф-
ра удобно занумеровать символы слов w(·) подряд и обозначить их
через w1 w2 w3 . . . . Тогда шифрование проводится по формуле

                            zi = wi ⊕ ki mod s .
7.6. Идеальные криптосистемы                                                 151

    В результате применения описанного метода мы зашифровали
сообщение следующим образом:

 m1 m2 . . . mt −→ ē = u(m̄1 )v(m̄1 )z(m̄1 )u(m̄2 )v(m̄2 )z(m̄2 ) . . . . (7.28)

    По построению алгоритма ясно, что из правой части (7.28) мож-
но восстановить сообщение, если знать k̄ . Вначале нужно дешифро-
вать символы слов w(·), используя формулу

                                  wi = zi ⊕ ki mod s ,                    (7.29)

а затем из слов u(·)v(·)w(·) восстанавливаются последовательные
блоки сообщения.
    П р и м е р 7.6. Пусть требуется зашифровать сообщение

                            a2 a2 a1 a2 a2 a2 a1 a2 a2 a1

с трехбитовым ключом k̄ = 011. Разобьем сообщение на два блока
по пять символов, n = 5.
    Выполним преобразование для первого блока m̄1 = a2 a2 a1 a2 a2 .
Для этого блока n1 = 1 и u(m̄1 ) = (001)2 . Рассмотрим теперь упоря-
доченное множество всех сообщений, состоящих из одной буквы a1 и
                                                     5!
четырех букв a2 (табл. 7.2). Всего таких сообщений 1!4! = 5 , поэтому
имеем два подмножества S0 и S1 с числом элементов соответствен-
но 4 и 1. Мы видим, что m̄1 входит в S0 под номером 2 = (10)2 .


            Т а б л и ц а 7.2. Множество равновероятных
                               сообщений; n1 = 1 , n2 = 4
                 Сообщение              Номер в S        Sv   w
                 a1 a2 a2 a2 a2             000               00
                 a2 a1 a2 a2 a2             001               01
                 a2 a2 a1 a2 a2             010          S0   10
                 a2 a2 a2 a1 a2             011               11
                 a2 a2 a2 a2 a1             100          S1    -

Таким образом, мы получаем следующие два слова: v(m̄1 ) = 0,
w(m̄1 ) = (10)2 .
    Теперь выполним преобразование для второго блока сообщения
m̄2 = a2 a1 a2 a2 a1 . Для этого блока n1 = 2 и u(m̄2 ) = (010)2 . Рассмот-
рим упорядоченное множество всех сообщений, состоящих из двух
152                 Глава 7. Теоретическая стойкость криптосистем

                                                           5!
букв a1 и трех букв a2 (табл. 7.3). Всего таких сообщений 2!3! = 10,
поэтому имеем два подмножества S0 и S1 с числом элементов соот-
ветственно 8 и 2. Мы видим, что m̄2 входит под номером 6 = (110)2


           Т а б л и ц а 7.3. Множество равновероятных
                              сообщений; n1 = 2 , n2 = 3
              Сообщение              Номер в S      Sv    w
              a1 a1 a2 a2 a2           0000              000
              a1 a2 a1 a2 a2           0001              001
              a1 a2 a2 a1 a2           0010              010
              a1 a2 a2 a2 a1           0011         S0   011
              a2 a1 a1 a2 a2           0100              100
              a2 a1 a2 a1 a2           0101              101
              a2 a1 a2 a2 a1           0110              110
              a2 a2 a1 a1 a2           0111              111
              a2 a2 a1 a2 a1           1000         S1    0
              a2 a2 a2 a1 a1           1001               1

в S0 . Таким образом, мы получаем v(m̄2 ) = 0, w(m̄2 ) = (110)2 .
    В результате мы получили следующий двоичный код преобра-
зованного сообщения:

                               001 0 10 010 0 110

(пробелы здесь поставлены только для удобства чтения; для одно-
значного декодирования они не нужны).
    Теперь зашифруем преобразованное сообщение. Периодически
продолженный ключ имеет вид k̄ = 011011 . . . . Сложение битов слов
w(·) с этим ключом дает

                                   1 0 1 1 0
                               ⊕
                                   0 1 1 0 1
                                             .
                                   1 1 0 1 1

Зашифрованное сообщение выглядит следующим образом:

                         ē = 001 0 11 010 0 011.                 ⊔
                                                                  ⊓


    Остановимся теперь на основных свойствах рассмотренного ме-
тода.
7.6. Идеальные криптосистемы                                          153

    Утверждение 7.7. Построенный шифр строго идеален.
     Д о к а з а т е л ь с т в о . Как уже отмечалось при изложении ме-
тода, слово w(m̄) для каждого блока m̄ состоит из равновероятных и
независимых символов 0 и 1, другими словами, «полностью» случай-
но. Так как блоки в сообщении независимы, то в преобразованном со-
общении последовательность слов w(m̄1 )w(m̄2 ) . . . = w1 w2 w3 . . . так-
же полностью случайна. Но любая последовательность w1 w2 w3 . . .
соответствует некоторому сообщению, и все такие сообщения равно-
вероятны. Поэтому при подстановке любого ключа в дешифрующее
выражение (7.29) мы получаем какое-либо решение, причем все ре-
шения равновероятны. В результате, имея только шифротекст ē, мы
ничего не можем сказать об использованном ключе, т.е.
                            H(k̄|ē) = H(k̄).
    Далее, каждому конкретному сообщению m1 m2 . . . mt соответст-
вует одна и только одна последовательность w1 w2 w3 . . ., и при до-
статочно большом t , а именно, таком, что длина последовательности
w1 w2 w3 . . . не меньше длины ключа, каждому ключу, подставляемо-
му в (7.29), соответствуют различные равновероятные сообщения.
Поэтому
                        H(m1 m2 . . . mt |ē) = H(k̄).
Ненулевая энтропия источника гарантирует то, что требуемое доста-
точно большое t всегда существует.
    Таким образом, мы доказали, что (7.27) выполняется.        ⊔
                                                               ⊓
    Особенностью предложенного шифра является то, что шифро-
ванию подвергается не все преобразованное сообщение, а только его
часть. В приведенном примере даже может показаться, что слишком
много информации остается «открытой». Какая все-таки доля ин-
формации скрывается этим шифром? Следующее утверждение дает
ответ на этот вопрос.
    Утверждение 7.8. Пусть сообщение порождается источни-
ком без памяти с энтропией h на букву . Тогда для каждого блока
m̄ из n символов сообщения средняя длина шифруемого слова w(m̄)
удовлетворяет неравенству
                     E(|w(m̄)|) > nh − 2 log(n + 1)                (7.30)
(здесь E(·) — математическое ожидание, а | · | — длина).
154                 Глава 7. Теоретическая стойкость криптосистем

     Д о к а з а т е л ь с т в о . Компонента кода u(m̄) может прини-
мать любое значение от 0 до n , и поэтому ее максимальная энтропия
равна log(n + 1).
     Слово v(m̄) может прининять любое значение от 0 до ν , что свя-
зано с разбиением S на подмножества S0 , S1 , . . . , Sν . Очевидно, что
ν ≤ ⌊log |S|⌋. Из известного неравенства |S| = Cnn1 < 2n получаем
log |S| < n и ν ≤ log |S| < n. Поэтому максимальная энтропия слова
v(m̄) строго меньше log(n + 1).
     Энтропия блока равна H(m̄) = nh (так как символы порожда-
ются источником без памяти). При преобразовании блока энтропия
не изменяется, поэтому для энтропии слова w(m̄) имеем

                     H(w(m̄)) > nh − 2 log(n + 1)

(из общей энтропии мы вычли верхнюю границу максимальной эн-
тропии слов u(m̄) и v(m̄)). Но так как слово w(m̄) состоит из рав-
новероятных и независимых символов 0 и 1, его средняя длина сов-
падает с энтропией, что завершает доказательство.               ⊔
                                                                ⊓
     Неформально, утверждение 7.8 говорит о том, что «почти вся»
информация сообщения содержится в шифруемой компоненте кода
w , если длина блока n достаточно велика. Иными словами, пред-
ставленный шифр скрывает «почти всю» информацию. Причем да-
же полный перебор ключей не позволяет вскрыть шифр.
     Конечно, рассмотренная конструкция идеальной криптосисте-
мы может иметь различные варианты построения. Например, может
представлять интерес вариант, в котором часть ключа используется
для «закрытия» префикса (т.е. компонент u и v кода). Правда, в
этом случае система будет «просто» идеальной (не строго идеаль-
ной).



Задачи и упражнения
 7.1. Зашифровать сообщение m̄ шифром Вернама с ключом k̄ :

         а. m̄ = 1001101011 , k̄ = 0110100101 ,
         б. m̄ = 0011101001 , k̄ = 1100011100 ,
         в. m̄ = 1000011100 , k̄ = 1001011010 ,
Задачи и упражнения                                                  155

        г. m̄ = 0011100010 , k̄ = 0110111001 ,
       д. m̄ = 1001101011 , k̄ = 1000111010 .

 7.2. Пусть источник без памяти порождает буквы из алфавита
      A = {a, b, c} с вероятностями P (a), P (b), P (c). Шифратор
      заменяет буквы, используя одну из шести возможных пере-
      становок, как это делалось в примере 7.3. Определить апосте-
      риорные вероятности использованных ключей для заданного
      зашифрованного сообщения ē:
       а. P (a) = 0.1, P (b) = 0.7, P (c) = 0.2, ē = abaacac,
       б. P (a) = 0.9, P (b) = 0.09, P (c) = 0.01, ē = cbaccca,
       в. P (a) = 0.14, P (b) = 0.06, P (c) = 0.8, ē = bbabbcab,
        г. P (a) = 0.7, P (b) = 0.05, P (c) = 0.25, ē = cccacbbc,
       д. P (a) = 0.1, P (b) = 0.7, P (c) = 0.2, ē = abbbbab.
 7.3. Для источников задачи 7.2 вычислить энтропию и расстояние
      единственности.
 7.4. По имеющемуся зашифрованному сообщению ē найти апосте-
      риорные вероятности использованных ключей и соответству-
      ющие им сообщения, если известно, что используется шифр
      примера 7.3, а сообщения порождаются марковским источни-
      ком, описанным в примере 7.5:
       а. ē = bcacbcacc,
       б. ē = caaabaaba,
       в. ē = aacabcaac,
        г. ē = bcaaaacaa,
       д. ē = aaacaaaca.
Глава 8.     СОВРЕМЕННЫЕ ШИФРЫ С
             СЕКРЕТНЫМ КЛЮЧОМ




8.1.   Введение
В этой главе мы рассмотрим вычислительно стойкие шифры с сек-
ретным ключом, которые, в принципе, могут быть вскрыты, но тре-
буют для этого очень большого количества вычислений, скажем,
1020 лет для суперкомпьютера. Эти шифры обеспечивают шифро-
вание и дешифрование данных со скоростями, значительно превы-
шающими скорости шифров с открытыми ключами и теоретически
стойких шифров, что и объясняет их широкое практическое исполь-
зование. В последующих разделах мы опишем некоторые наиболее
популярные шифры и режимы их функционирования, однако внача-
ле, чтобы пояснить принципы построения этих шифров, продолжим
пример с шифром Цезаря, начатый в первой главе.
     Там мы рассмотрели атаку по шифротексту на шифр Цезаря.
Было показано, что в случае избыточных сообщений шифр легко
вскрывается путем перебора ключей. Поищем возможности повы-
шения стойкости шифра Цезаря. Пожалуй, самое простое, что при-
ходит в голову — увеличить количество возможных значений ключа.
В этом случае Еве придется перебирать больше ключей, прежде чем
она найдет единственный правильный.
     Естественный способ увеличить количество возможных значе-
ний ключа для шифра Цезаря — использовать pазные ключи для
pазных букв сообщения. Hапpимеp, мы можем шифpовать каждую
нечетную букву ключом k1 , а четную ключом k2 . Тогда секретный
ключ k = (k1 , k2 ) будет состоять из двух чисел, и количество воз-
можных ключей будет 322 = 1024. Зашифруем наше прежнее сооб-
щение из первой главы ключом k = (3, 5):

                                3,5
                  ПЕРЕМЕНА −→ ТКУКПКРЕ.                       (8.1)

    Эта схема легко обобщается на произвольную длину секретно-
8.1. Введение                                                      157

го ключа k = (k1 , k2 , · · · , kt )32 . При t порядка 10 и выше задача
полного перебора ключей становится практически нерешаемой.
     Тем не менее, данный шифр легко вскрывается путем так на-
зываемого частотного криптоанализа. Для этого используется ста-
тистика языка, на котором написано передаваемое сообщение. При
использовании частотного криптоанализа перебор начинают с клю-
чей, соответствующих наиболее часто встречающимся буквам и их
сочетаниям. Например, известно, что в типичном тексте на русском
языке буква О встречается чаще других. Смотрим на ТКУКПКРЕ в
(8.1) и определяем, какие буквы встречаются чаще других на четных
и нечетных местах. На четных местах это К. Предполагаем, что это
код О, следовательно, k2 = К − О = 28 (mod 32). На нечетных ме-
стах все буквы различны, поэтому для поиска k1 знание частот букв
языка не помогает (дело в том, что для нашего примера взято очень
короткое сообщение). Пытаемся, как и прежде, найти k1 путем пере-
бора, но убеждаемся, что приемлемых расшифровок не получается.
Это означает, что наша гипотеза о том, что О заменяется в шифре
на К, неверна. Берем вместо О другую часто встречающуюся букву
— букву Е. Вычисляем k2 = К − Е = 5. Повторяем аналогичные
действия для поиска k1 и на этот раз находим решение k1 = 3.
В результате, чтобы расшифровать сообщение, из всех возможных
1024 ключей нам понадобилось проверить только 36 (мы проверяли
(0, 28), . . . , (31, 28),(0, 5), . . . , (3, 5)).
     Попробуем слегка усложнить шифр, чтобы затруднить частот-
ный криптоанализ. Нам нужно каким-то образом перемешать сим-
волы сообщения, заставить их влиять друг на друга, чтобы скрыть
индивидуальные частоты их появления. По-прежнему будем исполь-
зовать ключ k = (k1 , k2 ) и шифровать сообщение блоками по два
символа mi , mi+1 . Один из простейших вариантов шифра может вы-
глядеть так:
                   m̃i     = mi + mi+1 ,
                   m̃i+1   = mi+1 + m̃i ,
                                                                  (8.2)
                   ci      = m̃i + k1 ,
                   ci+1    = m̃i+1 + k2     (mod 32)

(все суммы вычисляются по модулю 32). Здесь mi — нечетная буква
исходного текста, mi+1 — четная буква, k1 , k2 — символы ключа,
а ci , ci+1 — получаемые символы шифротекста. Например, пара
158            Глава 8. Современные шифры с секретным ключом

символов ПЕ шифруется ключом k = (3, 5) следующим образом:

                         m̃i     = П + Е = Ф,
                         m̃i+1   = Е + Ф = Щ,
                         ci      = Ф + 3 = Ч,
                         ci+1    = Щ + 5 = Ю,
т.е. ПЕ превращается в ЧЮ.
     Отметим, что этот шифр можно дешифровать. Алгоритм де-
шифрования, называемый обычно обратным шифром, выглядит сле-
дующим образом:
                 m̃i+1   = ci+1 − k2 ,
                 m̃i     = ci − k1 ,
                                                              (8.3)
                 mi+1    = m̃i+1 − m̃i ,
                 mi      = m̃i − mi+1        (mod 32).

    Применяя к нашему сообщению шифр (8.2) с ключом (3, 5), по-
лучаем
                                           3,5
      ПЕРЕМЕНА −→ ФЩХЪСЦНН −→ ЧЮШЯФЫРТ.                       (8.4)

Здесь для наглядности после первой стрелки показан промежуточ-
ный результат, получающийся после выполнения первых двух опе-
раций в (8.2) (это «перемешанный», но еще не зашифрованный текст
сообщения). Мы видим, что данный шифр скрывает частоты появле-
ния отдельных символов, затрудняя частотный анализ. Конечно, он
сохраняет частоты появления пар символов, но мы можем скрыть и
их, если будем шифровать сообщения блоками по три символа и т.д.
     Вообще, шифр (8.2) выглядит более сложным для Евы по срав-
нению с шифром (8.1), и он дает нам возможность рассмотреть еще
одну ситуацию, связанную с ее действиями. До сих пор мы рас-
сматривали атаки только по шифротексту. Но что произойдет, если
Ева каким-то образом достала открытый текст, соответствующий ра-
нее переданному зашифрованному сообщению? (Т.е. мы находимся
в условиях атаки второго типа, см. главу 1, стр. 10.) Например, Ева
имеет пару (ПЕРЕМЕНА, ТКУКПКРЕ) для шифра (8.1). Тогда она
сразу вычисляет секретный ключ, k1 = Т − П = 3, k2 = К − Е = 5,
и легко расшифровывает все последующие сообщения от Алисы к
Бобу. При использовании шифра (8.2) пара (ПЕРЕМЕНА, ЧЮШЯ-
ФЫРТ) уже не дает такого очевидного решения, хотя и здесь оно
8.2. Блоковые шифры                                         159

довольно просто. Ева применяет две первые операции из (8.2) (не
требующие секретного ключа) к слову ПЕРЕМЕНА, получает про-
межуточный результат ФЩХЪСЦНН и уже по паре (ФЩХЪСЦНН,
ЧЮШЯФЫРТ), как и в первом случае, находит ключ k = 3, 5 .
    Как затруднить такие действия Евы? Идея проста. Будем при
шифровании сообщения использовать шифр (8.2) два раза. Тогда
получим:
                 3,5                3,5
       ПЕРЕМЕНА −→ ЧЮШЯФЫРТ −→ ШШЪЫТПЕЩ.                   (8.5)
Теперь, имея пару (ПЕРЕМЕНА, ШШЪЫТПЕЩ), Ева не может
вычислить ключ, по крайней мере алгоритм ее действий не очевиден
(она не может получить промежуточное значение ЧЮШЯФЫРТ,
так как при его построении был использован секретный ключ, ей не
известный).
     В представленной схеме (8.5) отдельная реализация алгоритма
(8.2) называется раундом или циклом шифра.
     Мы проиллюстрировали влияние на стойкость шифра таких па-
раметров, как длина ключа, размер блока, количество раундов, а
также показали необходимость введения «перемешивающих» преоб-
разований. В реальных шифрах используются, в принципе, те же
преобразования, но над более длинными цепочками символов и обла-
дающие целым рядом дополнительных свойств. Это связано с нали-
чием развитых методов криптоанализа, таких, как дифференциаль-
ный и линейный криптоанализ, описание которых выходит за рамки
нашей книги, но может быть найдено в [35].

8.2.    Блоковые шифры
Блоковый шифр можно определить как зависящее от ключа K об-
ратимое преобразование слова X из n двоичных символов. Преоб-
разованное с помощью шифра слово (или блок) будем обозначать
через Y . Для всех рассматриваемых в этом разделе шифров длина
слова Y равна длине слова X .
    Таким образом, блоковый шифр — это обратимая функция
E (другим словами, такая, для которой существует обратная функ-
ция). Конкретный вид EK этой функции определяется ключом K ,
                   Y = EK (X),
                        −1
                   X = EK  (Y ) для всех X.
160            Глава 8. Современные шифры с секретным ключом

        −1
Здесь EK    обозначает дешифрующее преобразование и называется
обратным шифром.
     Для криптографических приложений блоковый шифр должен
удовлетворять ряду требований, зависящих от ситуации, в которой
он используется. В большинстве случаев достаточно потребовать,
чтобы шифр был стоек по отношению к атаке по выбранному тек-
сту. Это автоматически подразумевает его стойкость по отношению
к атакам по шифротексту и по известному тексту. Следует заметить,
что при атаке по выбранному тексту шифр всегда может быть взло-
ман путем перебора ключей. Поэтому требование стойкости шифра
можно уточнить следующим образом.
     Шифр стоек (при атаке по выбранному тексту), если для него
не существуют алгоритмы взлома, существенно более быстрые, чем
прямой перебор ключей.
     Нам будет достаточно такого нестрогого определения стойкости.
На самом деле, по состоянию на сегодняшний день, ни для одного
используемого шифра не доказано соответствие этому определению
стойкости. Реально можно говорить о следующем.
     Шифр считается стойким (при атаке по выбранному тексту),
если для него неизвестны алгоритмы взлома, существенно более эф-
фективные, чем прямой перебор ключей.
     Ниже мы приведем примеры некоторых практичеки используе-
мых блоковых шифров. Наша задача будет состоять не только в том,
чтобы дать достаточно подробное описание алгоритмов (их описа-
ние может быть найдено в литературе), но и в объяснении основных
принципов построения блоковых шифров. Кроме того, наше описа-
ние может облегчить понимание материала, изложенного в офици-
альных документах (ГОСТах и.т.п.). Далее, на протяжении всей гла-
вы, мы будем изучать технику использования блоковых шифров для
решения различных задач криптографии.
     До недавнего времени ни одна книга по криптографии не обхо-
дилась без описания шифра DES (Data Encryption Standard). Этот
шифр был принят в качестве стандарта США в 1977 году. Его основ-
ные параметры: размер блока 64 бита, длина ключа 56 бит, 16 раун-
дов. Этот шифр интенсивно использовался более двух десятков лет
и еще сегодня встречается во многих работающих системах. Несмот-
ря на многочисленные атаки против DES, он так и не был взломан.
Однако высокий уровень развития вычислительных средств позво-
ляет сегодня вскрывать DES путем перебора ключей. Например, еще
8.2. Блоковые шифры                                          161

в 1993 году было опубликовано техническое описание системы стои-
мостью в один миллион долларов, позволяющей взламывать любой
ключ DES за 7 часов. В результате DES не рекомендуется использо-
вать во вновь создаваемых криптографических системах, и поэтому
мы не описываем этот шифр. В 2001 году после специально объяв-
ленного конкурса в США был принят новый стандарт на блоковый
шифр, названный AES (Advanced Encryption Standard), в основу ко-
торого был положен шифр Rijndael, разработанный бельгийскими
специалистами.
    Большинство современных блоковых шифров строятся по схе-
мам, значительно отличающимся от DES. Тем не менее есть один
действующий шифр, построенный на тех же принципах, что и DES,
и представляющий для нас особый интерес. Это российский блоко-
вый шифр ГОСТ 28147-89.


Шифр ГОСТ 28147-89
Шифр ГОСТ 28147-89 [5], как следует из его обозначения, был при-
нят в качестве стандарта в 1989 году. Основные параметры ГОСТ
28147-89: длина ключа 256 бит, размер блока 64 бита, 32 раунда.
ГОСТ 28147-89 более удобен для программной реализации, чем DES,
имеются сведения о выигрыше по времени примерно в 1.5 раза. В от-
личие от DES, ГОСТ 28147-89, по-видимому, не был предметом столь
глубокого анализа со стороны мирового криптологического сообще-
ства. Тем не менее, как отмечают специалисты, консервативный ди-
зайн и величина основных параметров (длина ключа, размер блока,
количество раундов) позволяют утверждать, что шифр вряд ли мо-
жет быть слабым. Никаких эффективных атак против шифра ГОСТ
28147-89 не опубликовано.
    В основе ГОСТ 28147-89, так же как и DES, лежит так называе-
мая структура Фейстела. Блок разбивается на две одинаковые части,
правую R и левую L. Правая часть объединяется с ключевым эле-
ментом и посредством некоторого алгоритма шифрует левую часть.
Перед следующим раундом левая и правая части меняются места-
ми. Такая структура позволяет использовать один и тот же алгоритм
как для шифрования, так и для дешифрования блока. Это особенно
важно при аппаратной реализации, так как прямой и обратный шиф-
ры формируются одним и тем же устройством (различается только
порядок подачи элементов ключа).
162            Глава 8. Современные шифры с секретным ключом

      Перейдем к непосредственному описанию шифра ГОСТ 28147-
89. Введем необходимые определения и обозначения. Последователь-
ность из 32 бит будем называть словом. Блок текста X (64 бита),
также как блок шифротекста Y , состоит из двух слов — левого L
и правого R , причем L — старшее слово, а R — младшее. Секрет-
ный ключ K (256 бит) рассматривается состоящим из восьми слов
K = K0 K1 · · · K7 . На его основе строится так называемый раундовый
ключ W = W0 W1 · · · W31 , состоящий из 32 слов (метод построения
раундового ключа будет дан позже).
      Для работы шифра нужны 8 таблиц S0 , S1 , . . . , S7 (называ-
емых также S-боксами). Каждая таблица содержит 16 четырехби-
товых элементов, нумеруемых с 0 по 15. Будем обозначать через
Si [j] j -й элемент i-й таблицы. ГОСТ рекомендует заполнять каж-
дую таблицу различными числами из множества {0, 1, . . . , 15}, пе-
реставленными случайным образом. Содержимое таблиц формирует
дополнительный секретный параметр шифра, общий для большой
группы пользователей. Заметим, что в DES аналогичные S-боксы
фиксированы и несекретны.
      В шифре используются следующие операции:

  + сложение слов по модулю 232 ;
 ←֓ циклический сдвиг слова влево на указанное число бит;
  ⊕ побитовое «исключающее или» двух слов, т.е. побитовое сло-
    жение по модулю 2.

Алгоритм 8.1. Базовый цикл шифра ГОСТ 28147-89
ВХОД:   Блок L, R , раундовый ключ W .
ВЫХОД: Преобразованный блок L, R .
1.    FOR i = 0, 1, . . . , 31 DO
2.       k ← R + Wi , k = (k7 · · · k0 )16 ;
3.      FOR j = 0, 1, . . . , 7 DO
4.          kj ← Sj [kj ];
5.       L ← L ⊕ (k ←֓ 11);
6.       L ←→ R ;
7.    RETURN L, R .

(На шаге 4 алгоритма используются отдельные четырехбитовые эле-
менты переменной k .)
8.2. Блоковые шифры                                                  163

   С помощью базового цикла осуществляется шифрование и де-
шифрование блока. Чтобы зашифровать блок, строим раундовый
ключ


     W = K 0 K1 K2 K 3 K4 K5 K 6 K7 K0 K1 K 2 K3 K4 K 5 K6 K7
                  K0 K1 K2 K3 K4 K5 K6 K7 K7 K6 K5 K4 K3 K2 K1 K0 , (8.6)

подаем на вход X и на выходе получаем Y .
    Чтобы дешифровать блок, строим раундовый ключ


     W = K 0 K1 K2 K 3 K4 K5 K 6 K7 K7 K6 K 5 K4 K3 K 2 K1 K0
                  K7 K6 K5 K4 K3 K2 K1 K0 K7 K6 K5 K4 K3 K2 K1 K0 , (8.7)

подаем на вход Y и на выходе получаем X .
    Программная реализация обычно требует переработки цикла 3
алгоритма 8.1, так как работа с полубайтами неэффективна. Ясно,
что то же самое преобразование может быть выполнено с использо-
ванием четырех таблиц по 256 байт или двух таблиц по 65536 по-
луслов. Например, при работе с байтами имеем k = (k3 · · · k0 )256 , и
шаги 3—4 алгоритма 8.1 переписываются следующим образом:


3.            FOR j = 0, 1, 2, 3 DO
4.               kj ← Tj [kj ].

    Таблицы Tj , j = 0, 1, 2, 3 , вычисляются предварительно из S-
боксов:


              FOR i = 0, 1, . . . , 255 DO
                 Tj [i] ← S2j [i mod 16] + 16S2j+1 [i div 16].

     ГОСТ ничего не говорит о правилах формирования ключевой
информации, кроме требования, чтобы каждый S-бокс содержал пе-
рестановку различных чисел. В то же время ясно, что, например,
нулевой ключ или тривиально заданные S-боксы (отображающие k
в себя) не обеспечивают секретности шифра.
 164            Глава 8. Современные шифры с секретным ключом

 Шифр RC6

 Это один из новейших шифров, предложенный Ривестом (Ronald
 Rivest) в 1998 году. Этот шифр принимал участие в конкурсе на
 новый стандарт блокового шифра США, проводимом в 1999–2001
 годах, прошел в финал, но по совокупности таких показателей, как
 быстродействие, удобство использования и т.п., уступил первое ме-
 сто другому шифру (Rijndael). Тем не менее, активные исследова-
 ния RC6 в ходе проведения конкурса не выявили в нем каких-либо
 слабых мест, и данный шифр высоко оценивается многими специа-
 листами.
     В RC6 пользователь задает размер слова ( w ) 16, 32 или 64 бита,
 количество раундов ( r ), длину ключа ( l ) от 0 до 255 байт. Размер
 блока всегда составляет четыре слова. Конкретный вариант шифра
 обозначается по схеме RC6- w/r/l . Например, RC6-32/20/16 — раз-
 мер блока 128 бит, длина ключа 128 бит, 20 раундов (такой шифр
 исследовался в качестве кандидата на стандарт США).
     В шифре используются следующие операции:

 +, − сложение и вычитание слов по модулю 2w ;

    ∗ умножение по модулю 2w ;

   ⊕ побитовое сложение по модулю 2 или, что то же самое, «исклю-
     чающее или» двух слов;

←֓, ֒→ циклические сдвиги слова влево или вправо на указанное число
       бит (заметим, что при длине слова w бит величина цикличе-
       ского сдвига фактически приводится по модулю w , причем,
       как правило, это приведение выполняется автоматически на
       машинном уровне, т.е. не требует дополнительных вычислений
       — процессор просто использует младшие log w бит числа, за-
       дающего величину сдвига).

     Шифрование и дешифрование блока данных производится с ис-
 пользованием одного и того же раундового ключа W длиной 2r + 4
 слова (нумерация слов с нуля), получаемого из секретного ключа K
 (метод формирования раундового ключа будет рассмотрен ниже).
8.2. Блоковые шифры                                          165

Алгоритм 8.2. RC6: шифрование блока данных

ВХОД:    Блок из четырех слов (a, b, c, d), раундовый ключ W .
ВЫХОД: Зашифрованный блок (a, b, c, d).
1.    b ← b + W0 , d ← d + W1 ;
2.    FOR i = 1, 2, . . . , r DO
3.       t ← (b ∗ (2b + 1)) ←֓ log w ,
4.       u ← (d ∗ (2d + 1)) ←֓ log w ,
5.       a ← ((a ⊕ t) ←֓ u) + W2i ,
6.       c ← ((c ⊕ u) ←֓ t) + W2i+1 ,
7.       (a, b, c, d) ← (b, c, d, a);
8.    a ← a + W2r+2 , c ← c + W2r+3 ;
9.    RETURN (a, b, c, d).

    Для дешифрования просто «прокручиваем» процесс в обратном
порядке.


Алгоритм 8.3. RC6: дешифрование блока данных

ВХОД:    Блок из четырех слов (a, b, c, d), раундовый ключ W .
ВЫХОД: Дешифрованный блок (a, b, c, d).
1.    c ← c − W2r+3 , a ← a − W2r+2 ;
2.    FOR i = r, r − 1, . . . , 1 DO
3.       (a, b, c, d) ← (d, a, b, c),
4.       t ← (b ∗ (2b + 1)) ←֓ log w ,
5.       u ← (d ∗ (2d + 1)) ←֓ log w ,
6.       a ← ((a − W2i ) ֒→ u) ⊕ t ,
7.       c ← ((c − W2i+1 ) ֒→ t) ⊕ u ;
8.    d ← d − W1 , b ← b − W0 ;
9.    RETURN (a, b, c, d).

    Расписание раундового ключа в RC6 более сложно, чем в ГОСТ
28147-89, что характерно для большинства современных шифров. По
сути дела речь идет о развертывании секретного ключа K в более
длинную псевдослучайную последовательность W с целью затруд-
нить криптоанализ шифра.
    Обозначим через c число слов в ключе, c = 8l/w . Посредством
нижеприведенного алгоритма секретный ключ K разворачивается в
166            Глава 8. Современные шифры с секретным ключом

раундовый ключ W :

                  K0 K1 · · · Kc−1 −→ W0 W1 · · · W2r+3 .

В алгоритме используются «магические» числа: Pw — первые w бит
двоичного разложения числа e − 2, где e — число Эйлера, служа-
щее основанием натурального логарифма, и √  Qw — первые w бит
двоичного разложения числа φ − 1, где φ = ( 5 − 1)/2 — «золотое
сечение». В табл. 8.1 значения Pw и Qw приведены в шестнадцати-
ричной системе счисления для различных длин слов w .


Алгоритм 8.4. RC6: формирование раундового ключа
ВХОД:     Секретный ключ K .
ВЫХОД: Раундовый ключ W .
1.    W 0 ← Pw ;
2.    FOR i = 1, 2, . . . , 2r + 3 DO Wi ← Wi−1 + Qw ;
3.    a ← 0 , b ← 0, i ← 0, j ← 0;
4.    k ← 3 max(c, 2r + 4);
5.    DO k раз
6.        Wi ← (Wi + a + b) ←֓ 3 , a ← Wi ,
7.        Kj ← (Kj + a + b) ←֓ (a + b), b ← Kj ,
8.        i ← i + 1 mod 2r + 4, j ← j + 1 mod c;
9.    RETURN W .


          Т а б л и ц а 8.1. «Магические» числа для RC6
             w          16        32               64
             Pw        b7e1   b7e15163    b7e15162 8aed2a6b
             Qw        9e37   9e3779b9    9e3779b9 7f4a7c15

    Рассмотрим кратко основные идеи построения алгоритма шиф-
рования RC6. Заметим прежде всего, что, как и в шифрах DES и
ГОСТ 28147-89, в каждом раунде RC6 одна половина блока исполь-
зуется для шифрования другой. Действительно, значение перемен-
ных t и u (строки 3–4 алгоритма 8.2) определяется только словами
b и d соответственно. Затем эти переменные используются для мо-
дификации слов a и c перед сложением с элементами ключа (строки
5–6). Таким образом, в a и c вносится зависимость от b и d . В сле-
дующем раунде пары a, c и b, d меняются ролями, причем b и d
8.2. Блоковые шифры                                           167

переставляются между собой (строка 7 алгоритма). Вследствие та-
кой структуры шифра количество раундов должно быть четным.
    Выбранная для вычисления переменных t и u функция ви-
да f (x) = (2x2 + x) mod 2w характеризуется сильной зависимостью
старших бит своего значения от всех бит аргумента. Именно стар-
шие биты f должны определять величину сдвига в строках 5–6 алго-
ритма. Поэтому необходимое их количество переносится в младшие
разряды t и u посредством вращения ←֓ log w . При модификации
a и c использование «исключающего или» достаточно традицион-
но, тогда как зависимое от данных вращение (операция ←֓) — ха-
рактерная особенность RC6 (заимствованная у его более простого
предшественника RC5).
    Строки 1 и 8 алгоритма 8.2 скрывают значения слов, которые
не изменялись в ходе первого и последнего раундов.
    Рекомендуемое количество раундов r = 20 связано с результа-
тами исследования стойкости шифра по отношению к дифференци-
альному и линейному криптоанализу.
    В ходе исследований шифра слабых ключей не обнаружено, т.е.
любой ключ, даже нулевой, обеспечивает заявляемую высокую стой-
кость шифра. Предполагается, что для RC6 не существует алгоритма
взлома, лучшего, чем перебор ключей.

Шифр Rijndael (AES)
Авторами шифра Rijndael (читается «Рейндал») являются бельгий-
ские специалисты В. Рейман (Vincent Rijmen) и Й. Даман (Joan Dae-
men). Этот шифр победил в упомянутом выше конкурсе AES и в 2001
году был принят в качестве нового стандарта США. Возможно, он
будет играть такую же важную роль в практической криптографии,
какая на протяжении десятилетий принадлежала DES. Rijndael за-
метно сложнее для описания, чем RC6 и ГОСТ 28147-89, хотя его
компьютерная реализация достаточно эффективна. Мы представим
только основную идею построения шифра. Детальное описание и
примеры реализации Rijndal даны в [21, 25].
    Шифр Rijndael/AES характеризуется размером блока 128 бит,
длиной ключа 128, 192 или 256 бит и количеством раундов 10, 12 или
14 в зависимости от длины ключа.
    Договоримся об основных обозначениях. Под словом будем по-
нимать последовательность из четырех байт (32 бита). Байты в слове
168           Глава 8. Современные шифры с секретным ключом

нумеруются с 0 (младший байт) по 3 (старший байт). Блок данных
состоит из четырех слов, которые нумеруются также с 0 по 3. Для
упрощения обозначений условимся, что номера байтов в слове и слов
в блоке всегда приводятся по модулю 4 без явного указания на это.
Блок данных рассматривается как матрица размером 4 × 4 байта,
причем слова соответствуют не строкам (как это обычно принято),
а столбцам. Например X2,3 обозначает второй байт третьего слова
блока X . Однако запись с одним индексом обозначает слово, напри-
мер, X3 — третье слово блока. Мы будем следовать этому соглаше-
нию, чтобы не менять связанной с ним терминологии Rijndael.
    Для выполнения преобразований в блоке используется раундо-
вый ключ W , получаемый из секретного ключа K . Размер секрет-
ного ключа l определяет общее число раундов шифра r :

                      l = 128    ⇒ r = 10,
                      l = 192    ⇒ r = 12,
                      l = 256    ⇒ r = 14.

Раундовый ключ состоит из блоков (по 128 бит), количество которых
равно числу раундов плюс 1,

                      W = W0 , W1 , . . . , Wr .

    В основу разработки Rijndael были положены три критерия:
стойкость по отношению ко всем известным атакам, скорость и ком-
пактность кода, простота дизайна. В отличие от предыдущих рас-
смотренных нами шифров, Rijndael не использует какой-либо ана-
лог структуры Фейстела. Каждый раунд состоит из трех различных
обратимых преобразований, называемых слоями:

  1) линейный смешивающий слой гарантирует высокую степень
     взаимопроникновения символов блока для маскировки стати-
     стических связей;

  2) нелинейный слой реализован с помощью S-боксов, имеющих
     оптимальную нелинейность, и предотвращает возможность ис-
     пользования дифференциального, линейного и других совре-
     менных методов криптоанализа;

  3) слой сложения с ключом выполняет непосредственно шифро-
     вание.
8.2. Блоковые шифры                                           169

    Шифр начинается и заканчивается сложением с ключом. Это
позволяет закрыть вход первого раунда при атаке по известному
тексту и сделать криптографически значимым результат последнего
раунда.


Алгоритм 8.5. Rijndael: шифрование блока
ВХОД:    Блок X , раундовый ключ W .
ВЫХОД: Блок Y .
 1.   Y ← X ⊕ W0 ;
 2.   FOR i = 1, 2, . . . , r − 1 DO
 3.      Y ← SubBytes(Y ),
 4.      Y ← ShiftRows(Y ),
 5.      Y ← MixColumns(Y ),
 6.      Y ← Y ⊕ Wi ;
 7.   Y ← SubBytes(Y ),
 8.   Y ← ShiftRows(Y ),
 9.   Y ← Y ⊕ Wr ;
10.   RETURN Y .

    Процедура SubBytes (замена байтов) реализует слой нелинейно-
го преобразования. Две другие процедуры ShiftRows (сдвиг строк)
и MixColumns (перемешивание столбцов) представляют линейный
смешивающий слой. Слой сложения с ключом реализован с помо-
щью побитового «исключающего или» ⊕.
    Обратим внимание на то, что в последнем раунде отсутствует
преобразование MixColumns. На первый взгляд это кажется стран-
ным решением, ухудшающим структуру шифра. Но это не так. Обо-
значим шаги с 3 по 6 алгоритма соответственно через B, R, C и K, и
запишем всю последовательность действий в виде линейной цепочки:
                  KBRCKBRCK · · · BRCKBRK.                   (8.8)
Чтобы расшифровать блок, нужно выполнить все действия в обрат-
ном порядке, используя обратные операции. Как будет показано ни-
же, преобразования B и R можно поменять местами без изменения
результата, преобразования C и K также можно поменять местами
при условии некоторого изменения раундового ключа. При выполне-
нии такой перестановки последовательность (8.8) запишется в виде
                  KRBKCRBKC · · · RBKCRBK.                   (8.9)
170            Глава 8. Современные шифры с секретным ключом

Последовательность (8.9), прочитанная справа налево, теперь точ-
но совпадает с (8.8). Это означает, что блок можно дешифровать,
используя ту же последовательность действий, что и при его шиф-
ровании. Здесь важно то, что, как будет показано ниже, последо-
вательность действий BRCK может быть эфективно реализована с
помощью табличных вычислений, причем все необходимые таблицы
задаются константно, т.е. не зависят ни от ключа, ни от данных. Сей-
час мы перейдем непосредственно к описанию преобразований BRC,
хотя в интересах практической реализации шифра Rijndael можно
просто использовать табличные алгоритмы, приведенные ниже, и не
вдаваться в подробности выполнения преобразований.
      Чтобы понять, как выполняются преобразования блока в шифре
Rijndael, необходимо освоить арифметику полиномов (см., например,
[9]).
      Каждый байт данных рассматривается как полином с коэффи-
циентами 0 и 1, действия с коэффициентами производятся по модулю
2. Например,
                     10010011 = x7 + x4 + x + 1,
                 10010011 + 01010001 = 11000010,
                 10010011 · 00000010 = 100100110.
В шифре Rijndael полиномы-байты умножаются по модулю полино-
ма m(x) = x8 + x4 + x3 + x + 1. Например,

10010011 · 00000010 mod m(x) = 100100110 − 100011011 = 000111101

(вычитание по модулю 2 эквивалентно сложению). Выбранный поли-
ном m(x) нельзя представить как произведение других полиномов с
двоичными коэффициентами (это аналог простого числа в арифме-
тике полиномов). В результате любой полином a(x) 6= 0 имеет ин-
версию, т.е. полином a−1 (x), такой, что a(x) · a−1 (x) mod m(x) = 1
(инверсия вычисляется с помощью обобщенного алгоритма Евклида,
в котором все числа заменены на полиномы). На языке теории групп
говорят, что в этом случае полиномы-байты образуют поле F28 .
    Каждое слово данных представляется уже как полином с коэф-
фициентами в F28 . Например,

                0x7500a302 = (0x75)x3 + (0xa3)x + 2

(префикс 0x означает запись числа в шестнадцатиричной системе).
8.2. Блоковые шифры                                                 171

    Преобразование SubBytes(Y ) действует независимо на каждый
байт b в Y :
 b(x) ← b−1 (x) mod m(x)    (0 ← 0),
                                                        
 b(x) ← (x7 + x6 + x5 + x4 + 1)b(x) + (x7 + x6 + x2 + x) mod (x8 + 1).
Результаты этого преобразования, заранее подсчитанные для каж-
дого байта от 0 до 255, заносятся в таблицу S. Тогда преобразование
SubBytes(Y ) сводится к выполнению для каждого байта b в Y опе-
рации
                              b ← S[b].
Содержимое таблицы S в явном виде приведено в [21].
     Преобразование ShiftRows(Y ) действует на каждую строку ri в
Y , т.е. на i-ю (i = 0, 1, 2, 3) последовательность байт слов блока, по
правилу
                                 ri ← ri ←֓ i
(операция ←֓ означает циклический сдвиг влево на указанное число
байт).
     Преобразование MixColumns(Y ) действует на каждый столбец
ci в блоке Y , т.е. на каждое машинное слово, i = 0, 1, 2, 3, по правилу
                   ci (x) ← a(x) · ci (x) mod (x4 + 1),
где a(x) = 3x3 + x2 + x + 2. Эта     операция может быть записана в
матричном виде
                                                     
                   c0,i       2      3   1   1     c0,i
                  c1,i     1      2   3   1   c1,i   
                  c2,i  ←  1
            ci =                            ·        .      (8.10)
                                     1   2   3   c2,i   
                   c3,i       3      1   1   2     c3,i
     Очевидно, что операцию SubBytes можно поменять местами с
ShiftRows, не изменяя результат, так как эти преобразования воз-
действуют только на индивидуальные байты. Далее, используя дис-
трибутивность умножения полиномов можем записать
    MixColumns(Y ⊕ Wi ) = MixColumns(Y ) ⊕ MixColumns(Wi ).
Таким образом, MixColumns и сложение с ключом также можно по-
менять местами при условии, что соответствующие блоки раундово-
го ключа (кроме первого и последнего) были предварительно под-
вергнуты обратному преобразованию MixColumns−1 (Wi ). Все это
172               Глава 8. Современные шифры с секретным ключом

служит обоснованием идентичности последовательностей действий
(8.8) и (8.9) с модифицированным ключом. В результате получаем
следующий алгоритм обратного шифра.


Алгоритм 8.6. Rijndael: дешифрование блока
ВХОД:   Блок Y , раундовый ключ W .
ВЫХОД: Блок X .
 1.   X ← Y ⊕ Wr ;
 2.   FOR i = r − 1, r − 2, . . . , 1 DO
 3.      X ← SubBytes−1 (X),
 4.      X ← ShiftRows−1 (X),
 5.      X ← MixColumns−1 (X),
 6.      X ← X ⊕ Wi ;
 7.   X ← SubBytes−1 (X),
 8.   X ← ShiftRows−1 (X),
 9.   X ← X ⊕ W0 ;
10.   RETURN X .

    Обратные преобразования, использованные в алгоритме, опре-
деляются естественным образом.
    Преобразование SubBytes−1 (X) действует на каждый байт b в
X:
      b(x) ← (b(x) − (x7 + x6 + x2 + x))(x7 + x5 + x2 ) mod (x8 + 1),
      b(x) ← b−1 (x) mod m(x)    (0 ← 0),

где x7 +x5 +x2 = (x7 +x6 +x5 +x4 +1)−1 mod (x8 +1) . Результаты этого
преобразования заносятся в таблицу S−1 . Содержимое таблицы S−1
в явном виде приведено в [21].
     Преобразование ShiftRows−1 (X) действует на каждую строку
ri в X по правилу
                             ri ← ri ֒→ i
(операция ֒→ означает циклический сдвиг вправо на указанное чис-
ло байт).
    Преобразование MixColumns−1 (X) действует на каждый стол-
бец ci в блоке X по правилу

                   ci (x) ← a−1 (x) · ci (x) mod (x4 + 1),
8.2. Блоковые шифры                                                   173

где a−1 (x) = 11x3 + 13x2 + 9x + 14 . То   же самое в матричной записи
выглядит так:
                                                        
               c0,i        14 11 13        09     c0,i
              c1,i     09 14 11         13   c1,i       
        ci = 
              c2,i  ←  13 09 14
                                            ·            .    (8.11)
                                           11   c2,i       
               c3,i        11 13 09        14     c3,i
     Теперь перейдем к эффективной табличной реализации шифра
на компьютере с длиной слова 32 бита. Обозначим текущее состоя-
ние блока через U . Последовательность шагов 3–6 алгоритма шиф-
рования переводит блок данных из состояния U в новое состояние
Y . С учетом характера преобразований, выполняемых на шагах 3–6,
мы можем записать, как вычисляется каждое j -е слово (т.е. каждый
столбец) в Y :
                                                    
         Y0,j       2 3 1 1          S[U0,j ]      Wi,0,j
        Y1,j   1 2 3 1   S[U1,j−1 ]   Wi,1,j 
        Y2,j  =  1 1 2 3  ·  S[U2,j−2 ]  ⊕  Wi,2,j 
                                                    

         Y3,j       3 1 1 2         S[U3,j−3 ]     Wi,3,j
(самый правый столбец в выражении — это j -е слово Wi ). Раскры-
вая матричное умножение, получаем
                                                         
                    2                    3                    1
                   1                  2                  3 
  Yj = S[U0,j ] · 
                   1  ⊕ S[U1,j−1 ] ·  1  ⊕ S[U2,j−2 ] ·  2  ⊕
                                                          

                    3                    1                    1
                                                             
                                                              1
                                                             1 
                                             ⊕ S[U0,j−3 ] · 
                                                             3  ⊕ Wi,j .
                                                                

                                                              2
Определим четыре таблицы
                                                          
                      S[b] · 2                    S[b] · 3
                     S[b]                      S[b] · 2   
           T0 [b] = 
                                 , T1 [b] =               ,
                       S[b]                      S[b]      
                      S[b] · 3                     S[b]
                                                          
                       S[b]                        S[b]
                     S[b] · 3                   S[b]      
           T2 [b] = 
                     S[b] · 2
                                  , T3 [b] =               .
                                                S[b] · 3   
                       S[b]                       S[b] · 2
174               Глава 8. Современные шифры с секретным ключом

Каждая таблица строится для b , пробегающего значения от 0 до 255,
и состоит из 256 четырехбайтовых слов. Операция умножения при
вычислении таблиц — это умножение полиномов по модулю m(x).
Таблицы T не зависят ни от ключа, ни от данных и могут быть сфор-
мированы заранее. С использованием этих таблиц j -е слово блока
вычисляется следующим образом:


      Yj = T0 [U0,j ] ⊕ T1 [U1,j−1 ] ⊕ T2 [U2,j−2 ] ⊕ T3 [U3,j−3 ] ⊕ Wi,j .


   Сейчас мы готовы записать алгоритм шифрования в табличной
форме.


Алгоритм 8.7. Rijndael: шифрование блока
              (быстрый вариант)


ВХОД:    Блок X , раундовый ключ W .
ВЫХОД: Блок Y .
 1.   U ← X ⊕ W0 ;
 2.   FOR i = 1, 2, . . . , r − 1 DO
 3.      FOR j = 0, 1, 2, 3 DO
 4.         Yj ← T0 [U0,j ] ⊕ T1 [U1,j−1 ] ⊕ T2 [U2,j−2 ] ⊕
                                              ⊕ T3 [U3,j−3 ] ⊕ Wi,j ;
 5.      U ←Y;
 6.   FOR i = 0, 1, 2, 3 DO
 7.      FOR j = 0, 1, 2, 3 DO
 8.         Yi,j ← S[Ui,j−i ];
 9.   Y ← Y ⊕ Wr ;
10.   RETURN Y .


    Заметим, что S-боксы в большом количестве содержатся в таб-
лицах T. Например, в качестве S-бокса на шаге 8 можно использо-
вать младшие байты таблицы T2 .
    Чтобы построить табличный алгоритм для обратного шифра,
нужно повторить рассуждения, приведенные выше, по отношению
к обратным преобразованиям. В результате мы получаем обратные
8.2. Блоковые шифры                                                        175

таблицы T−1 :
                                                                   
                      S−1 [b] · 14                     S−1 [b] · 11
                     S−1 [b] · 9                    S−1 [b] · 14   
         T−1
          0 [b] = 
                                     , T−1 [b] =                   ,
                      S−1 [b] · 13       1           S−1 [b] · 9    
                      S−1 [b] · 11                     S−1 [b] · 13
                                                                   
                      S−1 [b] · 13                     S−1 [b] · 9
                     S−1 [b] · 11                   S−1 [b] · 13   
         T−1
          2 [b] = 
                                     , T−1 [b] =                   .
                      S−1 [b] · 14       3           S−1 [b] · 11   
                      S−1 [b] · 9                      S−1 [b] · 14


Алгоритм 8.8. Rijndael: дешифрование блока
              (быстрый вариант)
ВХОД:    Блок Y , раундовый ключ W .
ВЫХОД: Блок X .
 1.   U ← Y ⊕ W0 ;
 2.   FOR i = r − 1, r − 2, . . . , 1 DO
 3.      FOR j = 0, 1, 2, 3 DO
 4.         Xj ← T−1                  −1           −1
                       0 [U0,j ] ⊕ T1 [U1,j+1 ] ⊕ T2 [U2,j+2 ] ⊕
                                                   −1
                                                ⊕T3 [U3,j+3 ] ⊕ Wi,j ;
 5.      U ← X;
 6.   FOR i = 0, 1, 2, 3 DO
 7.      FOR j = 0, 1, 2, 3 DO
 8.         Xi,j ← S−1 [Ui,j+i ];
 9.   X ← X ⊕ Wr ;
10.   RETURN X .

    Последнее, что нам осталось рассмотреть, это процесс форми-
рования раундового ключа. В прямом и обратном шифре нам было
удобно делить раундовый ключ W на блоки по четыре слова. Од-
нако формирование ключа проходит в пословном режиме, поэтому
условимся обозначать буквой w с индексом отдельное слово в W ,
нумеруя слова с нуля. Как следует из описания шифра, раундовый
ключ W должен состоять из r + 1 блоков, где r — количество раун-
дов в шифре. Поэтому количество слов в W равно 4(r + 1) . Число
же слов в секретном ключе K , которое будем обозначать через c,
равно 4, 6 или 8. Вначале опишем алгоритм построения W , затем
дадим некоторые пояснения.
176           Глава 8. Современные шифры с секретным ключом

Алгоритм 8.9. Rijndael: формирование раундового
              ключа
ВХОД:   Секретный ключ K из c слов.
ВЫХОД: Раундовый ключ W из 4(r + 1) слов.
1.    W ← K (c слов);
2.    FOR i = c, c + 1, . . . , 4(r + 1) − 1 DO
3.       t ← wi−1 ;
4.      IF i mod c = 0 THEN
5.          t ← SubWord(RotWord(t)) ⊕ Rcon[i div c];
6.      ELSE IF c = 8 AND i mod c = 4 THEN
7.          t ← SubWord(t) ;
8.       wi ← wi−c ⊕ t ;
9.    RETURN w0 · · · w4(r+1)−1 .

    В данном алгоритме SubWord(t) — функция, применяющая S-
бокс шифра к каждому байту слова t

              [t0 , t1 , t2 , t3 ] −→ [S[t1 ], S[t2 ], S[t3 ], S[t0 ]].

Преобразование RotWord(t) осуществляет циклический сдвиг слова
t на один байт влево

                     [t0 , t1 , t2 , t3 ] −→ [t1 , t2 , t3 , t0 ].

Массив раундовых констант Rcon состоит из слов

                           Rcon[i] = [yi , 0, 0, 0],

где
                           yi = xi−1 mod m(x).
    Выбранный метод построения раундового ключа должен способ-
ствовать решению следующих задач:
  1) затруднить атаки на шифр при частично известном секретном
     ключе или при использовании зависимых (связанных общими
     правилами построения) ключей;
  2) устранить имеющиеся симметрии внутри раунда шифра и меж-
     ду раундами (для этого используется массив раундовых кон-
     стант Rcon).
8.3. Основные режимы функционирования блоковых шифров           177

    Как отмечалось при рассмотрении обратного шифра, чтобы по-
лучить раундовый ключ для дешифрования, необходимо подверг-
нуть преобразованию MixColumns−1 блоки W c первого по предпо-
следний.

8.3.   Основные режимы функционирования
       блоковых шифров
Блоковые шифры применяются для решения многих задач крипто-
графии. В этом разделе мы рассмотрим основные режимы их ис-
пользования.
    В предыдущем разделе были даны примеры реальных блоковых
шифров. Теперь мы можем думать о (идеализированном) блоковом
шифре, как о преобразовании входного блока X в выходной блок Y
с участием секретного ключа K ,

                            Y = EK (X),

причем это преобразование должно иметь следующие свойства:
  1) при известном Y , но неизвестном K практически невозможно
     узнать X ;
  2) при произвольных известных X и Y , но неизвестном K прак-
     тически невозможно узнать K .
    Вначале рассмотрим классическую задачу шифрования сообще-
ний при помощи блоковых шифров.

Режим ECB
Название режима ECB (Electronic CodeBook) можно перевести как
электронная кодовая книга.
    Сообщение X разбивается на блоки X = X1 , X2 , . . . , Xt . Каж-
дый блок шифруется блоковым шифром

                     Yi = EK (Xi ),     1 ≤ i ≤ t.

Получаем зашифрованное сообщение Y = Y1 , Y2 , . . . , Yt . Дешифро-
вание выполняется по правилу
                            −1
                     X i = EK  (Yi ),   1 ≤ i ≤ t.
178            Глава 8. Современные шифры с секретным ключом

     Нетрудно видеть, что дешифрование сообщения можно произ-
водить, выбирая блоки шифротекста в произвольном порядке. Такой
режим удобен во многих реальных ситуациях. Например, можно ра-
ботать с базой данных, хранящейся в зашифрованном виде. Однако
при таком использовании одинаковые записи будут зашифрованы
одинаково. Говорят, что в режиме ECB шифр сохраняет «образ дан-
ных», т.е. некий «рисунок» или шаблон, характерный для данных.
Это может дать некоторую информацию противнику. Например, ес-
ли количество различных записей в базе данных невелико (что неред-
ко случается), то противник может составить словарь шифротекстов
и вскрыть базу на основе частотного анализа. Заметим, что ему в
этом случае не понадобится вскрывать сам шифр.
     Некоторые авторы рекомендуют использовать режим ECB толь-
ко в случаях, когда размер отдельного элемента данных в сообщении,
к которому требуется осуществлять непосредственный (прямой) до-
ступ, меньше размера блока. Остаток блока, свободный от данных,
рекомендуется заполнять случайно выбираемыми битами. Тогда да-
же одинаковые элементы данных будут иметь разные шифротексты.
При дешифровании биты заполнения просто отбрасываются.
     Если размер элемента данных превышает размер блока, то часто
рекомендуют использовать режим CBC.

Режим CBC
Название режима CBC (Cipher-Block Chaining) переводится как сцеп-
ление блоков шифра.
    Зашифрованное сообщение получается по следующему правилу:

                 Yi = EK (Xi ⊕ Yi−1 ),    1 ≤ i ≤ t,

т.е. каждый последующий блок открытого текста предварительно за-
крывается предыдущим зашифрованным блоком. Слово Y0 должно
быть определено заранее и известно при шифровании и дешифро-
вании. Полученное зашифрованное сообщение можно дешифровать
следующим образом:
                              −1
                 Xi = Yi−1 ⊕ EK  (Yi ),   1 ≤ i ≤ t.

    Мы получаем шифротекст, в котором каждый следующий блок
зависит от предыдущих. Данный режим разрушает «образ данных».
8.4. Потоковые шифры                                                      179

Даже если все блоки X идентичны, шифротекст будет состоять из
различных блоков Y . Этот режим предпочтителен при шифрова-
нии сообщений, размер которых превышает размер блока. Однако
дешифровать сообщение можно только последовательно, начиная с
первого блока.


8.4.    Потоковые шифры
В главе 7 мы рассмотрели шифр Вернама и установили, что он яв-
ляется совершенно секретным, т.е. при его использовании против-
ник, перехвативший зашифрованное сообщение, не получает ника-
кой информации об исходном сообщении. В шифре Вернама зашиф-
рованное сообщение y1 , y2 , . . . , yk получается из исходного сообще-
ния x1 , x2 , . . . , xk и ключа z1 , z2 , . . . , zk при помощи операции шиф-
рования, задаваемой равенством

                       yi = xi ⊕ zi ,   i = 1, 2, . . . , k.           (8.12)

    Мы видели, что данный шифр совершенен только в том случае,
если ключ z1 , z2 , . . . , zk образован из независимых и равновероятных
символов и используется только один раз. Это приводит к необходи-
мости генерировать случайные последовательности очень большого
объема и передавать их по закрытым каналам связи, что весьма за-
труднительно. Поэтому давно была высказана идея использовать в
качестве ключа последовательности не случайные, а порожденные
при помощи генераторов псевдослучайных чисел. В этом случае в
качестве секретного ключа используется начальное значение или со-
стояние генератора. Однако надо четко осознавать, что в этом слу-
чае система уже не будет совершенно секретной. Максимум на что
мы можем надеяться, это то, что для раскрытия этой системы по-
требуется очень много времени (например, нужно будет выполнить
перебор всех возможных начальных состояний генератора). В ка-
честве возмещения за потерю совершенности мы получаем возмож-
ность использовать короткие (обычно несколько сотен бит) секрет-
ные ключи, которые значительно проще распределять и хранить (а
при использовании систем с открытым ключом их можно и вычис-
лять).

    Определение 8.1. Шифр, построенный на основе (8.12), где в
180             Глава 8. Современные шифры с секретным ключом

качестве z1 , z2 , . . . , zk используется псевдослучайная последователь-
ность, называется потоковым шифром (stream cipher).

      Как правило, исходное сообщение и ключевая последователь-
ность представляют собой независимые потоки бит. Так как шифру-
ющее (и дешифрующее) преобразование для всех потоковых шифров
одно и то же, они различаются только способом построения генерато-
ров псевдослучайных чисел. Действительно, чтобы из шифротекста
y1 , y2 , . . . , yk , полученного по формуле (8.12), восстановить сообще-
ние x1 , x2 , . . . , xk , необходимо сгенерировать точно такую же после-
довательность z1 , z2 , . . . , zk , что и при шифровании, и использовать
для дешифрования формулу

                     xi = yi ⊕ zi ,    i = 1, 2, . . . , k.        (8.13)

    П р и м е р 8.1. Один из самых простых генераторов псевдослу-
чайных чисел (линейный конгруэнтный генератор) работает по схеме

                         zi+1 = (azi + b) mod c,                   (8.14)

где a, b , c — некоторые константы, а zi+1 — очередное псевдослу-
чайное число, вычисляемое по предыдущему zi . Обязательно зада-
ется начальное значение z0 . Возьмем в качестве примера a = 5,
b = 12, c = 23, и пусть z0 = 4. Вычислим несколько элементов
последовательности:

                    z1   =   (4 · 5 + 12) mod 23 = 9,
                    z2   =   (9 · 5 + 12) mod 23 = 11,
                    z3   =   (11 · 5 + 12) mod 23 = 21,
                    z4   =   (21 · 5 + 12) mod 23 = 2,
                    z5   =   (2 · 5 + 12) mod 23 = 22,
                    z6   =   (22 · 5 + 12) mod 23 = 7,
                    z7   =   (7 · 5 + 12) mod 23 = 1.

Полученная последовательность внешне выглядит как довольно слу-
чайная.                                                      ⊔
                                                             ⊓
    Для использования в криптографических целях генератор дол-
жен удовлетворять следующим основным требованиям:

  1) период последовательности должен быть очень большой;
8.4. Потоковые шифры                                                   181

  2) порождаемая последовательность должна быть «почти» неот-
     личима от действительно случайной, в частности, вычисление
     числа zi+1 по известным предыдущим элементам последова-
     тельности без знания ключа должно быть трудной, практиче-
     ски нерешаемой задачей.

    Рассмотренный выше линейный конгруэнтный генератор совер-
шенно не годится для криптографических целей, так как известны
простые алгоритмы, позволяющие полностью восстановить парамет-
ры генератора всего по нескольким элементам порождаемой им по-
следовательности.
    В качестве примеров криптостойких генераторов псевдослучай-
ных чисел мы рассмотрим режимы OFB и CTR блоковых шифров
и алгоритм RC4.

Режим OFB блокового шифра
Название режима OFB (Output FeedBack) переводится как обрат-
ная связь по выходу. В этом режиме блоковый шифр на основе
секретного ключа K и некоторого инициализирующего вектора Y0
формирует псевдослучайную последовательность r -битовых чисел
z1 , z2 , . . . , zk , которая может использоваться в (8.12) и (8.13) соот-
ветственно для шифрования и дешифрования сообщения. Будем счи-
тать, как и ранее, что размер блока шифра равен n бит.
      Псевдослучайная последовательность получается по схеме

                     Yi = EK (Yi−1 ),
                     zi = r старших бит Yi ,    1≤i≤k

(здесь r , 1 ≤ r ≤ n , — параметр метода).
    При использовании стойкого блокового шифра можно получить
криптостойкий генератор, отвечающий приведенным выше требова-
ниям. А именно, средняя длина периода псевдослучайной последо-
вательности (при случайно выбранных K и Y0 ) составляет пример-
но r2n−1 бит [28]. Кроме того, псевдослучайная последовательность
«непредсказуема» для противника, так как возможность предсказа-
ния (вычисления) zi+1 на основе z1 , . . . , zi означала бы нестойкость
шифра по отношению к атаке по известному тексту. Предсказание
zi+1 становится даже более трудной задачей, чем взлом блокового
шифра, если r < n [28].
182            Глава 8. Современные шифры с секретным ключом

     Обратим внимание на одну особенность, характерную для всех
потоковых шифров. Для шифрования каждого отдельного сообще-
ния необходимо использовать разные K и/или Y0 . В противном
случае несколько сообщений будут шифроваться с помощью одних
и тех же последовательностей z , и такой шифр может быть рас-
крыт. Поясним суть проблемы. Пусть два сообщения u1 , u2 , . . . , uk
и v1 , v2 , . . . , vk зашифрованы с помощью одной и той же последова-
тельности z . Тогда шифротексты будут иметь вид

                     u1 ⊕ z1 , u2 ⊕ z2 , . . . , uk ⊕ zk и
                     v1 ⊕ z1 , v2 ⊕ z2 , . . . , vk ⊕ zk .

Сложим оба шифротекста и, с учетом равенства zi ⊕zi = 0, получим
последовательность

                    u1 ⊕ v1 , u2 ⊕ v2 , . . . , uk ⊕ vk .

Мы получили аналог так называемого «шифра с бегущим ключом»,
когда один текст шифруется с помощью другого текста, взятого из
определенного места определенной книги. Известно, что такой шифр
не стоек, хотя использовался в эпоху «донаучной» криптографии
[28]. Статистический анализ, основанный на избыточности текстов,
позволяет в большинстве случаев достаточно точно восстановить оба
сообщения.
     Дешифрование сообщений для описанного режима блокового
шифра может производиться только с начала, так как невозможно
получить произвольный элемент последовательности z , не вычис-
лив предыдущие. В этом смысле режим аналогичен режиму CBC.
Преимущество режима OFB заключается в том, что последователь-
ность z может быть сформирована заранее для того, чтобы быстро
шифровать или дешифровать сообщения с помощью (8.12), (8.13)
в момент их поступления. Это может быть актуально для систем,
обрабатывающих данные в реальном масштабе времени.

Режим CTR блокового шифра
Название данного режима происходит от слова CounTeR — счетчик.
Этот режим очень похож на OFB, но в нем шифруется не преды-
дущий выход шифра, а просто счетчик, увеличиваемый на каждом
8.4. Потоковые шифры                                                 183

шаге на постоянное число (обычно 1). Точнее, схема выглядит сле-
дующим образом:

          zi = r старших бит EK (Y0 + i),     i = 1, 2, 3, . . . ,

где r — параметр.
    При использовании «идеального» блокового шифра режим CTR
обеспечивает те же параметры стойкости, что и OFB. Преимущество
режима CTR состоит в том, что любой элемент последовательно-
сти z может быть вычислен непосредственно. Это дает возможность
шифровать и дешифровать любые фрагменты сообщения независи-
мо друг от друга.

Алгоритм RC4
Алгоритм RC4, предложенный Ривестом в 1994 году, относится к
классу алгоритмов, разработанных специально для потоковых шиф-
ров. Генераторы псевдослучайных чисел, построенные с помощью
таких алгоритмов, как правило, значительно быстрее генераторов,
основанных на блоковых шифрах.
     Алгоритм RC4 работает с n -битовыми словами (обычно n =
8 ). Все вычисления проводятся по модулю 2n (остаток x mod 2n
вычисляется очень быстро путем выделения n младших бит в x
с помощью логической операции «и»). RC4 использует L-словный
ключ K = K0 K1 . . . KL−1 и генерирует последовательность слов
z̄ = z1 z2 z3 . . . , конкретный вид которой определяется ключом K .
Состояние генератора задается таблицей S из 2n слов и двух пере-
менных i и j . В каждый момент времени таблица S содержит все
возможные n -битовые числа в перемешанном виде. Так как каждый
элемент таблицы принимает значения в промежутке [0, 2n − 1], то
его можно трактовать двояко: либо как число, либо как номер дру-
гого элемента в таблице. Секретный ключ задает только начальное
перемешивание чисел в таблице, которое формируется с помощью
следующего алгоритма:

       j ← 0, S ← (0, 1, . . . , 2n − 1);
       FOR i = 0, 1, . . . , 2n − 1 DO
          j ← (j + Si + Ki mod L ) mod 2n ,
          Sj ↔ Si ;
       i ← 0, j ← 0 .
184                    Глава 8. Современные шифры с секретным ключом

После этого генератор готов к работе. Генерация очередного псевдо-
случайного слова zi осуществляется следующим образом:

          i ← (i + 1) mod 2n ;
          j ← (j + Si ) mod 2n ;
          S j ↔ Si ;
          t ← (Si + Sj ) mod 2n ;
          zi ← S t .

   П р и м е р 8.2. Пусть n = 3, K = 25 (L = 2 ).
   Сформируем начальную перестановку чисел в таблице S (все
вычисления проводим по модулю 8):

                        j   = 0,             S = (0, 1, 2, 3, 4, 5, 6, 7),
              i = 0,    j   = 0 + 0 + 2 = 2, S = (2, 1, 0, 3, 4, 5, 6, 7),
              i = 1,    j   = 2 + 1 + 5 = 0, S = (1, 2, 0, 3, 4, 5, 6, 7),
              i = 2,    j   = 0 + 0 + 2 = 2, S = (1, 2, 0, 3, 4, 5, 6, 7),
              i = 3,    j   = 2 + 3 + 5 = 2, S = (1, 2, 3, 0, 4, 5, 6, 7),
              i = 4,    j   = 2 + 4 + 2 = 0, S = (4, 2, 3, 0, 1, 5, 6, 7),
              i = 5,    j   = 0 + 5 + 5 = 2, S = (4, 2, 5, 0, 1, 3, 6, 7),
              i = 6,    j   = 2 + 6 + 2 = 2, S = (4, 2, 6, 0, 1, 3, 5, 7),
              i = 7,    j   = 2 + 7 + 5 = 6, S = (4, 2, 6, 0, 1, 3, 7, 5).

Теперь вычислим несколько первых элементов псевдослучайной по-
следовательности z̄ :

 i = 1,   j   = 0 + 2 = 2,      S   = (4, 6, 2, 0, 1, 3, 7, 5),   t = 2 + 6 = 0,   z1   = 4,
 i = 2,   j   = 2 + 2 = 4,      S   = (4, 6, 1, 0, 2, 3, 7, 5),   t = 1 + 2 = 3,   z2   = 0,
 i = 3,   j   = 4 + 0 = 4,      S   = (4, 6, 1, 2, 0, 3, 7, 5),   t = 2 + 0 = 2,   z3   = 1,
 i = 4,   j   = 4 + 0 = 4,      S   = (4, 6, 1, 2, 0, 3, 7, 5),   t = 0 + 0 = 0,   z4   = 4,
 i = 5,   j   = 4 + 3 = 7,      S   = (4, 6, 1, 2, 0, 5, 7, 3),   t = 5 + 3 = 0,   z5   = 4,
 i = 6,   j   = 7 + 7 = 6,      S   = (4, 6, 1, 2, 0, 5, 7, 3),   t = 7 + 7 = 6,   z6   =7

и т.д. Чтобы воспользоваться формулой (8.12) для получения шиф-
ра, числа zi записываем в двоичном виде. В рассмотренном примере
каждое число zi представляется тремя битами, и мы получаем по-
следовательность

                   z̄ = 1 0 0 0 0 0 0 0 1 1 0 0 1 0 0 1 1 1 . . .                              ⊔
                                                                                               ⊓
8.5. Криптографические хеш-функции                                  185

8.5.   Криптографические хеш-функции
Мы уже встречались с понятием хеш-функции (hash function) в гла-
ве 4 при рассмотрении методов генерации электронной подписи. Там
хеш-функции использовались в качестве «представителей» подпи-
сываемых сообщений, т.е. подпись реально вычислялась только для
значения хеш-функции, но предполагалось, что это значение суще-
ственным образом зависит от всех символов сообщения и никто не
может изменить сообщение так, чтобы это значение сохранилось. В
этом разделе мы более точно сформулируем основные требования
к криптографически стойким хеш-функциям и рассмотрим один из
способов их вычисления.
    Определение 8.2. Хеш-функцией называется любая функция

                           y = h(x1 x2 . . . xn ),

которая строке (сообщению) x1 x2 . . . xn произвольной длины n ста-
вит в соответствие целое число фиксированной длины.
    Примером хеш-функции может служить контрольная сумма для
сообщения. В этом случае

            h(x1 x2 . . . xn ) = (x1 + x2 + . . . + xn ) mod 2w ,

где w — размер машинного слова. Длина слова, получаемого как
значение этой хеш-функции, составляет w бит независимо от длины
сообщения. Контрольные суммы очень часто используются для об-
наружения непреднамеренных ошибок в сообщении (при изменении
одного символа контрольная сумма изменится). Однако очень легко
внести преднамеренную ошибку в сообщение и сохранить при этом
значение контрольной суммы. Если бы такая хеш-функция исполь-
зовалась, например, при генерации электронной подписи, то было бы
очень легко изменить содержание подписанного сообщения. Поэто-
му рассмотренная хеш-функция не годится для криптографических
применений.
    Сформулируем основные требования, предъявляемые к крипто-
графическим хеш-функциям. Пусть x — некоторая строка (сообще-
ние). Тогда
  1) для любого заданного x вычисление h(x) должно выполняться
     относительно быстро;
186           Глава 8. Современные шифры с секретным ключом

  2) при известном y должно быть трудно (практически невозмож-
     но) найти x, для которого y = h(x);

  3) при известном сообщении x должно быть трудно найти другое
     сообщение x′ 6= x, такое, что h(x′ ) = h(x);

  4) должно быть трудно найти какую-либо пару различных сооб-
     щений x и x′ , для которых h(x′ ) = h(x).

    Отметим, что первое требование должно выполняться всегда,
в противном случае хеш-функция теряет какое-либо практическое
значение. Остальные требования важны для тех или иных прило-
жений. Например, если пароли для входа в систему хранятся в виде
значений соответствующих им хеш-функций, то хеш-функция долж-
на удовлетворять второму требованию. В схеме электронной подписи
актуально третье требование. Четвертое требование важно в неко-
торых криптографических протоколах. Заметим, что четвертое тре-
бование более сильное, чем третье (т.е. при выполнении четвертого
автоматически выполняется и третье).
    Разработка хеш-функции, удовлетворяющей всем четырем тре-
бованиям — задача непростая. В настоящее время предложены и
практически используются хеш-функции (например, MD5, SHA-1,
RIPEMD-160 и др., см., например, [23, 28]), которые считаются от-
вечающими перечисленным выше требованиям (хотя это строго не
доказано). Описание этих и подобных им функций усложнено в де-
талях и громоздко. Мы рассмотрим универсальный способ построе-
ния хеш-функций на базе блоковых шифров, который представляет
практический интерес, хотя получаемые хеш-функции и не являют-
ся очень быстро вычислимыми. Именно такой подход использован в
российском стандарте на криптографическую хеш-функцию (ГОСТ
Р34.11-94 [7]).
    Пусть дан блоковый шифр E , который для заданного блока X
и ключа K формирует шифротекст Y ,

                          Y = EK (X).

    Мы представим два алгоритма, для которых длина слова, полу-
чаемого как значение хеш-функции, равна размеру блока в шифре,
но отметим, что известны конструкции, позволяющие получать хеш-
функции c длинами слов, кратными размеру блока.
8.5. Криптографические хеш-функции                                  187

    В первом алгоритме сообщение вначале представляется в ви-
де последовательности блоков X1 , X2 , . . . , Xn . Последний блок при
необходимости дополняется нулями, иногда в последний блок при-
писывают длину сообщения в виде двоичного числа. Значение хеш-
функции h получается как результат выполнения следующего ите-
рационного процесса:

       h ← 0;
       FOR i = 1, 2, . . . , n DO
          h ← Eh (Xi ) ⊕ Xi .

    В качестве начального значения h можно использовать не нуль,
а какое-либо «магическое» число, но это не имеет большого значе-
ния. В данном алгоритме значение h , полученное на предыдущей
итерации, используется в качестве ключа шифра в следующей ите-
рации. Поэтому неявно полагается, что длина ключа в шифре равна
длине блока. Однако, как мы видели при изучении шифра RC6, дли-
на ключа может значительно превышать размер блока (в RC6 при
максимальной длине блока 256 бит длина ключа может достигать
255 байт, или 2040 бит). В таких случаях более эффективен другой
алгоритм.
    В этом алгоритме сообщение вначале представляется в виде по-
следовательности X1 , X2 , . . . , Xm , в которой размер каждого элемен-
та равен длине ключа в шифре. Последний элемент заполняется так
же, как и в первом алгоритме. Значение хеш-функции h вычисляет-
ся следующим образом:

       h ← 0;
       FOR i = 1, 2, . . . , m DO
          h ← EXi (h) ⊕ h .
Здесь уже элементы сообщения выполняют роль ключей в шифре.
    Представленные алгоритмы вычисления хеш-функций удовле-
творяют всем четырем требованиям, предъявляемым к криптогра-
фическим хеш-функциям, в предположении стойкости используе-
мых блоковых шифров (см. [26, 28]).
Глава 9.    СЛУЧАЙНЫЕ ЧИСЛА В
            КРИПТОГРАФИИ




9.1.   Введение
Мы видели в предыдущих главах, что случайные и псевдослучай-
ные числа играют довольно важную роль в криптографии. Напри-
мер, при описании многих протоколов мы встречались с необходи-
мостью генерировать большие случайные числа или слова, исполь-
зуемые как секретные ключи. Вспомним также и шифр Вернама,
совершенная секретность которого базируется на том, что ключевая
последовательность состоит из равновероятных и независимых сим-
волов. Естественно, что задача генерирования последовательностей
случайных чисел представляет большой интерес для разработчиков
криптосистем. Более того, с развитием криптографии выяснилось,
что многие фундаментальные проблемы этой науки тесно связаны с
генерированием и тестированием случайных чисел. Например, воз-
можность построения надежных генераторов псевдослучайных чи-
сел связана с проблемой существования односторонних функций, а
одна из атак на блоковые шифры базируется на статистических те-
стах, предназначенных для выявления отклонений от случайности.
    В данной главе мы попытаемся познакомить читателя с основ-
ными задачами, идеями и методами, связанными с генерированием
и тестированием случайных чисел в криптографии. Мы начнем с
основного вопроса: что такое случайное число или, более общо, по-
следовательность случайных чисел? Пожалуй, первое, что приходит
в голову — это последовательность, полученная при помощи подбра-
сываний симметричной монеты, если ее стороны пометить, скажем,
нулем и единицей. Именно это определение, или, скорее понятие, и
взято за основное, «первичное». Более формально, в качестве слу-
чайных чисел в криптографии рассматриваются последовательности
из нулей и единиц, в которых появление символов независимо и их
вероятности равны. (Мы иногда для краткости будем называть такие
последовательности «абсолютно» случайными или просто случайны-
9.1. Введение                                                 189

ми, если это не будет приводить к путанице.) Другие случайные чис-
ла, скажем, целые числа из некоторого диапазона, легко получить
из последовательности случайных нулей и единиц и мы не будем
останавливаться на этом вопросе.
     Следущий вопрос, на котором мы остановимся — как генериро-
вать случайные числа? В «обычной» жизни люди иногда использу-
ют случайные числа, получая их путем подбрасывания монеты или
игральной кости, «вытягивания» игральной карты из колоды и т.п.
Очевидно, эти способы мало пригодны в криптосистемах, где тре-
буется производить большие последовательности случайных чисел
с высокой скоростью. Для этой цели можно использовать другие
физические процессы, обладающие высокой производительностью и
сравнительно легко сочетающиеся с компьютерными системами. На-
пример, в качестве физических процессов, содержащих «случайную»
составляющую, можно использовать шумы, возникающие в электри-
ческих цепях и их элементах, счетчики физических частиц, движе-
ния манипулятора-мыши в руке человека, работающего за компьюте-
ром, и т.д. и т.п. Одна из основных задач, возникающих при исполь-
зовании «физических» генераторов — преобразование порождаемых
ими последовательностей в абсолютно случайные. Она будет кратко
рассмотрена в следующем разделе.
     Пожалуй самый популярный способ получения случайных чи-
сел не связан с наблюдениями за каким-либо сложным физическим
процессом, а базируется на проведении вычислений, (например, как
в рассмотренном ранее потоковом шифре RC4). Получаемые таким
способом числа нызываются псевдослучайными, что подчеркивает
некоторое присущее им радикальное отличие от «истинно» случай-
ных чисел. Действительно, мы не можем предсказать значение «ис-
тинно» случайного числа (генерируемого, скажем, физическим дат-
чиком) до его появления, однако можем легко вычислить все значе-
ния, порождаемые псевдослучайным генератором. Это кардиналь-
ное различие легко видеть в случае генерирования ключа в системах
передачи информации: даже если передатчик и приемник использу-
ют идентичные физические генераторы для символов ключа, они не
получат одинаковые последовательности чисел (а если это малове-
роятное событие и произойдет, то они не узнают о его наступлении).
Поэтому-то и требуется передавать порожденную физическим гене-
ратором последовательность от передатчика к приемнику по защи-
щенному каналу. С другой стороны, используя одинаковые генера-
190                    Глава 9. Случайные числа в криптографии

торы псевдослучайных чисел, приемник и передатчик могут легко
получить одинаковые последовательности. В разд. 9.3 мы рассмот-
рим некоторые вопросы, связанные с псевдослучайными числами.
    К качеству случайных чисел, используемых в криптографии,
предъявляются высокие требования. Прежде всего, требуется ис-
ключить возможные статистические отклонения от эталона: вероят-
ности порождения нуля и единицы должны быть в точности равны
1/2 и генерируемые числа должны быть независимы. Для выявления
таких отклонений используются специальные статистические мето-
ды, или тесты, которых к настоящему времени разработано довольно
много. Так, Национальный институт стандартов и технологий США
(NIST) рекомендует 16 таких тестов для применения в криптосисте-
мах [29]. Мы также рассмотрим некоторые тесты в разд. 9.4.
    Как мы уже отмечали ранее, многие разделы криптографии
идейно связаны, причем иногда эти связи далеко не очевидны. При-
мер такой взаимосвязи дан в последнем разделе этой главы, где мы
опишем атаку на блоковые шифры, которая тесно связана со слу-
чайными числами и статистическими тестами.


9.2.   Задачи, возникающие при использовании
       физических генераторов случайных чисел

Мы будем считать, что физический генератор первоначально порож-
дает последовательность из нулей и единиц, которые, вообще говоря,
могут быть неравновероятны и/или зависимы. Такие последователь-
ности необходимо преобразовывать в равновероятные и независи-
мые и только после этого применять в криптосистемах. (Иногда та-
кое преобразование называется «очисткой» или «стандартизацией».)
При этом обычно рассматриваются отдельно методы преобразования
для двух случаев: в первом считают, что символы исходной последо-
вательности независимы, но, возможно, не равновероятны, а во вто-
ром случае предполагают, что символы могут быть и зависимы. Мы
рассмотрим только методы решения первой задачи, что объясняется
двумя причинами: во-первых, для многих физических генераторов
(скажем, базирующихся на оценке интенсивности какого-либо физи-
ческого процесса) показания, полученные в разные, непересекающи-
еся, интервалы времени, можно считать независимыми. Во-вторых,
известные методы преобразования зависимых последовательностей
9.2. Использование физических генераторов                       191

в независимые являются только приближенными — у них символы
получаемой последовательности только «почти» независимы. Кро-
ме того, авторам неизвестны примеры практического применения в
криптосистемах методов преобразования зависимых последователь-
ностей символов в независимые. Хотя отметим, что эта задача при-
влекает внимание многих исследователей и для ее решения предло-
жено много интересных и остроумных алгоритмов.
    Итак, в оставшейся части этого раздела мы рассмотрим методы
преобразования последовательностей независимых нулей и единиц,
вероятности порождения которых, возможно, не равны.
    Фон Нейман (John von Neumann) впервые рассмотрел эту зада-
чу и предложил первый алгоритм для ее решения. Для его описания
мы введем следующие обозначения: дан бернуллиевский источник,
порождающий символы из алфавита {0, 1} с вероятностями 1 − p
и p соответственно, 0 < p < 1, причем p может быть неизвестно.
Требуется преобразовать (или закодировать) порождаемую источ-
ником последовательность в такую, где вероятности появления нуля
и единицы равны, т.е. в абсолютно случайную.
    Фон Нейман предложил следующий метод: исходная последова-
тельность разбивается на блоки (слова) длины 2, которые кодиру-
ются по следующему правилу:
             00 → Λ,   01 → 0,   10 → 1,   11 → Λ,             (9.1)
где Λ обозначает пустое слово. Например, порождаемая последова-
тельность 00 01 11 10 00 00 01 будет трансформирована в абсолютно
случайную последовательность 010. Здесь первый нуль соответству-
ет второму блоку, т.е. 01, единица соответствует четвертому блоку, а
второй нуль — последнему блоку. Так как вероятности порождения
слов 01 и 10 совпадают (они равны p(1 − p) и (1 − p)p ), то, очевид-
но, в результате преобразования получается абсолютно случайная
последовательность.
     Из приведенного примера виден и недостаток метода, задавае-
мого правилом (9.1) — результирующая последовательность намного
короче исходной. Точнее, легко видеть, что из t исходных символов
получается последовательность из tp(1 − p) независимых символов.
Например, если p близко к 1/2, то из t символов в среднем получа-
ется t/4.
     Элайес (Peter Elias) предложил метод преобразования, более
экономно расходующий символы исходной последовательности, что
192                      Глава 9. Случайные числа в криптографии

достигается за счет перехода к кодированию блоков длины n , n > 2
(при n = 2 методы Элайеса и фон Неймана совпадают). Для ко-
личественной оценки эффективности метода Элайес ввел величи-
ну ηn , определяемую как отношение среднего значения длины по-
лучаемого кодового слова к длине блока n . Он показал, что есте-
ственной верхней границей для величины ηn является энтропия ис-
точника h(p), которая, напомним, определяется равенством h(p) =
−(p log p + (1 − p) log(1 − p)). (Впрочем, легко понять, что h(p) —
это максимально возможное значение отношения длин выходной и
входной последовательностей, так как, неформально, энтропия — это
мера неопределенности, или случайности исходной последовательно-
сти, с дугой стороны, энтропия выходной абсолютно случайной по-
следовательности равна ее длине, так как для нее энтропия одного
символа составляет 1 бит.)
     В методе Элайеса величина ηn приближается к энтропии Шен-
нона с ростом длины блока n , но при этом и сложность алгорит-
ма быстро возрастает. Точнее, объем используемой памяти растет
как 2n , что делает его практически неприменимым при длине блока
несколько десятков. В работе Б. Я. Рябко и Е. П. Мачикиной [32]
предложен метод, сложность которого существенно меньше — объем
требуемой памяти растет как n log2 n , что позволяет применять его
и при больших n . В этой же работе можно найти более подробное
описание метода Элайеса.

9.3.   Генераторы псевдослучайных чисел
Мы уже говорили о генераторах псевдослучайных чисел, когда рас-
сматривали потоковые шифры (разд. 8.4). Практически все исполь-
зуемые в криптографии генераторы псевдослучайных чисел могут
быть схематически представлены как некоторая функция от двух пе-
ременных F (s, i), где i — номер генерируемого случайного двоично-
го слова некоторой фиксированной длины, а s — параметр или сек-
ретный ключ, часто называемый «семенем» (seed). Обычно s — дво-
ичное слово, выбираемое случайно. Генерируемая псевдослучайная
последовательность образуется как цепочка двоичных слов F (s, 1),
F (s, 2), F (s, 3), . . . , F (s, k), где k — требуемая длина последова-
тельности. В разд. 8.4 были даны четыре примера таких генерато-
ров (линейный конгруэнтный, RC4 и получаемые при использовании
блоковых шифров в режимах OFB и CTR), поэтому мы не будем
9.3. Генераторы псевдослучайных чисел                                  193

рассматривать новые примеры, а сформулируем более точно требо-
вания, предъявляемые к генераторам.
    Любой генератор должен удовлетворять двум основным требо-
ваниям: во-первых, генерируемая псевдослучайная последователь-
ность должна быть статистически неотличима от абсолютно слу-
чайной и, во-вторых, знание какой-либо начальной части последо-
вательности (скажем, F (s, 1), F (s, 2), . . . , F (s, k − 1)) не должно
позволять предсказывать следующий бит этой последовательности
(точнее, наилучшее возможное предсказание должно быть таким:
"очередной бит последовательности с вероятностью 0.5 принимает
значение нуль и с вероятностью 0.5 — единица"). Здесь сразу следу-
ет отметить, что эти требования невыполнимы даже при неизвест-
ном значении слова s, если не ограничивать сложность тестов и ме-
тодов прогноза, измеряемую объемом памяти и/или временем вы-
числений. Для объяснения этого явления мы сначала заметим, что
представляют интерес только такие генераторы, у которых длина
выходной последовательности больше длины семени s (в противном
случае генератор был бы не нужен — можно было бы использовать
s как случайную последовательность). Теперь предположим, что да-
на последовательность бит z1 , z2 , . . . , zk , порожденная генератором,
причем ее длина ( k ) больше длины слова s. Тогда для предсказа-
ния следующего символа zk+1 можно поступить следующим обра-
зом: будем поочередно подавать на вход генератора всевозможные
значение ключа s (скажем, в лексикографическом порядке) и гене-
рировать первые k бит. Если полученные символы при некотором
s = u совпадают с z1 , z2 , . . . , zk , то значение ключа равно u (точнее,
это справедливо при выполнении некоторых естественных условий,
на которых мы не будем останавливаться, ограничившись нефор-
мальным рассмотрением). Естественно, при найденом ключе можно
вычислить следующий порождаемый символ zk+1 , т.е. однозначно
предсказать его значение.
    Таким образом, мы видим, что метод прямого перебора клю-
чей позволяет предсказать следующий бит последовательности, по-
рождаемой генератором псевдослучайных чисел, поэтому-то она и
не является «истинно» случайной. Однако время прямого перебо-
ра ключей пропорционально 2|s| , где, |s| — длина слова s и, оче-
видно, оно может быть сделано сколь угодно большим при увеличе-
нии |s|. (Это и определяет выбор длины ключа — время выполне-
ния 2|s| операций должно быть гигантским для лучших современ-
194                    Глава 9. Случайные числа в криптографии

ных компьютеров. В настоящее время |s| должна быть не меньше
нескольких сотен бит.) Поэтому в криптографии оба вышеупомяну-
тых требования к генераторам псевдослучайных чисел несколько мо-
дифицированы: генерируемая псевдослучайная последовательность
должна быть статистически неотличима от абсолютно случайной за
небольшое время вычислений и, во-вторых, знание какой-либо на-
чальной части последовательности не позволяет предсказать следу-
ющий бит этой последовательности за небольшое время вычислений
(здесь «большое время» обычно означает «требуются годы вычисле-
ний на суперкомпьютерах»).
    Для многих, если не для всех реально используемых генераторов
предполагается, что оба эти условия выполняются, но это предполо-
жение не доказано математически, а базируется на здравом смысле
и опыте (это относится, например, к RC4).
    С другой стороны, существует изящная теория, позволяющая
связать задачу генерирования псевдослучайных чисел с другими раз-
делами криптографии и с теорией сложности. В рамках этой тео-
рии «небольшое время вычислений» означает «вычисления, прово-
димые за полиномиальное время». Изложение этой теории может
быть найдено, например, в [26], а здесь мы только отметим ряд ос-
новных результатов. Во-первых, показано, что существуют генера-
торы псевдослучайных чисел, чьи последовательности не отличимы
от случайных за полиномиальное время любым тестом. Это, в част-
ности, означает, что такие последовательности можно использовать
как «истинно» случайные при решении любой задачи, требующей не
более чем полиномиальное время вычислений. Во-вторых, показано
что оба требования, предъявляемые к генерируемым последователь-
ностям (статистическая неотличимость от абсолютно случайной по-
следовательности и непредсказуемость), эквивалентны. В-третьих,
установлена связь между генераторами псевдослучайных чисел и од-
носторонними функциями, которая, в частности, позволяет строить
«доказуемо надежные» генераторы на основе односторонних функ-
ций. Кавычки здесь означают, что доказательства справедливы при
некоторых условиях, типичных для теории сложности алгоритмов,
например, базируются на недоказанных предположениях об одно-
сторонности некоторых функций.
    Мы остановимся на описании нескольких генераторов, базирую-
щихся на односторонних функциях. Прежде всего отметим, что два
класса таких генераторов описаны ранее в разд. 8.4. Действительно,
9.4. Тесты для проверки генераторов                                   195

режимы OFB и CTR описаны в общем виде и могут применяться для
любых блоковых шифров, которые, в свою очередь, могут рассмат-
риваться как односторонние функции. Другие конструкции генера-
торов базируются на теоретико-числовых односторонних функциях,
знакомых нам по предыдущим разделам. В качестве примера мы
рассмотрим генератор, базирующийся на системе RSA.
     Параметры генератора — два больших простых числа P и Q
(P 6= Q), их произведение N = P Q и число e > 1 , взаимнопростое с
(P − 1)(Q − 1). Семя x0 — cлучайно выбранное число из диапазона
(1, N −1). Генератор формирует последовательность бит z1 , z2 , . . . , zk
по следующей схеме:

                  xi ← xei−1 mod N,
                  zi ← младший бит xi ,      i = 1, 2, . . . , k.

    Отметим, что число e можно взять равным трем, что упрощает
операцию возведения в степень.
    Целый ряд других генераторов, базирующихся на теоретико-
числовых односторонних функциях описан в литературе; см., на-
пример, [26, 28].

9.4.    Тесты для проверки генераторов случайных
        и псевдослучайных чисел
Случайные и псевдослучайные числа находят самое широкое при-
менение не только в криптографических системах, но и в вычисли-
тельных методах, и при имитационном моделировании. Это делает
актуальной задачу построения эффективных статистических тестов,
предназначенных для выявления возможных отклонений от случай-
ности. Так, Национальный институт стандартов и технологий США
(NIST) недавно провел исследование известных статистических те-
стов для проверки случайных и псевдослучайных чисел, результаты
которого вместе с рекомендациями по практическому применению
опубликованы в [29]. В ходе этого исследования были выделены 16
методов, которые NIST рекомендует для применения в криптогра-
фии.
    В серии статей [13, 14, 33] авторы, во-первых, показали теорети-
чески и экспериментально, что эффективные тесты могут быть по-
строены на основе так называемых архиваторов и, во-вторых, пред-
196                       Глава 9. Случайные числа в криптографии

ложили три теста, мощность которых существенно выше, чем у всех
методов, рекомендованных NIST. В этом разделе мы опишем один
из этих трех тестов.
    Предлагаемый статистический тест базируется на конструкции
адаптивного кода «стопка книг», предложенного в [12] (позднее этот
код был переоткрыт и в англоязычной литературе получил название
«move-to-front»).
    Для описания теста нам понадобятся некоторые определения.
Пусть источник порождает буквы из алфавита A = {a1 , a2 , ..., aS },
и требуется по выборке x1 , x2 , . . . , xn проверить гипотезу

                H0 : p(a1 ) = p(a2 ) = . . . = p(aS ) = 1/S,

пpотив альтеpнативной гипотезы H1 , являющейся отpицанием H0 .
    При тестировании по предлагаемому методу буквы алфавита A
упорядочены (и занумерованы в соответствии с этим порядком от
1 до S ), причем этот порядок меняется после анализа каждого вы-
борочного значения xi следующим образом: буква xi , которую мы
обозначим через a (xi = a), получает номер 1, номера тех букв, ко-
торые были меньше, чем номер a, увеличиваются на 1, а у остальных
букв номера не меняются. Для более формального описания этого
преобразования обозначим через ν t (a) номер буквы a ∈ A после ана-
лиза x1 , x2 , . . . , xt−1 , и пусть начальный порядок ν 1 (·) на буквах A
задан произвольно. Тогда нумерация после анализа xt определяется
следующим образом:
                               
                               1,
                                           если xt = a,
                   t+1
                 ν (a) = ν (a) + 1, если ν t (a) < ν t (xt ),
                                  t                                    (9.2)
                               
                                t                t       t
                                 ν (a),     если ν (a) > ν (xt ).

(Все происходит как в стопке книг, если считать, что номер книги
совпадает с положением в стопке. Книга извлекается и кладется на-
верх. Ее номер становится первым; книги, которые первоначально
были над ней, сдвигаются вниз, а остальные остаются на месте.)
    Основная идея метода — подсчитывается не частота встречаемо-
сти букв в выборке x1 , x2 , . . . , xn , а частота встречаемости номеров
букв (при описанном упорядочивании). В том случае, когда выпол-
нена гипотеза H1 , вероятность (и частота встречаемости в выборке)
некоторых букв больше 1/S и их номера, в среднем, будут меньше,
чем у букв с меньшими вероятностями. (Другими словами, книги,
9.4. Тесты для проверки генераторов                                             197

к которым обращаются чаще, проводят в верхней части стопки зна-
чительно большее время, чем остальные. И, следовательно, вероят-
ность обнаружить требуемую книгу в верхней части стопки больше,
чем в нижней.) Если же выполнена гипотеза H0 , то, очевидно, ве-
роятность появления в выборке буквы с любым номером равна 1/S .
        При применении описываемого теста множество всех номеров
{1, . . . , S} заранее, до анализа выборки, разбивается на r , r > 1 ,
непересекающихся частей A1 = {1, 2, . . . , k1 } , A2 = {k1 + 1, . . . , k2 } ,
. . . , Ar = {kr−1 + 1, . . . , kr } . Затем по выборке x1 , x2 , . . . , xn подсчи-
тывается количество номеров ν t (xt ), принадлежащих подмножеству
Aj , которое мы обозначим через nj , j = 1, . . . , r . При выполнении
H0 вероятность того, что ν t (xt ) принадлежит множеству Aj про-
порциональна количеству элементов этого подмножества, т.е. равна
|Aj |/S . Затем по значениям n1 , . . . , nr проверяется гипотеза
                                    
                      H0∗ : P ν t (xt ) ∈ Aj = |Aj |/S                          (9.3)

против альтернативной гипотезы H1∗ = ¬H0∗ . Очевидно, что при
выполнении исходной гипотезы H0 выполняется и H0∗ и, наоборот,
при выполнении гипотезы H1∗ выполняется H1 . Поэтому применение
описанного критерия корректно.
    При проверке гипотез используется хорошо известный в стати-
стике критерий хи-квадрат ( χ2 ), описание которого может быть най-
дено, например, в [9]. При пpименении кpитеpия χ2 вычисляется
величина (статистика)
                                     r
                                    X   (nj − nPj0 )2
                             x2 =                     ,                        (9.4)
                                    j=1
                                            nPj0

где Pj0 = |Aj |/S , см. (9.3). Известно, что pаспpеделение случайной
величины x2 асимпотически пpиближается к pаспpеделению χ2 с
(r − 1) степенью свободы пpи выполнении H0 .
     Мы не описываем какой-либо алгоритм выбора количества под-
множеств Aj и их величины, а предлагаем определять эти харак-
теристики экспериментально. Дело в том, что при тестировании ге-
нераторов случайных и псевдослучайных чисел, как и в некоторых
других задачах, возможно проведение специальных экспериментов
для определения значений этих величин, а затем проведение про-
верки гипотез по независимым данным (или по участкам последова-
198                    Глава 9. Случайные числа в криптографии

тельности псевдослучайных чисел, не использовавшимся при подбо-
ре указанных значенй). Такие эксперименты направлены на поиск
значений параметров, позволяющих выявить отклонения от случай-
ности (т.е. от H0 ) при приемлемых объемах выборки (или за прием-
лемое время вычислений).
     В качестве примера покажем, что дает описанный метод тести-
рования применительно к генераторам, предложенным в [9]. Д. Кнут
[9] применяет различные статистические тесты к нескольким гене-
раторам псевдослучайных чисел, которые он обозначил буквами B ,
C , D , E , F . Генераторы B — E порождаются так называемыми ли-
нейными конгруэнтными последовательностями по формуле
                      xi+1 = (axi + b) mod m,                 (9.5)
где a, b , m и x0 — параметры метода, а генератор F основан на так
называемом методе Фибоначчи (полное описание всех генераторов
дано в [9]).
     Все эти генераторы предназначены для получения равномерно
распределенных целых чисел из множества {0, . . . , m − 1}, где m —
параметр метода, см.(9.5). Известно, что младшие знаки порождае-
мых по (9.5) чисел часто далеки от абсолютно случайных, поэтому
обычно рекомендуется использовать только старшие знаки в каче-
стве случайных чисел [9]. Следуя этой рекомендации, из порожда-
емых генератором значений выделялся старший бит, или старший
байт (варианты, обозначаемые в дальнейшем R1 и R8 соответствен-
но). Точнее, в режиме R1 для четного m старший бит zi вычислялся
по формуле                 (
                            0, если xi < m/2,
                      zi =
                            1, если xi ≥ m/2,
а для нечетного — как
                        
                        0, если xi < (m − 1)/2,
                        
                   zi = 1, если xi > (m − 1)/2,
                        
                          Λ, если xi = (m − 1)/2,
                        

где Λ — пустое слово.
    В режиме R8 восьмибитовое слово ẑi «извлекается» из xi по
формуле               (
                       ⌊256xi /m∗ ⌋, если xi < m∗ ,
                ẑi =
                       Λ,            если xi ≥ m∗ ,
9.4. Тесты для проверки генераторов                                             199

где m∗ = 256⌊m/256⌋ , а целое число ⌊256xi /m∗ ⌋ записано как 8-
битовое слово.
     Последовательность zi ∈ {0, 1} разбивалась на блоки длины s
и при тестировании рассматривалась как выборка из алфавита раз-
мера S = 2s , состоящего из всех двоичных слов длины s. Мно-
жество всех позиций в «стопке книг» разбивалось или на два под-
множества A1 = {a1 , . . . , ak1 } , A2 = {ak1 +1 , . . . , aS }, или на три:
A1 = {a1 , . . . , ak1 } , A2 = {ak1 +1 , . . . , ak2 }, A3 = {ak2 +1 , . . . , aS }.
     В табл. 9.1 приведены данные по тестированию датчиков, опи-
санных в книге Д. Кнута [9]. При проведении экспериментов каждый
генератор тестировался в режиме R1 при разных длинах выбор-
ки. Если удавалось найти длину выборки, при которой генерируе-
мые последовательности отличались от случайных (при применении
«стопки книг» ), все вычисления повторялись при этой длине выбор-
ки по другим 100 последовательностям, ранее не использовавшимся
для тестирования. При этом вычислялись величины Qα , равные ко-
личеству тех случаев, когда вычисленное по выборке значение x2
(см.(9.4)) превосходило значение квантиля уровня α распределения
χ2 с соответствующим числом степеней свободы для двух значений
α = 0.5 и α = 0.95. Если же не удавалось найти отклонений на иссле-
дуемых длинах выборок, то все вычисления повторялись в режиме
R8 .
     Д. Кнут [9] протестировал указанные датчики другими метода-
ми и пришел к выводу, что генераторы D и особенно E и F долж-
ны быть забракованы, B прошел испытания удовлетворительно, а
C «находится на грани». Полученные нами данные хорошо согласу-
ются с этими результатами. Действительно, применение нового теста
показывает, что генератор F должен быть забракован уже при длине
выборки 240 бит: при ста испытаниях вычисленное по (9.4) значение
x2 превосходит квантили порядка 0.95 и 0.5 соответственно 80 и 83
раза из 100 (тогда как для «идеальных» случайных бит это должно
происходить, в среднем, в 5 и в 50 из 100 случаев). Генераторы C
и D также бракуются описанным тестом, правда при больших дли-
нах выборки. Это можно показать строго, используя, скажем, тот
же критерий χ2 . Как мы отмечали, при абсолютно случайных чис-
лах вероятность «попадания» в колонку Q0.95 должна быть равна
0.05. Прямое вычисление показывает, что гипотеза о равенстве ве-
роятности попадания 0.05 должна быть отвергнута по критерию χ2
при уровне значимости 0.01, если число попаданий привышает 11 из
200                        Глава 9. Случайные числа в криптографии

100. Из табл. 9.1 видно, что во всех случаях гипотеза об абсолютной
случайности чисел, порождаемых генераторами C — F должна быть
отвергнута при уровне значимости 0.01, так как Q0.95 во всех слу-
чаях больше 11. Интересно отметить, что датчик C не бракуется ни
одним статистическим тестом из [9]. Однако описанный нами тест
забраковал этот датчик даже в режиме R1 . Таким образом, пред-
ложенный тест оказался более мощным, чем методы, традиционно
используемые для тестирования генераторов случайных чисел.


      Т а б л и ц а 9.1. Тестирование генераторов из [9]
      Гене-   Режим    s    Длина выборки,   k1    k2    Q0.5   Q0.95
      ратор                      бит
        B      R8     24       1680000       217    -      52    4
        C      R1     24       7920000       217    -      70    17
        D      R1     16        160000       210   214     74    16
        E      R1     12         12000       23    25      99    97
        F      R1     8            240       21    22      83    80


    Как уже отмечалось, в [13, 33] тест «стопка книг» сравнивался
с методами, рекомендованными Национальным институтом стандар-
тов и технологий США (NIST). Оказалось, что его мощность суще-
ственно выше, чем у всех 16 методов, рекомендованных NIST; по-
дробности можно найти в [33].


9.5.     Статистическая атака на блоковые шифры
Как отмечалось в главе 8, блоковые шифры с секретным ключом
находят самое широкое применение в системах защиты передавае-
мой и хранимой информации, что делает актуальными как задачи
построения надежных блоковых шифров, так и поиск эффективных
криптологических атак на эти шифры (т.е. методов определения сек-
ретного ключа шифра на основе экспериментов с зашифрованными
сообщениями). Исследования в этих областях ведутся параллельно
и часто одними и теми же специалистами и, как правило, изобрете-
ние новой атаки приводит к появлению шифров, к ней устойчивых.
Отметим сразу, что для криптографии представляют интерес атаки,
которые менее трудоемки, чем метод прямого перебора ключей.
9.5. Статистическая атака на блоковые шифры                                  201

    Мы видели в предыдущей главе, что блоковые шифры описыва-
ются как функция, определенная на множестве всех двоичных слов
длины (n + k) и принимающая значения в множестве двоичных слов
длины n , где n — размер блока, а k — длина (секретного) клю-
ча. Мы видели, что в современных шифрах длина блока обычно со-
ставляет 128 или 64 бита, а длина ключа принимает значения от
нескольких десятков до нескольких тысяч бит. Например, у шиф-
ра AES (Rijndael) длина блока n = 128 бит, а длина ключа может
принимать три значения — 128, 196 и 256 бит. У других популяр-
ных шифров RС5 и RC6, предложенных Р. Ривестом, длина блока
может быть 32, 64 или 128 бит, а длина ключа в разных вариантах
принимает значения от 64 до нескольких тысяч бит.
    Как было показано в главе 8, процесс шифрования в современ-
ных блоковых шифрах обычно разбивается на последовательность
сравнительно простых этапов, называемых раундами. В ходе каж-
дого нового раунда проводится шифрование данных, полученных на
предыдущем этапе с так называемым ключом раунда. В RC5, RC6
и многих других шифрах количество раундов является параметром
и часто криптоаналитики исследуют стойкость шифров как функ-
цию числа раундов. Одна из целей такого анализа — нахождение
числа раундов, гарантирующих высокую надежность шифра. Таким
образом, схематично процесс шифрования можно представить как
цепочку «элементарных» этапов (или раундов) шифрования
    x1 = E1 (x0 , k1 ), x2 = E2 (x1 , k2 ), . . . , xr = Er (xr−1 , kr ),   (9.6)
где x0 — исходное n -битовое слово, которое необходимо зашифро-
вать, Ei — операция (функция) шифрования на i-м этапе, ki —
ключ, используемый на i-м этапе, xi — n -битовое слово, являюще-
еся «выходом» i-го этапа и «входом» (i + 1)-го, и, наконец, xr —
результат шифрования.
    Как отмечалось при изучении блоковых шифров, для них из-
вестны специальные виды атак, такие как дифференциальный и ли-
нейный криптоанализ и их разновидности. Для иллюстрации связи
случайных чисел с многими задачами криптографии в данном разде-
ле мы опишем универсальную атаку на блоковые шифры, названую
градиентной статистической атакой, и в качестве примера исследуем
возможность ее применения для криптоанализа шифра RC5. Приве-
денные экспериментальные данные позволяют сделать вывод о том,
что эта атака может быть применена, и что для некоторых режи-
202                         Глава 9. Случайные числа в криптографии

мов шифра ее трудоемкость может быть существенно меньше, чем у
прямого перебора ключей.
     Описываемый нами метод относится к классу атак с выбира-
емым текстом (chosen plaintext attack), см. главы 1 и 8. При реа-
лизации этой атаки криптоаналитик может подавать на вход шиф-
ра любой текст и анализировать полученное зашифрованное сооб-
щение. Цель атаки — нахождение (секретного) ключа, причем при
этом предполагается, что криптоаналитик знает все характеристики
шифра, кроме этого ключа. Такие атаки представляют практиче-
ский интерес и, как отмечалось в главе 8, современные блоковые
шифры должны быть стойки к ним.
     У большинства современных шифров начальный ключ K дли-
ной в |K| бит преобразуется в последовательность так называемых
раундовых ключей k1 , k2 , . . . , kr , которые используются последова-
тельно для шифрования на разных этапах, см. (9.6). В разных шиф-
рах эта процедура осуществляется по разному, причем это зависит
не только от шифра, но и от значений длин блока, ключа и числа
раундов, которые для многих шифров являются параметрами. На-
пример, для шифра RC5 длина блока может принимать значения
32, 64 или 128 бит, количество раундов может быть любым целым
числом, а длина ключа должна быть кратна 8 и может принимать
любое значение, начиная с 8 бит. Отметим, что значения n = 64,
r = 12, |K| = 128 рекомендованы разработчиками и широко иссле-
дованы. Часто рассматриваются и схемы, в которых     Pr длина ключа K
равна суммарной длине ключей раундов, |K| = i=1 |ki |.
     Дешифрование проводится по схеме, обратной к шифрованию
(9.6):

  xr−1 = Dr (xr , kr ), xr−2 = Dr−1 (xr−1 , kr−1 ), . . . , x0 = D1 (x1 , k1 ),
                                                                           (9.7)
где используются те же ключи раундов, а операции Di обратны эта-
пам шифрования Ei .
     Оценим трудоемкость атаки путем полного перебора ключей.
Для ее проведения достаточно иметь одно зашифрованное сообще-
ние (двоичное слово), длина которого не меньше длины ключа. За-
тем необходимо пытаться дешифровать это зашифрованное сообще-
ние, последовательно перебирая все возможные ключи в каком-либо
порядке и сравнивая полученный результат с исходным, незашифро-
ванным, текстом; совпадение означает, что неизвестный ключ най-
9.5. Статистическая атака на блоковые шифры                             203

ден. Обычно предполагается, что ключ принимает любое значение
из множества всех двоичных слов длины |K| с вероятностью 2−|K| ,
поэтому среднее значение числа перебираемых ключей равно 2|K| /2.

      Одно из требований, предъявляемых к блоковым шифрам, мож-
но сформулировать следующим образом: любое зашифрованное со-
общение должно быть неотличимо от абсолютно случайной последо-
вательности. В частности, все шифры, принимавшие участие в кон-
курсе на шифр 21-го века, проводившемся в США в 1999–2001 годах,
проверялись на выполнение этого условия. Мы не будем останавли-
ваться на логическом анализе этого требования (которое, в некото-
ром смысле, вообще не выполнимо), а приведем пример, поясняющий
его смысл. Для этого мы определим n -битовое слово αi как двоич-
ную запись числа i, i = 0, 1, 2, . . . , 2n −1 , где, как и ранее, n — длина
блока рассматриваемого шифра (т.е. α0 состоит из n -битовой цепоч-
ки нулей, α1 из (n − 1) нуля и единицы, α2 — из (n − 2) нулей, после
которых идет последовательность 10 и т.д.). От современного бло-
кового шифра требуется, чтобы при любом значении ключа после-
довательность n -битовых слов E(α0 ), E(α1 ), E(α2 ), . . . , рассматри-
ваемая как двоичная последовательность, была статистически неот-
личима от случайной. (Здесь E(αi ) означает зашифрованное слово
αi .) Это требование, в частности, позволяет использовать блоковые
шифры как генераторы псевдослучайных чисел, как было показано
в разд. 8.4.

    Перейдем теперь к описанию статистической атаки на блоко-
вые шифры, у которых кодирование и декодирование разбивается
на последовательность раундов (9.6) и (9.7), начав с неформального
предварительного рассмотрения. При этом мы будем использовать
совершенно не строгие термины «более» и «менее» случайные по-
следовательности, понимая под этим, что некоторая последователь-
ность более случайна, чем другая, если отклонения от случайности
у первой достоверно выявляются при бо́льшей длине, чем у второй.
(При этом предполагается, что используется некоторый статистиче-
ский тест при одном и том же уровне значимости. Другое «опреде-
ление» более случайной последовательности — величина статистики
критерия для этой последовательности меньше, чем для менее слу-
чайной.) Предположим, что на вход шифра, ключ которого неизве-
стен, подаются последовательно слова α0 , α1 , α2 , . . . . Очевидно,
204                         Глава 9. Случайные числа в криптографии

эта последовательность очень неслучайна. Последовательность
                 E1 (α0 , k1 ), E1 (α1 , k1 ), E1 (α2 , k1 ), . . .
после первого раунда шифрования, которую мы обозначим через β0 ,
β1 , . . . , более случайна, чем исходная; получаемая после второго
раунда последовательность
                 E2 (β0 , k2 ), E2 (β1 , k2 ), E2 (β2 , k2 ), . . .
еще более случайна и т.д. Наконец, полученная после последнего ра-
унда последовательность ω0 , ω1 , ω2 , . . . более случайна, чем преды-
дущая. Это неформальное утверждение подтверждается экспери-
ментально в приведенных ниже данных для шифра RC5 и в довольно
многочисленных работах по анализу блоковых шифров. Объяснение
этого факта довольно очевидно: шифрование на каждом раунде при-
водит к «перемешиванию» и, тем самым, повышает «случайность»
шифруемых данных. Отметим и очевидное следствие — при дешиф-
ровании последовательности ω0 , ω1 , ω2 , . . . по схеме (9.7) случай-
ность получаемых данных последовательно уменьшается. Это, ко-
нечно, справедливо только в том случае, когда при дешифровании
используются «истинные» ключи раундов. Если же при дешифро-
вании, скажем, xr−1 = Dr (xr , kr ) вместо истинного ключа kr ис-
пользуется какое-либо другое слово kr∗ той же длины, то эффект
преобразования Dr (xr , kr∗ ) будет таков же, как при шифровании —
выходная последовательность станет более случайна, чем входная.
Это важное для нас наблюдение в общем виде состоит в следую-
щем: при дешифровании на j -м раунде при использовани «непра-
вильного» ключа kj∗ (вместо «правильного» ключа kj ) случайность
выходной последовательности возрастает, тогда как при использова-
нии правильного kj — убывает. На этом наблюдении и базируется
предлагаемая атака, которую мы теперь можем схематично описать.
    Вначале уточним формулировку задачи. Дан шифр, для кото-
рого шифрование и дешифрование проводятся по схемам (9.6), (9.7)
соответственно. Предполагается, что все параметры шифра, кроме
ключа K , известны. Цель атаки — найти неизвестные ключи раун-
дов k1 , k2 , . . . , kr , где, как и ранее, r — число раундов (что экви-
валентно нахождению K , так как дает возможность дешифровать
любое сообщение, зашифрованное с этим ключом).
    При проведении описываемой атаки сначала на вход шифра по-
дается «простая» последовательность из mr n -битовых слов (на-
9.5. Статистическая атака на блоковые шифры                                  205

пример, вышеописанная α0 , α1 , α2 , . . . , αmr ), где mr — параметр
метода. Обозначим полученную на выходе зашифрованную после-
довательность через ω0 , ω1 , ω2 , . . . ωmr . Предполагается, что ис-
пользуется некоторая количественная мера случайности, которую
мы обозначим через γ(w), где w — двоичная последовательность,
причем, чем больше γ(w), тем последовательность менее случайна
(в дальнейшем в качестве такой меры будет использоваться стати-
стика x2 ).
    После этого для всех возможных значений ключа r -го раунда
kr поочередно вычисляем последовательность Γr (u) , определяемую
как
    Γr (u) = Dr (ω0 , u), Dr (ω1 , u), Dr (ω2 , u), . . . , Dr (ωmr , u),   (9.8)
где u ∈ {0, 1}|kr | ), и оцениваем степень ее случайности. Затем на-
ходим такое значение u∗ , для которого статистика γ(Γr (u∗ )) макси-
мальна среди всех значений γ(Γr (u)), u ∈ {0, 1}|kr | ), и полагаем, что
(неизвестный) ключ r -го раунда равен u∗ : kr = u∗ . Отметим сразу,
что количество операций дешифрования на этом этапе пропорцио-
нально 2|kr | mr .
    Затем повторяем аналогичные вычисления для поиска ключа
(r − 1)-го раунда ( kr−1 ), используя в качестве исходной последова-
тельность Γr (kr ) = Γr (u∗ ), см. (9.8). Точнее, вычисляем последова-
тельность
     Γr−1 (u) = Dr−1 (Dr (ω0 , kr ), u), Dr−1 (Dr (ω1 , kr ), u), . . . ,   (9.9)
где теперь u ∈ {0, 1}|kr−1 | ) и оцениваем случайность этой последо-
вательности. Мы считаем, что количество n -битовых слов в этой
последовательности, которое мы обозначим через mr−1 , не превосхо-
дит mr (в противном случае можно вычислить недостающие слова,
хотя, как будет видно из последующих данных, mr−1 будет обыч-
но меньше mr , так как последовательность Γr−1 (u) менее случайна,
чем Γr (u) . Слово u∗∗ , минимизирующее случайность последователь-
ности Γr−1 (u) и будет значением ключа (r − 1)-го раунда. Отметим,
что на этом этапе количество операций дешифрования пропорцио-
нально 2|kr−1 | mr−1 .
    Повторяя описанные вычисления последовательно, мы найдем
значения ключей раундов kr−1 , kr−2 , kr−3 , . . . , k1 . Суммарное ко-
личество Pопераций при нахождении всех ключей раундов пропорци-
             r    |ki |
онально      i=1 2      mi или в типичном случае, когда длины ключей
206                     Глава 9. Случайные числа в криптографии

раундов равны ( |ki | = |k|), количество операций пропорционально
величине rmmax 2|k| , тогда как для прямого перебора это величи-
на порядка 2|K| (где mmax = maxi=1,...,r mi и K — ключ шифра).
Эта разница в показателях степени и определяет область применимо-
сти предлагаемой атаки: если rmmax меньше 2|K|−|k| , то количество
операций у предлагаемого метода меньше, чем у полного перебора
ключей.
     Теперь обсудим возможные модификации, параметры и вариан-
ты описанного метода. Мы описали идею метода в «чистом» виде, а
здесь остановимся на возможных вариантах его реализации.
     Во-первых, мера случайности γ(·) является параметром мето-
да, причем можно использовать не только различные меры для раз-
ных шифров, но и для разных раундов. Как указано выше, любой
статистический тест, который применим для проверки основной ги-
потезы ( H0 ) о том, что двоичная последовательность порождается
бернуллиевским источником с равными вероятностями для нуля и
единицы, против альтернативной гипотезы H1 , являющейся отри-
цанием H0 , может быть использован для этой цели. При этом γ(·)
может быть равна величине статистики критерия (скажем, величине
x2 , используемой в критерии хи-квадрат; именно такая мера будет
использована в нижеприведенных примерах.)
     Во-вторых, в отличие от описанного выше варианта, при поис-
ке ключа j -го раунда можно выбирать не один истинный ключ, а
несколько «подозрительных» значений u , т.е. таких слов, у которых
мера случайности γ(Γj (u)) минимальна (среди u ∈ {0, 1}|kj | )). Кро-
ме того, при поиске простых последовательностей и ключей раун-
дов естественно использовать последовательные методы, аналогич-
ные последовательным критериям в математической статистике.
     В третьих, начальная «очень неслучайная» последовательность
α0 , α1 , α2 , . . . , αmr может выбираться различными способами. На-
пример, кажется разумным выбирать последовательность, в которой
соседние слова ( αi , αi+1 ) не только содержат много одинаковых сим-
волов, но и отличаются только одним знаком (так называемый код
Грея). Наконец, часть двоичных символов в словах последовательно-
сти α0 , α1 , α2 , . . . , αmr могут выбираться случайно, а оставшиеся
полагаться равными нулю и т.д.
     Последняя модификация связана с тем фактом, что у многих со-
временных шифров при большом числе раундов даже «очень» неслу-
чайная последовательность после шифрования статистически не от-
9.5. Статистическая атака на блоковые шифры                                               207

личима от случайной (при использовании известных статистических
тестов и при приемлемом времени вычислений). Пусть, например,
шифр использует r раундов и для некоторой «простой» начальной
                                                   0
последовательности α0 = α00 , α10 , α20 , . . . , αm последовательности

          α1 = E1 (α00 , k1 ), E1 (α10 , k1 ), E1 (α20 , k1 ), . . . , E1 (αm 0
                                                                                 , k1 )
           2         1               1               1                        1
          α = E2 (α0 , k2 ), E2 (α1 , k2 ), E2 (α2 , k2 ), . . . , E2 (αm , k2 )
          ...
          αd = Ed (α0d−1 , kd ), Ed (α1d−1 , kd ), . . . , Ed (αm     d−1
                                                                          , kd )

неслучайны при всех ключах раундов k1 , . . . , kd , d < r . Тогда опи-
санная выше атака может быть модифицирована следущим образом:
для каждого набора ключей kd+1 , . . . , kr раундов d+1, . . . , r повто-
ряем описанную выше процедуру нахождения неизвестных ключей
k1 , . . . , kd раундов 1 , . . . , d . Другими словами, ключи kd+1 , . . . ,
kr находим полным перебором, а k1 , . . . , kd — по описанному выше
методу. Для проведения такой комбинированной атаки потребуется
количество операций

                                  Pr                 d
                                                     X
                                             |kj |
                              m2     j=d+1                 2|kj | ,
                                                     j=1

что при некоторых соотношениях параметров может быть меньше,
чем количество операций, необходимое при прямом переборе всех
ключей.
    В качестве объекта экспериментального исследования предло-
женной атаки был взят шифр RC5. В этом шифре, как видно из его
описания, каждый раунд может быть легко разделен на две части,
называемые полураундами. Мы в дальнейшем часто будем исполь-
зовать выражения типа «3.5 раунда» вместо «7 полураундов» (эта
терминология является общепринятой в работах, касающихся RC5,
RC6 и ряда других шифров). Описание экспериментального иссле-
дования мы начнем с анализа степени случайности зашифрованных
сообщений в зависимости от числа раундов шифра.
    Первый вопрос, который исследовался экспериментально1 , ка-
сался возможности различения зашифрованных при помощи RC5
  1 Вычисления проводились на суперкомпьютерарах Института вычислитель-

ных технологий СО РАН и Новосибирского государственного университета.
208                        Глава 9. Случайные числа в криптографии

«простых», явно не случайных, последовательностей при разном чис-
ле (полу)раундов. Для этого мы использовали в качестве исходной
вышеупомянутую последовательность αi , i = 0, 1, . . . , где αi — за-
пись числа i в двоичной системе счисления, под которую отводится
64 бита. (Напомним, что мы рассматриваем RC5 с длиной шифруе-
мого блока 64 бита.) Во всех случаях указанная последовательность
зашифровывалась при помощи указанного шифра с заданным коли-
чеством полураундов и по полученной последовательности проверя-
лась гипотеза H0 о том, что двоичная последовательность порожда-
ется бернуллиевским источником с равными вероятностями нуля и
единицы, против альтернативной гипотезы H1 , являющейся отрица-
нием H0 . В дальнейшем, для того чтобы избегать длинных повторов,
мы будем называть эту задачу «гипотезой о случайности». Для про-
верки этой статистической гипотезы использовался описанный в [14]
тест «адаптивный хи-квадрат».
    В табл. 9.2 приведены данные по проверке гипотезы о случайно-
сти при использовании адаптивного критерия хи-квадрат для RC5 с
разным количеством раундов.


      Т а б л и ц а 9.2. Количество последовательностей (из 100),
                         для которых гипотеза о случайности была
                         отвергнута
        Номер       Число раундов r и длина последовательностей t
        ключа     r=1       r = 1.5     r=2      r = 2.5     r=3
                 t = 218    t = 218    t = 218   t = 220    t = 220
          1        100        63         64        51         52
          2        100        100        100       74         70
          3        100        61         61        17         17
          4        100        81         78        62         64
          5        100        100        100       65          6
          6        100        85         86        12          9
          7        100        100        100       11          8
          8        100        98         99        99         99
          9        100        80         79        14         14
          10       100        100        100        7          5


    Все вычисления проводились для 10 случайно выбранных клю-
чей и повторялись 100 раз при шифровании 100 следующих после-
9.5. Статистическая атака на блоковые шифры                                               209

довательностей слов длины t :

  α0 , α1 , . . . , αt−1 ,     αt , αt+1 , . . . , α2t−1 , . . . ,
                                                       α99t , α99t+1 , . . . , α100t−1 . (9.10)
В табл. 9.2 указано количество случаев, когда гипотеза о случайно-
сти отвергалась при уровне значимости 0.0001. Например, мы видим
из таблицы, что гипотеза о случайности была отвергнута 100 раз из
100 при использовании первого (случайно выбранного) ключа и при
длине последовательности t = 218 слов. Таким образом, мы видим из
этой таблицы, что зашифрованные последовательности явно не слу-
чайны, так как в противном случае в среднем гипотеза отвергалась
бы приблизительно в 0.0001 · 100 = 0.1 случаях из 100.
    Для большего числа раундов вычисления проводились с мень-
шим числом вариантов (или повторностей), так как в этом случае
требовались последовательности большей длины и соответственно
большее время вычислений. Снова проверялась гипотеза о случай-
ности для той же зашифрованной последовательности α0 , . . . , αt−1
c разными (случайно выбранными) ключами и разным числом ра-
ундов; результаты приведены в табл. 9.3. Мы видим, что зашифро-

    Т а б л и ц а 9.3. Проверка гипотезы о случайности для
                       большого числа раундов при уровне
                       значимости 0.01
        Число           t    Количество   Количествово случаев,
         раундов                         тестов            в которых гипотеза о
                                                          случайности отвергнута
             5               228            30                        30
            5.5              229            22                        10
             6               231            6                         6
            6.5              232            6                         6
             7               232            6                         5
            7.5              233            3                         3
             8               237            3                         2

ванная последовательность α0 , α1 , . . . , αt−1 довольно надежно отли-
чается от случайной до восьмого раунда.
     Как уже было сказано, главное предположение, без выполне-
ния которого градиентная статистическая атака была бы невозмож-
на, состоит в следующем: при дешифровании на любом раунде при
210                   Глава 9. Случайные числа в криптографии

использовании «неправильного» ключа k ∗ (вместо «правильного»
ключа k ) случайность выходной последовательности возрастает, то-
гда как при использовании «правильного» k — убывает. Выполнение
этого предположения проверялось экспериментально по следующей
схеме: для трех случайно выбранных ключей 100 вышеописанных
сообщений (9.10) шифровались при помощи RC5 до j -го полура-
унда. Затем проводилось дешифрование на один полураунд с «ис-
тинным» ключом полураунда и с 10 случайно выбранными «непра-
вильными» ключами, и для всех 11 последовательностей оценива-
лась степень случайности полученных после этого преобразования
данных. Отметим, что, в соответствии в нашей гипотезой, разница
в степени случайности последовательности, дешифрованной с «пра-
вильным» ключом и 10 других, дешифрованных со случайными клю-
чами, должна соответствовать различиям в случайности, получае-
мым при шифровании в один дополнительный раунд. (Действитель-
но, правильный ключ уменьшает случайность на полраунда, а непра-
вильный — увеличивает случайность на полраунда.)
     В табл. 9.4 приведены данные экспериментов для различного
количества раундов ( r ) при уровне значимости 0.0001. Параметры
теста и длины последовательностей t определялись в ходе предва-
рительных экспериментов, проводимых по независимым данным, по-
лученным с использованием других случайных ключей.
     Поясним результаты первой серии опытов для 2.5 раундов. Ока-
залось, что среди 100 последовательностей, расшифрованных с пра-
вильным ключом полураунда, неслучайными признаны 54 из 100
(при уровне значимости 0.0001), тогда как из 100 последовательно-
стей дешифрованных с первым «неправильным» ключом признано
неслучайными только 9 последовательностей, со вторым — 10, с тре-
тьим — 10 и т.д.; т.е. последовательности, дешифрованные с пра-
вильным ключом, менее случайны, чем последовательности, дешиф-
рованные с неправильными ключами.
     Мы видим, что данные, приведенные в таблицах 9.2—9.4, под-
тверждают предположения, выполнение которых необходимо для
принципиальной возможности проведения градиентной статистиче-
ской атаки: во-первых, случайность зашифрованной последователь-
ности возрастает при увеличении числа полураундов и, во-вторых,
случайность последовательности, дешифрованной с неправильным
ключом полураунда, больше, чем у дешифрованной с правильным
ключом.
9.5. Статистическая атака на блоковые шифры                            211


Т а б л и ц а 9.4. Количество «неслучайных» последовательностей
                   (из 100) при дешифровании с истинным и 10
                   случайными ключами полураундов
  r = 2.5, t = 28
  Серия      Истинный                   Случайные ключи
               ключ      1    2    3    4    5   6    7     8    9    10
    1            54      9    10   10   15   13   13   8    10   19   12
    2            69      34   34   35   34   36   33   34   36   39   33
    3            87      44   37   36   38   38   37   41   42   42   41
  r = 3,     t = 216
  Серия      Истинный                   Случайные ключи
               ключ      1    2    3    4    5   6    7     8    9    10
    1            97      81   84   84   81   84   83   84   82   83   83
    2            73      35   39   36   32   36   32   33   40   39   42
    3            94      0    1    2    0    1    1    0    4    0    1
  r = 3.5,    t = 219
  Серия       Истинный                  Случайные ключи
                ключ     1    2    3    4    5   6    7     8    9    10
     1           100     28   16   23   9    15   26   18   17   22   22
     2           48      9    10   9    11   10   8    9    10   10   11
     3           65      20   21   18   20   19   20   19   19   18   17


    Таким образом, градиентная атака на шифр RC5 была реали-
зована. Оказалось, что она позволяет достаточно надежно находить
ключи четырех раундов при приемлемом времени вычислений.

Описание шифра RC5

Ввиду того, что градиентная атака рассматривалась по отношению
к шифру RC5, мы для полноты изложения приводим описание этого
шифра, достаточное для его компьютерной реализации.
    Шифр RC5 является предшественником шифра RC6, рассмот-
ренного нами в разд. 8.2. При описании RC5 будем использовать те
же обозначения параметров шифра и операций, как ранее для RC6.
    В RC5 пользователь задает размер слова w (16, 32 или 64 бита),
количество раундов r и длину ключа l . Размер блока составляет два
слова. Шифрование и дешифрование блока данных производится с
использованием одного и того же так раундового ключа W длиной
212                   Глава 9. Случайные числа в криптографии

2r + 2 слова (нумерация слов с нуля), получаемого из секретного
ключа K .


Алгоритм 9.1. RC5: шифрование блока данных
ВХОД:    Блок из двух слов (a, b), раундовый ключ W .
ВЫХОД: Зашифрованный блок (a, b).
1.    a ← a + W0 , b ← b + W1 ;
2.    FOR i = 1, 2, . . . , r DO
3.       a ← ((a ⊕ b) ←֓ b) + W2i ,
4.       b ← ((b ⊕ a) ←֓ a) + W2i+1 ;
5.    RETURN (a, b).

    Для дешифрования «прокручиваем» этот процесс в обратном
порядке.


Алгоритм 9.2. RC5: дешифрование блока данных
ВХОД:    Блок из двух слов (a, b), раундовый ключ W .
ВЫХОД: Дешифрованный блок (a, b).
1.    FOR i = r, r − 1, . . . , 1 DO
2.       b ← ((b − W2i+1 ) ֒→ a) ⊕ a,
3.       a ← ((a − W2i ) ֒→ b) ⊕ b ;
4.    b ← b − W1 , a ← a − W0 ;
5.    RETURN (a, b).

    Для полноты описания шифра приведем также алгоритм фор-
мирования раундового ключа. Он практически полностью совпадает
с соответствующим алгоритмом для RC6. Как и ранее, обозначим
через c число слов в секретном ключе K , K = K0 K1 · · · Kc−1 . В
алгоритме используются «магические» числа Pw и Qw , имеющие те
же значения, что и для шифра RC6 (см. табл. 8.1 на стр. 166).
9.5. Статистическая атака на блоковые шифры              213

Алгоритм 9.3. RC5: формирование раундового ключа
ВХОД:    Секретный ключ K .
ВЫХОД: Раундовый ключ W .
1.    W0 ← Pw ;
2.    FOR i = 1, 2, . . . , 2r + 1 DO Wi ← Wi−1 + Qw ;
3.    a ← 0, b ← 0 , i ← 0 , j ← 0;
4.    k ← 3 max(c, 2r + 2);
5.    DO k раз
6.       Wi ← (Wi + a + b) ←֓ 3, a ← Wi ,
7.       Kj ← (Kj + a + b) ←֓ (a + b), b ← Kj ,
8.       i ← i + 1 mod 2r + 2, j ← j + 1 mod c;
9.    RETURN W .
ОТВЕТЫ К ЗАДАЧАМ И УПРАЖНЕНИЯМ




1.1. а. k = 17 . б. k = 27.
1.2. а. ПРИВЕТ ( k = 5). б. ВЕСНА (k = 20 ).

2.1. а. 5 = 5 , 16 = 6 , 27 = 7 , −4 = 6, −13 = −3 = 7, 3 + 8 = 1,
3 − 8 = 5, 3 · 8 = 4, 3 · 8 · 5 = 4 · 5 = 0 (mod 10). б. 5 = 5, 16 = 5,
27 = 5, −4 = 7, −13 = −2 = 9, 3 + 8 = 0, 3 − 8 = 6, 3 · 8 = 2,
3 · 8 · 5 = 2 · 5 = 10 (mod 11).
2.2. 28 mod 10 = 6 , 37 mod 10 = 7 , 719 mod 100 = 43, 757 mod 100 =
7.
2.3. 108 = 2 · 2 · 3 · 3 · 3 , 77 = 7 · 11, 65 = 5 · 13, 30 = 3 · 3 · 5, 159 = 3 · 53.
2.4. пары (25, 12) и (40, 27) взаимно просты, другие — нет (числа
(25, 15) делятся на 5, (13, 39) делятся на 13).
2.5. ϕ(14) = 6, ϕ(20) = 8.
2.6. ϕ(53) = 52, ϕ(21) = ϕ(7) · ϕ(3) = 6 · 2 = 12, ϕ(159) = 2 · 52 = 104.
2.7. 313 mod 13 = 3·312 mod 13 = 3, 522 mod 11 = 52 ·510 ·510 mod 11 =
25 mod 11 = 3, 317 mod 5 = 3.
2.8. 39 mod 20 = 3 · 38 mod 20 = 3, 214 mod 21 = 22 · 212 mod 21 = 4,
2107 mod 159 = 23 · 2104 mod 159 = 8.
2.9. gcd(21, 12) = 3 , gcd(30, 12) = 6 , gcd(24, 40) = gcd(40, 24) = 8,
gcd(33, 16) = 1.
2.10. а. x = −1, y = 2. б. x = 1, y = −2. в. x = 2, y = −1. г.
x = 1, y = −2.
2.11. 3−1 mod 7 =            5, 5−1 mod 8         =    5, 3−1 mod 53         =    18,
10−1 mod 53 = 16.
2.12. Простые числа, меньшие 100: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
31, 37, 41, 43, 47, 53, 59, 61, 67, 73, 79, 83, 89, 97. Из них числа 5, 7,
11, 23, 47, 59 и 83 соответствуют виду p = 2q + 1.
Ответы к задачам и упражнениям                                       215

2.13. При p = 11 в качестве параметра g могут быть выбраны числа
2, 6, 7 и 8.
2.14. а. YA = 20, YB = 17, ZAB = 21. б. YA = 13, YB = 14,
ZAB = 10. в. YA = 21, YB = 9, ZAB = 16. г. YA = 8, YB = 5,
ZAB = 9. д. YA = 6, YB = 17 , ZAB = 16 .
2.15. а. dA = 11, dB = 13, x1 = 17 , x2 = 5, x3 = 6 , x4 = 4.
б. dA = 3 , dB = 19 , x1 = 8 , x2 = 12 , x3 = 3 , x4 = 6 . в. dA = 5 ,
dB = 11, x1 = 14, x2 = 10, x3 = 3, x4 = 10. г. dA = 5, dB = 15,
x1 = 7 , x2 = 21, x3 = 14 , x4 = 17. д. dA = 11 , dB = 5 , x1 = 15 ,
x2 = 2, x3 = 8, x4 = 9 .
2.16. а. dB = 13, r = 14, e = 12, m′ = 5. б. dB = 16, r = 9,
e = 15, m′ = 10. в. dB = 15, r = 16, e = 14, m′ = 10. г. dB = 21,
r = 14, e = 12, m′ = 5. д. dB = 8, r = 5, e = 5, m′ = 10.
2.17. а. NA = 55, ϕ(NA ) = 40, cA = 27, e = 23, m′ = 12.
б. NA = 65, ϕ(NA ) = 48, cA = 29, e = 50, m′ = 20. в. NA = 77,
ϕ(NA ) = 60, cA = 43, e = 52, m′ = 17. г. NA = 91, ϕ(NA ) = 72 ,
cA = 29, e = 88, m′ = 30. д. NA = 33, ϕ(NA ) = 20, cA = 7, e = 9,
m′ = 15 .
2.18. m = 111 .

3.1. а. x = 17 . б. x = 10. в. x = 28 . г. x = 14 . д. x = 30.
3.2. а. x = 20 . б. x = 45. в. x = 34 . г. x = 53 . д. x = 25.
3.3. а. x = 10000 . б. x = 20000 . в. x = 1000 . г. x = 12345 .
д. x =25000.


4.1. а. s = 28 . б. s = 30. в. s = 26 . г. s = 71 . д. s = 18 .
4.2. а. h7, 28i подлинно, h22, 15i нет, h16, 36i подлинно. б. h6, 42i
нет, h10, 30i да, h6, 41i да. в. h13, 41i да, h11, 28i нет, h5, 26i да.
г. h15, 71i да, h11, 46i нет, h16, 74i да. д. h10, 14i нет, h24, 18i да,
h17, 8i да.
4.3. а. y = 22, r = 10, u = 15, k −1 = 15, s = 5. б. y = 9, r = 19,
u = 13, k −1 = 3, s = 17. в. y = 10, r = 21, u = 11, k −1 = 17,
s = 11 . г. y = 6 , r = 17 , u = 7 , k −1 = 19, s = 1. д. y = 11 , r = 7,
u = 18 , k −1 = 7, s = 16.
216                                   Ответы к задачам и упражнениям

4.4. а. h15; 20, 3i да ( y r = 1, rs = 19, g h = 19), h15; 10, 5i да
(y r = 1, rs = 19, g h = 19), h15; 19, 3i нет ( y r = 22, rs = 5,
g h = 19 6= 18 ). б. h5; 19, 17i да ( y r = 13, rs = 21 , g h = 20), h7; 17, 8i
нет ( y r = 3, rs = 18, g h = 17 =  6 8), h6; 17, 8i да (y r = 3, rs = 18,
  h                              r
g = 8). в. h3; 17, 12i да ( y = 17, rs = 6, g h = 10), h2; 17, 12i нет
(y r = 17 , rs = 6 , g h = 2 6= 10 ), h8; 21, 11i да ( y r = 7 , rs = 22 ,
g h = 16). г. h5; 17, 1i да ( y r = 12, rs = 17, g h = 20), h5; 11, 3i
да ( y r = 1, rs = 20, g h = 20), h5; 17, 10i нет ( y r = 12, rs = 4,
g h = 20 6= 2). д. h15; 7, 1i нет ( y r = 7, rs = 7, g h = 19 6= 3),
h10; 15, 3i да (y r = 10, rs = 17, g h = 9), h15; 7, 16i да (y r = 7,
rs = 6, g h = 19 ).
4.5. а. y = 14, r = 3, s = 8. б. y = 24, r = 3, s = 5. в. y = 40,
r = 9 , s = 2 . г. y = 22, r = 9, s = 5. д. y = 64 , r = 7 , s = 10 .
4.6. а. h10; 4, 5i нет ( h−1 = 10 , u1 = 6 , u2 = 4 , au1 = 62 , y u2 = 25 ,
v = 9 6= 4), h10; 7, 5i да ( h−1 = 10, u1 = 6, u2 = 7, au1 = 62,
y u2 = 59 , v = 7 ), h10; 3, 8i да ( h−1 = 10 , u1 = 3 , u2 = 3 , au1 = 14 ,
y u2 = 64, v = 3). б. h1; 3, 5i да ( h−1 = 1, u1 = 5, u2 = 8, au1 = 40,
y u2 = 64, v = 3), h1; 4, 3i да ( h−1 = 1, u1 = 3, u2 = 7, au1 = 14,
y u2 = 25, v = 4), h1; 4, 5i нет ( h−1 = 1, u1 = 5, u2 = 7, au1 = 40,
y u2 = 25 , v = 7 6= 4 ). в. h7; 7, 4i да ( h−1 = 8 , u1 = 10 , u2 = 10 ,
au1 = 59, y u2 = 62, v = 7), h7; 9, 2i нет ( h−1 = 8, u1 = 5, u2 = 5,
au1 = 40 , y u2 = 14, v = 2 6= 9), h5; 9, 2i да (h−1 = 9, u1 = 7, u2 = 7 ,
au1 = 9, y u2 = 22, v = 9). г. h6; 9, 5i да ( h−1 = 2, u1 = 10, u2 = 4,
au1 = 59, y u2 = 24, v = 9), h8; 8, 3i нет ( h−1 = 7, u1 = 10, u2 = 10,
au1 = 59 , y u2 = 64 , v = 2 6= 8), h7; 4, 1i да (h−1 = 8, u1 = 8, u2 = 1 ,
au1 = 24 , y u2 = 22 , v = 4 ). д. h10; 7, 3i да ( h−1 = 10 , u1 = 8 ,
u2 = 7 , au1 = 24, y u2 = 24 , v = 7 ), h7; 7, 10i да (h−1 = 8 , u1 = 3 ,
u2 = 10, au1 = 14, y u2 = 22, v = 7), h8; 7, 5i нет ( h−1 = 7, u1 = 2,
u2 = 6, au1 = 22 , y u2 = 59 , v = 3 6= 7 ).


5.1. а. dA = 17 , dB = 9 , Алиса получает γ , Боб — β ; по каналу
связи передаются числа (11, 20, 21), (11), (14, 10), (17). б. dA = 19,
dB = 3, Алиса получает γ , Боб — α ; по каналу связи передаются
числа (17, 19, 5), (19), (15, 19), (19). в. dA = 7, dB = 15, Алиса
получает α , Боб — β ; по каналу связи передаются числа (11, 7, 10),
(7), (11, 20), (21). г. dA = 5, dB = 19, Алиса получает α , Боб —
β ; по каналу связи передаются числа (21, 15, 11), (11), (10, 11), (5).
Ответы к задачам и упражнениям                                         217

д. dA = 3, dB = 9, Алиса получает α , Боб — γ ; по каналу связи
передаются числа (19, 14, 17), (19), (21, 15), (15).
5.2. а. n̂ = 103, ŝ = 52, r−1 = 24, банкнота h11, 58i. б. n̂ = 13,
ŝ = 13, r−1 = 20, банкнота h99, 22i. в. n̂ = 58, ŝ = 74, r−1 = 12,
банкнота h55, 55i. г. n̂ = 37, ŝ = 46, r−1 = 8, банкнота h44, 11i.
д. n̂ = 49, ŝ = 70 , r−1 = 4 , банкнота h77, 42i.


6.1. Из указанного списка кривой принадлежат только точки (1,1),
(2,1) и (5,8).
6.2. [2](2, 2) = (3, 5), [2](4, 6) = (1, 3), (1, 3) + (1, 4) = O , (2, 2) +
(3, 2) = (2, 5), (3, 5) + (5, 1) = (3, 2).

7.1. а. ē = 1111001110. б. ē = 1111110101. в. ē = 0001000110.
г. ē = 0101011011 . д. ē = 0001010001 .
7.2. а. P1 ≈ 0.002, P2 ≈ 0.006, P3 ≈ 0.623, P4 ≈ 0.051, P5 ≈ 0.311,
P6 ≈ 0.007. б. P1 ≈ 0.000, P2 ≈ 0.009, P3 ≈ 0.000, P4 ≈ 0.000,
P5 ≈ 0.892, P6 ≈ 0.099. в. P1 ≈ 0.000, P2 ≈ 0.697, P3 ≈ 0.000,
P4 ≈ 0.004, P5 ≈ 0.299, P6 ≈ 0.000. г. P1 ≈ 0.003, P2 ≈ 0.000,
P3 ≈ 0.036, P4 ≈ 0.000, P5 ≈ 0.801, P6 ≈ 0.160. д. P1 ≈ 0.196,
P2 ≈ 0.000, P3 ≈ 0.001, P4 ≈ 0.000, P5 ≈ 0.018, P6 ≈ 0.785.
7.3. а. H ≈ 1.16, n ≈ 6.04. б. H ≈ 0.52, n ≈ 2.42. в. H ≈ 0.9,
n ≈ 3.76. г. H ≈ 1.08, n ≈ 5.08. д. H ≈ 1.16, n ≈ 6.04.
7.4. а. P1 ≈ 0.7 ( m̄ = bcacbcacc), P2 = 0 , P3 ≈ 0.3 ( m̄ = acbcacbcc),
P4 = 0 , P5 = 0 , P6 = 0 . б. P1 = 0 , P2 = 0 , P3 = 0 , P4 ≈ 0.21 ( m̄ =
bcccaccac), P5 ≈ 0.20 ( m̄ = abbbcbbcb), P6 ≈ 0.59 ( m̄ = acccbccbc).
в. P1 = 0 , P2 = 0 , P3 = 0 , P4 = 1 ( m̄ = ccbcabccb), P5 = 0 ,
P6 = 0 . г. P1 = 0 , P2 = 0 , P3 ≈ 0.000 ( m̄ = acbbbbcbb), P4 ≈ 1.000
( m̄ = abccccbcc), P5 = 0, P6 = 0. д. P1 = 0, P2 = 0, P3 ≈ 0.009
( m̄ = bbbcbbbcb ), P4 ≈ 0.970 ( m̄ = cccbcccbc), P5 = 0 , P6 ≈ 0.021
( m̄ = cccacccac).
СПИСОК ЛИТЕРАТУРЫ




1. Ахо А., Хопкрофт Дж., Ульман Дж. Построение и анализ
   вычислительных алгоритмов. – М.: Мир, 1979. – 383 c.
2. Введение в криптографию / Под общ. ред. В. В. Ященко. – М.:
   МЦНМО: «ЧеРо», 2000. – 287 c.
3. Виноградов И. М. Основы теории чисел. – М.: Наука, 1972. –
   402 c.
4. Галлагер Р. Теория информации и надежная связь. – М.: Со-
   ветское радио, 1974. – 425 c.
5. ГОСТ 28147-89. Системы обработки информации. Защита
   криптографическая. Алгоритм криптографического преобразо-
   вания данных.
6. ГОСТ Р34.10-94. Информационная технология. Криптографи-
   ческая защита информации. Процедуры выработки и проверки
   электронной цифровой подписи на базе асимметричного крипто-
   графического алгоритма.
7. ГОСТ Р34.11-94. Информационная технология. Криптографи-
   ческая защита информации. Функция хэширования.
8. ГОСТ Р34.10-2001. Процессы формирования и проверки элек-
   тронной цифровой подписи.
9. Кнут Д. Искусство программирования для ЭВМ. В 3-х томах.
   Т. 2. Получисленные алгоритмы. – М.: Мир, 1977. – 724 с.
10. Рябко Б. Я. Просто реализуемая идеальная криптографиче-
    ская система // Проблемы передачи информации. – 2000. –
    Т. 36, № 1. – С. 90–104.
11. Рябко Б. Я. Быстрая нумерация комбинаторных объектов //
    Дискретная математика. – 1998. – Т. 10, № 2. – С. 101–119.
Список литературы                                               219

12. Рябко Б. Я. Сжатие данных с помощью стопки книг // Про-
    блемы передачи информации. – 1980. – Т. 16, № 4. – С. 16–21.

13. Рябко Б. Я., Пестунов А. И. «Стопка книг» как новый ста-
    тистический тест для случайных чисел // Проблемы передачи
    информации. – 2004. – Т. 40, № 1. – C. 73–78.
14. Рябко Б. Я., Стогниенко В. С., Шокин Ю. И. Адаптив-
    ный кpитеpий хи-квадрат для pазличения близких гипотез пpи
    большом числе классов и его пpименение к некотоpым задачам
    кpиптогpафии // Проблемы передачи информации. – 2003. –
    Т. 30, № 2. – С. 53–62.
15. Рябко Б. Я., Фионов А. Н. Быстрый метод полной рандоми-
    зации сообщений // Проблемы передачи информации. – 1997. –
    Т. 33, № 3. – C. 3–14.
16. Рябко Б. Я., Фионов А. Н. Эффективный метод адаптивного
    арифметического кодирования для источников с большими ал-
    фавитами // Проблемы передачи информации. – 1999. – Т. 35,
    № 4. – C. 1–14.
17. Феллер В. Введение в теорию вероятностей и ее приложения.
    В 2-х томах. – М.: Мир, 1984. – Т 1. – 527 с.
18. Фионов А. Н. Эффективный метод рандомизации сообщений
    на основе арифметического кодирования // Дискретный анализ
    и исследование операций. – 1997. – Т. 4, № 2. – С. 51–74.
19. Шеннон К. Работы по теории информации и кибернетике. –
    М.: ИЛ, 1963. – С. 333–369 (Теория связи в секретных системах).
20. Blake I., Seroussi G., Smart N. Elliptic Curves in Cryptography.
    – Cambridge University Press, 1999. – 204 p.
21. Daemen J., Rijmen V. The Rijndael Block Cipher.
    см. http://csrc.nist.gov/encryption/aes/rijndael/.
22. Diﬃe W., Hellman M. E. New directions in cryptography //
    IEEE Transactions on Information Theory. – 1976. – V. 22. –
    P. 644–654.
220                                             Список литературы

23. FIPS 180-1. Secure hash standard.
    см. http://csrc.nist.gov/publications/.

24. FIPS 186-2. Digital signature standard.
    см. http://csrc.nist.gov/publications/.
25. FIPS 197. Advanced encryption standard.
    см. http://csrc.nist.gov/publications/.
26. Goldwasser S., Bellare M. Lecture notes on cryptography.
    http://www-cse.ucsd.edu/users/mihir/crypto-lecnotes.html
27. Menezes A. Elliptic Curve Public Key Cryptosystems. – Kluwer
    Academic Publishers, 1993.
28. Menezes A., van Oorschot P., Vanstone S. Handbook of
    Applied Cryptography. – CRC Press, 1996. – 661 p.
    http://www.cacr.math.uwaterloo.ca/hac/.
29. Rukhin A. et al. A statistical test suite for random and
    pseudorandom number generators for cryptographic applications //
    NIST Special Publication 800-22 (rev. May,15,2001).
    http://csrc.nist.gov/rng/SP800-22b.pdf.
30. Ryabko B., Fionov A. Eﬃcient homophonic coding // IEEE
    Transactions on Information Theory. – 1999. – V. 45, N. 6. –
    P. 2083–2091.
31. Ryabko B., Fionov A. Fast and space-eﬃcient adaptive arithmetic
    coding // Cryptography and Coding. – Berlin: Springer, 1999. – P.
    270–279 (Lecture Notes in Computer Science; V. 1746).
32. Ryabko B., Matchikina E. Fast and eﬃcient construction of an
    unbiased random sequence // IEEE Transactions on Information
    Theory. – 2000. – V. 46, N 3. – P. 1090–1093.
33. Ryabko B. Ya., Monarev V. A. Using information theory
    approach to randomness testing // Journal of Statistical Planning
    and Inference. – 2005.
34. Schneier B. Applied Cryptography, Second Edition: Protocols,
    Algorthms, and Source Code in C. – Wiley, 1996.
Список литературы                                             221

35. Schneier B. Self-study course in block cipher cryptanalysis //
    Cryptologia. – 2000. – V. 24, N. 1. – P. 18–34.
    http://www.counterpane.com/self-study.html.

36. Silverman J. H. The Arithmetic of Elliptic Curves. – Springer-
    Verlag, GTM 106, 1986.
ПРЕДМЕТНЫЙ УКАЗАТЕЛЬ




алгоритм (algorithm)
    возведения в степень (exponentiation), 27, 28
    Евклида (Euclidean algorithm), 24
    исчисления порядка (index-calculus algorithm), 45
    обобщенный Евклида (extended Euclidean algorithm), 24, 25
    Схоуфа (Schoof’s algorithm), 117
    «шаг младенца, шаг великана»
         (“baby-step, giant-step” algorithm), 15, 43
    Number Field Sieve, 49
    RC4, 183
атака (attack), 8
    методом грубой силы (brute-force attack), 8
    на систему Диффи–Хеллмана, 89
    по выбранному тексту (chosen-plaintext attack), 10, 202
    по известному тексту (known-plaintext attack), 10
    по шифротексту (ciphertext-only attack), 10
    статистическая (statistical attack), 201

генератор (generator)
    линейный конгруэнтный (linear congruential generator), 180, 198
    псевдослучайных чисел (pseudo-random number generator), 192
    случайных чисел (random number generator), 190

дискретный логарифм (discrete logarithm), 13, 46
Диффи–Хеллмана система, 19, 89
доказательство с нулевым знанием (zero-knowledge proof), 70

Евклида
   алгоритм, 24
   алгоритм обобщенный, 24, 25
Предметный указатель                                         223

задача
    дискретного логарифмирования (discrete logarithm problem), 41
    дискретного логарифмирования на эллиптической кривой
        (elliptic curve discrete logarithm problem), 105
    о нахождении гамильтонова цикла
        (Hamiltonian cycle problem), 75
    о раскраске графа (graph coloring problem), 71

избыточность (redundancy), 10, 86, 142
инверсия (inverse), 26, 56

канал (channel)
    закрытый (secure channel), 6
    защищенный (secure channel), 6
    открытый (open channel), 5
ключ (key)
    открытый (public key), 19, 32, 35, 55
    раундовый (round key), 162
    секретный (secret key, private key), 7, 19, 32, 35, 55
    шифра (cipher key), 7
криптосистема (cryptosystem), 7
    строго идеальная (strongly ideal cryptosystem), 148

наибольший общий делитель (greatest common divisor), 23
Нидхама–Шредера протокол, 92

правило Керкхоффса (Kerkhoﬀs’ assumption), 8
протокол (protocol)
    взаимной идентификации (mutual identiﬁcation), 88
    идентификации (identiﬁcation protocol), 88
    криптографический (cryptographic protocol), 29, 65
    ментальный покер (mental poker), 66
    Нидхама–Шредера (Needham–Schroeder protocol), 92
    электронные деньги (digital cache protocol), 82

расстояние единственности (unicity distance), 144
раунд шифра (cipher round), 159
224                                           Предметный указатель

режим (mode)
   CBC (сцепления блоков шифра), 178
   CTR (счетчика), 182
   ECB (электронной кодовой книги), 177
   OFB (обратной связи по выходу), 181
   блокового шифра (block cipher mode), 177

сертификация открытых ключей (public key certiﬁcation), 59, 89
система
    RSA, 34, 72, 78, 84, 85, 195
    Диффи–Хеллмана, 19, 89
слепая подпись (blind signature), 84
совершенная секретность (perfect secrecy), 133, 134
сообщение (message, plaintext), 7
    подписанное (signed message), 54, 56, 60
статистический тест (statistical test), 195
стойкость шифра (cipher security), 9
структура Фейстела (Feistel structure), 161
Схоуфа алгоритм, 117

теорема
    Ферма (Fermat theorem), 22
    Эйлера (Euler theorem), 22
теоретическая стойкость (theoretical security), 132

удельная энтропия (entropy rate), 141

Фейстела структура, 161
Ферма теорема, 22
функция
   односторонняя (one-way function), 13
   односторонняя с лазейкой (trapdoor function), 34, 36
   Эйлера (Euler totient function), 21

хеш-функция (hash function), 53, 128, 185
Предметный указатель                                         225

цифровая подпись (digital signature), 53
   DSA, 59, 62
   RSA, 53
   ГОСТ Р34.10-2001, 110
   ГОСТ Р34.10-94, 59
   Эль-Гамаля, 56

числа
    взаимнопростые (coprime, relatively prime numbers), 21
    гладкие (smooth numbers), 45
число
    простое (prime number), 21
    псевдослучайное (pseudo-random number), 189
    случайное (random number), 188

Шамира шифр, 29
Шеннона
   теория секретных систем, 131, 134, 144, 148
   энтропия, 136
шифр (cipher), 6
   DES, 160
   RC5, 207, 211
   RC6, 164
   Rijndael, 107, 167
   блоковый (block cipher), 159
   Вернама, 134
   ГОСТ 28147-89, 161
   потоковый (stream cipher), 180
   строго идеальный (strongly ideal cipher), 148
   Цезаря, 6
   Шамира, 29
   Эль-Гамаля, 31
   Эль-Гамаля на эллиптической кривой, 109
шифротекст (ciphertext), 7

Эйлера
    теорема, 22
    функция, 21
электронная подпись, см. цифровая подпись
226                                         Предметный указатель

эллиптическая кривая (elliptic curve), 98
    аффинное представление (aﬃne representation), 112
    композиция точек (point composition, point addition), 100
    полином деления (division polynomial), 119
    проективное представление (projective representation), 113
    сингулярная (singular), 98
    торсионная точка (torsion point), 119
    точка в бесконечности (point at inﬁnity), 100
    удвоение точки (point doubling), 101
Эль-Гамаля
    подпись, 53
    шифр, 31, 109
энтропия, см. энтропия Шеннона
энтропия Шеннона (Shannon entropy), 136

S-бокс, 163, 168
ОГЛАВЛЕНИЕ




Предисловие . . . . . . . . . . . . . . . . . . . . . . . . . . .             3

1. Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . . . . . 11

2. Криптосистемы с открытым ключом . . . . . . . . . .                        12
   2.1. Предыстория и основные идеи . . . . . . . . . . . . . . .             12
   2.2. Первая система с открытым ключом — система Диффи–
        Хеллмана . . . . . . . . . . . . . . . . . . . . . . . . . . .        18
   2.3. Элементы теории чисел . . . . . . . . . . . . . . . . . . .           21
   2.4. Шифр Шамира . . . . . . . . . . . . . . . . . . . . . . .             28
   2.5. Шифр Эль-Гамаля . . . . . . . . . . . . . . . . . . . . .             31
   2.6. Одностороння функция с «лазейкой» и шифр RSA . .                      34
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . . . . .          38
   Темы лабораторных работ . . . . . . . . . . . . . . . . . . . .            40

3. Методы взлома шифров, основанных на дискретном
   логарифмировании . . . . . . . . . . . . . . . . . . . . .                 41
   3.1. Постановка задачи . . . . . . . . . . . . . . . . . . . . .           41
   3.2. Метод «шаг младенца, шаг великана» . . . . . . . . . .                43
   3.3. Алгоритм исчисления порядка . . . . . . . . . . . . . .               45
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . . . . .          50
   Темы лабораторных работ . . . . . . . . . . . . . . . . . . . .            51

4. Электронная, или цифровая подпись . . . . . . .               .    .   .   52
   4.1. Электронная подпись RSA . . . . . . . . . . . . . .       .   .   .   52
   4.2. Электронная подпись на базе шифра Эль-Гамаля              .   .   .   55
   4.3. Стандарты на электронную (цифровую) подпись .             .   .   .   58
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . .    .   .   .   62
   Темы лабораторных работ . . . . . . . . . . . . . . . . .      .   .   .   64
228                                                          Оглавление

5. Криптографические протоколы . . . . . . . . . . .                    . .     65
   5.1. Ментальный покер . . . . . . . . . . . . . . . . . . .          . .     65
   5.2. Доказательства с нулевым знанием . . . . . . . . . .            . .     70
        Задача о раскраске графа . . . . . . . . . . . . . . .          . .     71
        Задача о нахождении гамильтонова цикла в графе .                . .     75
   5.3. Электронные деньги . . . . . . . . . . . . . . . . . .          . .     82
   5.4. Взаимная идентификация                                           с
        установлением ключа . . . . . . . . . . . . . . . . . .         . .      88
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . . .        . .      95
   Темы лабораторных работ . . . . . . . . . . . . . . . . . .          . .      96

6. Криптосистемы на эллиптических кривых . . .                     .    .   .    97
   6.1. Введение . . . . . . . . . . . . . . . . . . . . . . . .    .   .   .    97
   6.2. Математические основы . . . . . . . . . . . . . . .         .   .   .    98
   6.3. Выбор параметров кривой . . . . . . . . . . . . . .         .   .   .   106
   6.4. Построение криптосистем . . . . . . . . . . . . . .         .   .   .   108
        Шифр Эль-Гамаля на эллиптической кривой . . .               .   .   .   109
        Цифровая подпись по ГОСТ Р34.10-2001 . . . . .              .   .   .   110
   6.5. Эффективная реализация операций . . . . . . . .             .   .   .   111
   6.6. Определение количества точек на кривой . . . . .            .   .   .   117
   6.7. Использование стандартных кривых . . . . . . . .            .   .   .   126
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . .      .   .   .   129
   Темы лабораторных работ . . . . . . . . . . . . . . . . .        .   .   .   129

7. Теоретическая стойкость криптосистем . . . . . . . . 131
   7.1. Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
   7.2. Теория систем с совершенной секретностью . . . . . . . 132
   7.3. Шифр Вернама . . . . . . . . . . . . . . . . . . . . . . . 134
   7.4. Элементы теории информации . . . . . . . . . . . . . . 135
   7.5. Расстояние единственности шифра с секретным ключом142
   7.6. Идеальные криптосистемы . . . . . . . . . . . . . . . . . 148
   Задачи и упражнения . . . . . . . . . . . . . . . . . . . . . . . 154

8. Современные шифры с секретным ключом . . .                      .    .   . 156
   8.1. Введение . . . . . . . . . . . . . . . . . . . . . . . .    .   .   . 156
   8.2. Блоковые шифры . . . . . . . . . . . . . . . . . . .        .   .   . 159
        Шифр ГОСТ 28147-89 . . . . . . . . . . . . . . . .          .   .   . 161
        Шифр RC6 . . . . . . . . . . . . . . . . . . . . . . .      .   .   . 164
        Шифр Rijndael (AES) . . . . . . . . . . . . . . . . .       .   .   . 167
Оглавление                                                                  229

   8.3. Основные режимы функционирования блоковых шиф-
        ров . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   177
        Режим ECB . . . . . . . . . . . . . . . . . . . . . . . . .         177
        Режим CBC . . . . . . . . . . . . . . . . . . . . . . . . .         178
   8.4. Потоковые шифры . . . . . . . . . . . . . . . . . . . . .           179
        Режим OFB блокового шифра . . . . . . . . . . . . . . .             181
        Режим CTR блокового шифра . . . . . . . . . . . . . . .             182
        Алгоритм RC4 . . . . . . . . . . . . . . . . . . . . . . . .        183
   8.5. Криптографические хеш-функции . . . . . . . . . . . .               185

9. Случайные числа в криптографии . . . . . . . . . . . . 188
   9.1. Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
   9.2. Задачи, возникающие при использовании физических
        генераторов случайных чисел . . . . . . . . . . . . . . . 190
   9.3. Генераторы псевдослучайных чисел . . . . . . . . . . . 192
   9.4. Тесты для проверки генераторов случайных и псевдо-
        случайных чисел . . . . . . . . . . . . . . . . . . . . . . . 195
   9.5. Статистическая атака на блоковые шифры . . . . . . . 200

Ответы к задачам и упражнениям . . . . . . . . . . . . . 214

Список литературы . . . . . . . . . . . . . . . . . . . . . . . 218

Предметный указатель . . . . . . . . . . . . . . . . . . . . . 222




                       Учебное издание
                   Борис Яковлевич Рябко
                  Андрей Николаевич Фионов
         Криптографические методы защиты информации
                       Учебное пособие
                                                    УЧЕБНОЕ ПОСОБИЕ
                                                          ДЛЯ ВЫСШИХ УЧЕБНЫХ ЗАВЕДЕНИЙ




                                              СПЕЦИАЛЬНОСТЬ
                     ISBN 978-5-9912-0286-2                                              2-е издание
Сайт издательства:

www.techbook.ru      9 785 991 20 286 2
